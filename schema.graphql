# Copyright Â© 2022-2026 IT ENGINEERING MANAGEMENT INC,
#                       <https://github.com/team113>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License v3.0 as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License v3.0 for
# more details.
#
# You should have received a copy of the GNU Affero General Public License v3.0
# along with this program. If not, see
# <https://www.gnu.org/licenses/agpl-3.0.html>.

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"Possible error codes of performing `Mutation.addChatMember`."
enum AddChatMemberErrorCode {
  """
    Authenticated `MyUser` is blocked by the `User` he tries to add to the `Chat`.

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `Chat` is not a group, so cannot accept new members.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.addUserEmail`."
enum AddUserEmailErrorCode {
  """
    Authenticated `MyUser` has its unconfirmed email address already set.

    Status code: 409 Conflict.
  """ BUSY
  """
    Email address being confirmed is occupied by another `User` already.

    Status code: 409 Conflict.
  """ OCCUPIED
  """
    Authenticated `MyUser` has reached maximum allowed number of confirmed email addresses.

    Status code: 403 Forbidden.
  """ TOO_MANY
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
}

"Possible error codes of performing `Mutation.addUserPhone`."
enum AddUserPhoneErrorCode {
  """
    Authenticated `MyUser` has its unconfirmed phone number already set.

    Status code: 409 Conflict.
  """ BUSY
  """
    Phone number being confirmed is occupied by another `User` already.

    Status code: 409 Conflict.
  """ OCCUPIED
  """
    Authenticated `MyUser` has reached maximum allowed number of confirmed phone numbers.

    Status code: 403 Forbidden.
  """ TOO_MANY
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
}

"Angle of rotating an image."
enum Angle {
  "0 degrees." DEG0
  "90 degrees." DEG90
  "180 degrees." DEG180
  "270 degrees." DEG270
}

"Possible origins of a `Balance`."
enum BalanceOrigin {
  "Income `Balance` available for withdrawal." INCOME_AVAILABLE
  "Income `Balance` on hold, not available for withdrawal." INCOME_HOLD
  "Purse `Balance`." PURSE
}

"Possible error codes of performing `Mutation.blockUser`."
enum BlockUserErrorCode {
  """
    `User` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Reason of why a `ChatCall` was finished."
enum ChatCallFinishReason {
  """
    `Chat`-dialog `ChatCall` was dropped (canceled by the caller before
    being responded).
  """ DROPPED
  "`Chat`-dialog `ChatCall` was declined by the responder." DECLINED
  """
    `Chat`-dialog responder didn't manage to answer a `ChatCall` in the
    given ringing time.
  """ UNANSWERED
  "The last member of a `ChatCall` left." MEMBER_LEFT
  """
    `ChatCall` was moved from its `Chat`-dialog to a newly created
    `Chat`-group.
  """ MOVED
  "The last member of a `ChatCall` lost connection." MEMBER_LOST_CONNECTION
  "Server decided to finish a `ChatCall` due its inner processes." SERVER_DECISION
}

"Kind of a `Chat`."
enum ChatKind {
  "`Chat` with a single member." MONOLOG
  "`Chat` between two members." DIALOG
  "`Chat` between an arbitrary number of members." GROUP
}

"Possible error codes of performing `Mutation.clearChat`."
enum ClearChatErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `ChatItem` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
}

"Possible error codes of performing `Mutation.completeOperationDeposit`."
enum CompleteOperationDepositErrorCode {
  """
    `OperationDeposit` cannot be completed immediately and will be processed in background. Try again later or use `Subscription.operationsEvents` for awaiting the correspondent `EventOperationDepositCompleted` or `EventOperationDepositFailed` upon completion.

    Status code: 202 Accepted.
  """ IN_PROGRESS
  """
    `OperationDeposit` completion is unavailable at the moment. Try again later.

    Status code: 503 Service Unavailable.
  """ UNAVAILABLE
  """
    `OperationDeposit` with the provided ID doesn't exist or the provided `OperationDepositSecret` is wrong.

    Status code: 404 Not Found.
  """ UNKNOWN_OPERATION
  """
    `OperationDeposit` is already declined and cannot be completed.

    Status code: 403 Forbidden.
  """ UNPROCESSABLE
}

"Possible error codes of performing `Mutation.createChatContact`."
enum CreateChatContactErrorCode {
  """
    `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    `ChatContact` can be created with no more than 20 initial `ChatContactRecord`s.

    Use `Mutation.createChatContactRecords` to add more, if you need so.

    Status code: 400 Bad Request.
  """ WRONG_RECORDS_COUNT
}

"Possible error codes of performing `Mutation.createChatContactRecord`."
enum CreateChatContactRecordErrorCode {
  """
    `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    Exceeded `ChatContact`'s maximum capacity of 100 `ChatContactRecord`s.

    Status code: 400 Bad Request.
  """ TOO_MANY
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
  """
    `User` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.createChatContactRecords`."
enum CreateChatContactRecordsErrorCode {
  """
    `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    Exceeded `ChatContact`'s maximum capacity of 100 `ChatContactRecord`s.

    Status code: 400 Bad Request.
  """ TOO_MANY
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
  """
    `User` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    No more than 20 initial `ChatContactRecord`s can be created at once.

    Status code: 400 Bad Request.
  """ WRONG_RECORDS_COUNT
}

"Possible error codes of performing `Mutation.createChatDirectLink`."
enum CreateChatDirectLinkErrorCode {
  """
    `Chat` is not a group, so cannot have direct links.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `ChatDirectLink` with the specified `slug` is occupied by another `User` or `Chat`-group already.

    Status code: 409 Conflict.
  """ OCCUPIED
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.createDialogChat`."
enum CreateDialogChatErrorCode {
  """
    Authenticated `MyUser` is blocked by the responder.

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    Creating a `Chat`-dialog with the authenticated `MyUser` is not possible, consider creating a `Chat`-monolog instead.

    Status code: 403 Forbidden.
  """ USE_MONOLOG
}

"Possible error codes of performing `Mutation.createGroupChat`."
enum CreateGroupChatErrorCode {
  """
    Authenticated `MyUser` is blocked by one of the members.

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    `Chat` cannot be created with more than 100 initial members.

    Status code: 400 Bad Request.
  """ WRONG_MEMBERS_COUNT
}

"Possible error codes of performing `Mutation.createOperationDeposit`."
enum CreateOperationDepositErrorCode {
  """
    `OperationDeposit` creation is unavailable at the moment. Try again later.

    Status code: 503 Service Unavailable.
  """ UNAVAILABLE
  """
    Provided `OperationDepositMethod` is unavailable.

    Status code: 451 Unavailable For Legal Reasons.
  """ UNAVAILABLE_METHOD
}

"Possible error codes of performing `Mutation.createOperationWithdraw`."
enum CreateOperationWithdrawErrorCode {
  """
    Not enough funds in `MyUser`'s income.

    Status code: 402 Payment Required.
  """ NOT_ENOUGH_FUNDS
  """
    `OperationWithdraw` creation is unavailable at the moment. Try again later.

    Status code: 503 Service Unavailable.
  """ UNAVAILABLE
  """
    Provided `OperationWithdrawMethod` is unavailable.

    Status code: 451 Unavailable For Legal Reasons.
  """ UNAVAILABLE_METHOD
}

"Possible error codes of performing `Mutation.createSession`."
enum CreateSessionErrorCode {
  """
    Provided `ConfirmationCode` is wrong or no `MyUser` exists by the provided `MyUserIdentifier`.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided password is wrong or no `MyUser` exists by the provided `MyUserIdentifier`.

    Status code: 403 Forbidden.
  """ WRONG_PASSWORD
}

"Possible error codes of performing `Mutation.createUser`."
enum CreateUserErrorCode {
  """
    Provided login is occupied by another `User` already.

    Status code: 409 Conflict.
  """ OCCUPIED
}

"Possible error codes of performing `Mutation.declineChatCall`."
enum DeclineChatCallErrorCode {
  """
    Authenticated `MyUser` joined the `ChatCall` already.

    Status code: 403 Forbidden.
  """ ALREADY_JOINED
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.declineOperationDeposit`."
enum DeclineOperationDepositErrorCode {
  """
    `OperationDeposit` with the provided ID doesn't exist or the provided `OperationDepositSecret` is wrong.

    Status code: 404 Not Found.
  """ UNKNOWN_OPERATION
  """
    `OperationDeposit` is complete or failed already and cannot be declined.

    Status code: 403 Forbidden.
  """ UNPROCESSABLE
}

"Possible error codes of performing `Mutation.deleteChatContactRecord`."
enum DeleteChatContactRecordErrorCode {
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
}

"Possible error codes of performing `Mutation.deleteChatDirectLink`."
enum DeleteChatDirectLinkErrorCode {
  """
    `Chat` is not a group, so cannot have direct links.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.deleteChatForward`."
enum DeleteChatForwardErrorCode {
  """
    Authenticated `MyUser` is not an author of the `ChatForward`.

    Status code: 403 Forbidden.
  """ NOT_AUTHOR
  """
    `ChatForward` has been replied or forwarded to another `Chat`.

    Status code: 403 Forbidden.
  """ QUOTED
  """
    `ChatForward` cannot be deleted anymore.

    `ChatForward` is allowed to be deleted only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but 5 minutes haven't passed since its posting time (`ChatMessage.at` field).

    Status code: 403 Forbidden.
  """ UNEDITABLE
  """
    `ChatForward` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
}

"Possible error codes of performing `Mutation.deleteChatMessage`."
enum DeleteChatMessageErrorCode {
  """
    Authenticated `MyUser` is not an author of the `ChatMessage`.

    Status code: 403 Forbidden.
  """ NOT_AUTHOR
  """
    `ChatMessage` has been replied or forwarded.

    Status code: 403 Forbidden.
  """ QUOTED
  """
    `ChatMessage` cannot be deleted anymore.

    `ChatMessage` is allowed to be deleted only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but:
    - doesn't contain any paid content;
    - and 5 minutes haven't passed since its posting time (`ChatMessage.at` field).

    Status code: 403 Forbidden.
  """ UNEDITABLE
  """
    `ChatMessage` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
}

"Possible error codes of performing `Mutation.deleteMyUser`."
enum DeleteMyUserErrorCode {
  """
    `MyUserCredentials` are required to be provided as the `confirmation` argument.

    Status code: 401 Unauthorized.
  """ CONFIRMATION_REQUIRED
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided `UserPassword` is wrong or the authenticated `MyUser` doesn't have one.

    Status code: 403 Forbidden.
  """ WRONG_PASSWORD
}

"Possible error codes of performing `Mutation.deleteSession`."
enum DeleteSessionErrorCode {
  """
    `MyUserCredentials` are required to be provided as the `confirmation` argument.

    Status code: 401 Unauthorized.
  """ CONFIRMATION_REQUIRED
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided `UserPassword` is wrong or the authenticated `MyUser` doesn't have one.

    Status code: 403 Forbidden.
  """ WRONG_PASSWORD
}

"Possible error codes of performing `Mutation.editChatMessage`."
enum EditChatMessageErrorCode {
  """
    Authenticated `MyUser` is blocked by the `User` who receives the `ChatMessage`.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `ChatMessage`'s text can be set as `null` only if there is at least 1 `Attachment` in it.

    Status code: 400 Bad Request.
  """ NO_CONTENT
  """
    Authenticated `MyUser` is not an author of the `ChatMessage`.

    Status code: 403 Forbidden.
  """ NOT_AUTHOR
  """
    `ChatMessage` cannot be edited anymore.

    `ChatMessage` is allowed to be edited only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but:
    - doesn't contain any paid content;
    - and 5 minutes haven't passed since its posting time (`ChatMessage.at` field).

    Status code: 403 Forbidden.
  """ UNEDITABLE
  """
    One of the specified `Attachment`s doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_ATTACHMENT
  """
    `ChatMessage` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
  """
    Replied `ChatItem` doesn't exist in the `Chat`.

    Status code: 404 Not Found.
  """ UNKNOWN_REPLYING_CHAT_ITEM
  """
    List of `Attachment`s should contain at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_ATTACHMENTS_COUNT
  """
    List of replied `ChatItem`s should contain at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_REPLYING_CHAT_ITEMS_COUNT
}

"Possible error codes of performing `Mutation.favoriteChatContact`."
enum FavoriteChatContactErrorCode {
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
}

"Possible error codes of performing `Mutation.favoriteChat`."
enum FavoriteChatErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.forwardChatItems`."
enum ForwardChatItemsErrorCode {
  """
    Authenticated `MyUser` is blocked by the `User`, who receives the `ChatForward`.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `Donation`s are disabled by responder's `MonetizationSettings`.

    Status code: 403 Forbidden.
  """ DISABLED_DONATION
  """
    All of the `ChatItemQuoteInput`s should quote either a `ChatMessageText` or at least a single `Attachment` or `Donation`.

    Status code: 400 Bad Request.
  """ NO_QUOTED_CONTENT
  """
    Not enough funds in `MyUser`'s purse.

    Status code: 402 Payment Required.
  """ NOT_ENOUGH_FUNDS
  """
    Specified `Donation`'s `Sum` is less than responder's `MonetizationSettings.min` `Price`.

    Status code: 403 Forbidden.
  """ TOO_SMALL_DONATION
  """
    Posting `donation` in this `Chat` is not allowed.

    This error can happen only if the `Chat` doesn't represent a dialog (doesn't consist only of two `User`s).

    Status code: 403 Forbidden.
  """ UNALLOWED_DONATION
  """
    One of the specified `Attachment`s doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_ATTACHMENT
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    One or more forwarded `Attachments`s don't belong to the corresponding `ChatItem`s.

    Status code: 404 Not Found.
  """ UNKNOWN_FORWARDED_ATTACHMENT
  """
    One or more forwarded `Donation`s don't belong to the corresponding `ChatItem`s.

    Status code: 404 Not Found.
  """ UNKNOWN_FORWARDED_DONATION
  """
    One or more forwarded `ChatItem`s not found.

    Status code: 404 Not Found.
  """ UNKNOWN_FORWARDED_ITEM
  """
    The `User` who receives the `ChatForward` was deleted.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    One or more forwarded `ChatItem`s have an unsupported kind. Only `ChatMessage` and `ChatForward` are allowed.

    Status code: 400 Bad Request.
  """ UNSUPPORTED_FORWARDED_ITEM
  """
    List of `Item`s to forward should contain at least 1 element and at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_ITEMS_COUNT
}

"Possible error codes of performing `Mutation.hideChat`."
enum HideChatErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.hideChatItem`."
enum HideChatItemErrorCode {
  """
    `ChatItem` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
}

"Possible error codes of performing `Mutation.joinChatCall`."
enum JoinChatCallErrorCode {
  """
    There is no ongoing `ChatCall` in this `Chat` at the moment.

    Status code: 404 Not Found.
  """ NO_CALL
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.leaveChatCall`."
enum LeaveChatCallErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `User`'s device with the provided ID doesn't participate in the `ChatCall`.

    Status code: 404 Not Found.
  """ UNKNOWN_DEVICE
}

"Code of an `OperationCancellation`."
enum OperationCancellationCode {
  """
    `Operation` was canceled because the `ChatMessage`, triggering its
    creation, was deleted.
  """ DELETED_MESSAGE
}

"Possible codes of an `OperationDepositFailure`."
enum OperationDepositFailureCode {
  "`OperationDeposit` was denied by its payment provider." DENIED
  "`OperationDeposit` expired." EXPIRED
  "Internal error occurred." INTERNAL_ERROR
  """
    `OperationDeposit` was paid with a different billing `CountryCode` than
    it had been initialized with.
  """ WRONG_BILLING_COUNTRY
}

"Possible kinds of an `OperationDeposit`."
enum OperationDepositKind {
  """
    `OperationDeposit` via [PayPal].

    [PayPal]: https://www.paypal.com
  """ PAYPAL
}

"Direction of an `Operation`."
enum OperationDirection {
  "Incoming `Operation`, meaning the funds are granted to its owner." INCOMING
  "Outgoing `Operation`, meaning the funds are charged from its owner." OUTGOING
}

"Possible origins of an `Operation`."
enum OperationOrigin {
  "`Operation` happened in the `User`'s income." INCOME
  "`Operation` happened in the `User`'s purse." PURSE
}

"Possible causes of an `OperationReward`."
enum OperationRewardCause {
  """
    `OperationReward` is caused by an affiliated `User` earning money from
    a purchase.
  """ EARN
  """
    `OperationReward` is caused by an affiliated `User` performing a
    purchase.
  """ PURCHASE
  "`OperationReward` is caused by an affiliated `User` being rewarded." REWARD
}

"Possible statuses of an `Operation`."
enum OperationStatus {
  "`Operation` is canceled." CANCELED
  "`Operation` is successfully completed." COMPLETED
  "`Operation` is declined." DECLINED
  "`Operation` is in progress." IN_PROGRESS
  "`Operation` failed." FAILED
}

"Possible codes of an `OperationWithdrawFailure`."
enum OperationWithdrawFailureCode {
  "`OperationWithdraw` was refused by its processor." REFUSED
  """
    Not enough funds in `MyUser`'s income to cover the
    `OperationWithdraw.amount`.
  """ NOT_ENOUGH_FUNDS
}

"Possible kinds of an `OperationWithdraw`."
enum OperationWithdrawKind {
  """
    `OperationWithdraw` via [SWIFT].

    [SWIFT]: https://www.swift.com
  """ SWIFT
}

"Filter of `Operation`s by their `Operation.holdUntil` field."
enum OperationsFilterHold {
  "`Operation.holdUntil` is absent." ABSENT
  "`Operation.holdUntil` is present." PRESENT
}

"Possible error codes of performing `Mutation.postChatMessage`."
enum PostChatMessageErrorCode {
  """
    Authenticated `MyUser` is blocked by the `User` who receives the `ChatMessage`.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `Donation`s are disabled by responder's `MonetizationSettings`.

    Status code: 403 Forbidden.
  """ DISABLED_DONATION
  """
    Either `text` argument, or at least one ID in `attachments` argument, or a `donation` argument should be specified.

    Status code: 400 Bad Request.
  """ NO_CONTENT
  """
    Not enough funds in `MyUser`'s purse.

    Status code: 402 Payment Required.
  """ NOT_ENOUGH_FUNDS
  """
    Specified `Donation`'s `Sum` is less than responder's `MonetizationSettings.min` `Price`.

    Status code: 403 Forbidden.
  """ TOO_SMALL_DONATION
  """
    Posting `Donation` in this `Chat` is not allowed.

    This error can happen only if the `Chat` doesn't represent a dialog (doesn't consist only of two `User`s).

    Status code: 403 Forbidden.
  """ UNALLOWED_DONATION
  """
    One of the specified `Attachment`s doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_ATTACHMENT
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    Replied `ChatItem` doesn't exist in the `Chat`.

    Status code: 404 Not Found.
  """ UNKNOWN_REPLYING_CHAT_ITEM
  """
    The `User` who receives the `ChatMessage` was deleted.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    List of `Attachment`s should contain at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_ATTACHMENTS_COUNT
  """
    List of replied `ChatItem`s should contain at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_REPLYING_CHAT_ITEMS_COUNT
}

"Possible error codes of performing `Mutation.readChat`."
enum ReadChatErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `ChatItem` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_ITEM
}

"Possible error codes of performing `Mutation.redialChatCallMember`."
enum RedialChatCallMemberErrorCode {
  """
    There is no ongoing `ChatCall` in this `Chat` at the moment.

    Status code: 404 Not Found.
  """ NO_CALL
  """
    Authenticated `MyUser` doesn't participate in the ongoing `ChatCall`.

    Status code: 403 Forbidden.
  """ NOT_CALL_MEMBER
  """
    Redialed `User` is not a member of this `Chat`.

    Status code: 403 Forbidden.
  """ NOT_CHAT_MEMBER
  """
    `Chat` is not a group, so cannot redial its members.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.refreshSession`."
enum RefreshSessionErrorCode {
  """
    Provided `RefreshTokenSecret` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_REFRESH_TOKEN
}

"Possible error codes of performing `Mutation.registerPushDevice`."
enum RegisterPushDeviceErrorCode {
  """
    Provided `PushDeviceToken` is occupied already by another push device of the authenticated `MyUser`.

    Status code: 409 Conflict.
  """ OCCUPIED
  """
    Push notifications service provider is temporary unavailable. Retry later.

    Status code: 503 Service Unavailable.
  """ UNAVAILABLE
  """
    Unknown `PushDeviceToken` provided.

    Status code: 404 Not Found.
  """ UNKNOWN_DEVICE_TOKEN
}

"Possible error codes of performing `Mutation.removeChatCallMember`."
enum RemoveChatCallMemberErrorCode {
  """
    `Chat` is not a group, so cannot remove members from its calls.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `User` with the provided ID is not a member of the group.

    Status code: 400 Bad Request.
  """ NOT_MEMBER
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.removeChatMember`."
enum RemoveChatMemberErrorCode {
  """
    `Chat` is not a group, so cannot remove its members.

    Status code: 403 Forbidden.
  """ NOT_GROUP
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.removeUserEmail`."
enum RemoveUserEmailErrorCode {
  """
    `MyUserCredentials` are required to be provided as the `confirmation` argument.

    Status code: 401 Unauthorized.
  """ CONFIRMATION_REQUIRED
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided `UserPassword` is wrong or the authenticated `MyUser` doesn't have one.

    Status code: 403 Forbidden.
  """ WRONG_PASSWORD
}

"Possible error codes of performing `Mutation.removeUserPhone`."
enum RemoveUserPhoneErrorCode {
  """
    `MyUserCredentials` are required to be provided as the `confirmation` argument.

    Status code: 401 Unauthorized.
  """ CONFIRMATION_REQUIRED
  """
    Provided `ConfirmationCode` is wrong.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided `UserPassword` is wrong or the authenticated `MyUser` doesn't have one.

    Status code: 403 Forbidden.
  """ WRONG_PASSWORD
}

"Possible error codes of performing `Mutation.renameChat`."
enum RenameChatErrorCode {
  """
    `Chat` represents a dialog, so cannot be renamed.

    Status code: 403 Forbidden.
  """ DIALOG
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.startChatCall`."
enum StartChatCallErrorCode {
  """
    Authenticated `MyUser` is blocked by the `User`, who responds to the `ChatCall`.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    The `User` who responds to the `ChatCall` was deleted.

    This error can happen only if the `Chat` represents a dialog (consists only of two `User`s).

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.toggleChatArchivation`."
enum ToggleChatArchivationErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.toggleChatCallHand`."
enum ToggleChatCallHandErrorCode {
  """
    There is no ongoing `ChatCall` in this `Chat` at the moment.

    Status code: 404 Not Found.
  """ NO_CALL
  """
    Authenticated `MyUser` doesn't participate in the ongoing `ChatCall`.

    Status code: 403 Forbidden.
  """ NOT_CALL_MEMBER
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.toggleChatMute`."
enum ToggleChatMuteErrorCode {
  """
    `Chat` represents a monolog, so cannot be (un)muted.

    Status code: 403 Forbidden.
  """ MONOLOG
  """
    Mute duration cannot be shorter than one minute.

    Status code: 400 Bad Request.
  """ TOO_SHORT
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.toggleMyUserMute`."
enum ToggleMyUserMuteErrorCode {
  """
    Mute duration cannot be shorter than one minute.

    Status code: 400 Bad Request.
  """ TOO_SHORT
}

"Possible error codes of performing `Mutation.transformDialogCallIntoGroupCall`."
enum TransformDialogCallIntoGroupCallErrorCode {
  """
    Authenticated `MyUser` is blocked by one of the specified members.

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    There is no ongoing `ChatCall` in this `Chat` at the moment.

    Status code: 404 Not Found.
  """ NO_CALL
  """
    Specified `Chat` is not a dialog, so its call cannot be transformed into a group call.

    Status code: 403 Forbidden.
  """ NOT_DIALOG
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    `User` with the provided ID doesn't exist or was deleted.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
  """
    `Chat` cannot be created with more than 100 initial members.

    Status code: 400 Bad Request.
  """ WRONG_MEMBERS_COUNT
}

"Possible error codes of performing `Mutation.unblockUser`."
enum UnblockUserErrorCode {
  """
    `User` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.unfavoriteChatContact`."
enum UnfavoriteChatContactErrorCode {
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
}

"Possible error codes of performing `Mutation.unfavoriteChat`."
enum UnfavoriteChatErrorCode {
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
}

"Possible error codes of performing `Mutation.unregisterPushDevice`."
enum UnregisterPushDeviceErrorCode {
  """
    Push notifications service provider is temporary unavailable. Retry later.

    Status code: 503 Service Unavailable.
  """ UNAVAILABLE
}

"Possible error codes of performing `Mutation.updateChatAvatar`."
enum UpdateChatAvatarErrorCode {
  """
    `Chat` represents a dialog, so cannot have avatars.

    Status code: 403 Forbidden.
  """ DIALOG
  """
    Point coordinates of `crop` area are negative or bigger than original image dimensions.

    Status code: 400 Bad Request.
  """ INVALID_CROP_COORDINATES
  """
    Top left point coordinates of `crop` area must be smaller than bottom right ones and `crop` area dimensions must be greater than zero.

    Status code: 400 Bad Request.
  """ INVALID_CROP_POINTS
  """
    Uploaded image has too big dimensions.

    Status code: 400 Bad Request.
  """ INVALID_DIMENSIONS
  """
    Uploaded file is too big or zero in size.

    Status code: 400 Bad Request.
  """ INVALID_SIZE
  """
    Uploaded file cannot be decoded as an image.

    Status code: 400 Bad Request.
  """ MALFORMED
  """
    `Chat` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT
  """
    Uploaded file has unsupported MIME type.

    Status code: 400 Bad Request.
  """ UNSUPPORTED_FORMAT
}

"Possible error codes of performing `Mutation.updateChatContactName`."
enum UpdateChatContactNameErrorCode {
  """
    `ChatContact` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_CHAT_CONTACT
}

"Possible error codes of performing `Mutation.updateMonetizationSettings`."
enum UpdateMonetizationSettingsErrorCode {
  """
    Individual `MonetizationSettings` cannot be set for the the authenticated `MyUser`.

    Status code: 403 Forbidden.
  """ SAME_USER
  """
    Common `MonetizationSettings` cannot be deleted.

    Status code: 403 Forbidden.
  """ UNDELETABLE
  """
    `User` with the provided ID doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_USER
}

"Possible error codes of performing `Mutation.updateUserAvatar`."
enum UpdateUserAvatarErrorCode {
  """
    Point coordinates of `crop` area are negative or bigger than original image dimensions.

    Status code: 400 Bad Request.
  """ INVALID_CROP_COORDINATES
  """
    Top left point coordinates of `crop` area must be smaller than bottom right ones and `crop` area dimensions must be greater than zero.

    Status code: 400 Bad Request.
  """ INVALID_CROP_POINTS
  """
    Uploaded image has too big dimensions.

    Status code: 400 Bad Request.
  """ INVALID_DIMENSIONS
  """
    Uploaded file is too big or zero in size.

    Status code: 400 Bad Request.
  """ INVALID_SIZE
  """
    Uploaded file cannot be decoded as an image.

    Status code: 400 Bad Request.
  """ MALFORMED
  """
    Uploaded file has unsupported MIME type.

    Status code: 400 Bad Request.
  """ UNSUPPORTED_FORMAT
}

"Possible error codes of performing `Mutation.updateUserCallCover`."
enum UpdateUserCallCoverErrorCode {
  """
    Point coordinates of `crop` area are negative or bigger than original image dimensions.

    Status code: 400 Bad Request.
  """ INVALID_CROP_COORDINATES
  """
    Top left point coordinates of `crop` area must be smaller than bottom right ones and `crop` area dimensions must be greater than zero.

    Status code: 400 Bad Request.
  """ INVALID_CROP_POINTS
  """
    Uploaded image has too big dimensions.

    Status code: 400 Bad Request.
  """ INVALID_DIMENSIONS
  """
    Uploaded file is too big or zero in size.

    Status code: 400 Bad Request.
  """ INVALID_SIZE
  """
    Uploaded file cannot be decoded as an image.

    Status code: 400 Bad Request.
  """ MALFORMED
  """
    Uploaded file has unsupported MIME type.

    Status code: 400 Bad Request.
  """ UNSUPPORTED_FORMAT
}

"Possible error codes of performing `Mutation.updateUserLogin`."
enum UpdateUserLoginErrorCode {
  """
    Provided `login` is occupied by another `User` already.

    Status code: 409 Conflict.
  """ OCCUPIED
}

"Possible error codes of performing `Mutation.updateUserPassword`."
enum UpdateUserPasswordErrorCode {
  """
    `MyUserCredentials` are required to be provided as the `confirmation` argument.

    Status code: 401 Unauthorized.
  """ CONFIRMATION_REQUIRED
  """
    Provided `ConfirmationCode` is wrong or no `MyUser` exists by the provided `MyUserIdentifier`.

    Status code: 403 Forbidden.
  """ WRONG_CODE
  """
    Provided old `UserPassword` is wrong or no `MyUser` exists by the provided `MyUserIdentifier`.

    Status code: 403 Forbidden.
  """ WRONG_OLD_PASSWORD
}

"Possible error codes of performing `Mutation.updateWelcomeMessage`."
enum UpdateWelcomeMessageErrorCode {
  """
    `WelcomeMessage.text` can be set as `null` only if there is at least 1 `WelcomeMessage.attachments`.

    Status code: 400 Bad Request.
  """ NO_CONTENT
  """
    One of the specified `Attachment`s doesn't exist.

    Status code: 404 Not Found.
  """ UNKNOWN_ATTACHMENT
  """
    List of `Attachment`s should contain at most 100 elements.

    Status code: 400 Bad Request.
  """ WRONG_ATTACHMENTS_COUNT
}

"Possible error codes of performing `Mutation.uploadAttachment`."
enum UploadAttachmentErrorCode {
  """
    Uploaded image has too big dimensions.

    Status code: 400 Bad Request.
  """ INVALID_DIMENSIONS
  """
    Uploaded file is too big or zero in size.

    Status code: 400 Bad Request.
  """ INVALID_SIZE
  """
    Uploaded image cannot be decoded as an image.

    Status code: 400 Bad Request.
  """ MALFORMED
  """
    No filename found in a [Content-Disposition][1] header.

    [1]: https://mdn.io/Web/HTTP/Headers/Content-Disposition

    Status code: 400 Bad Request.
  """ NO_FILENAME
}

"Possible error codes of performing `Mutation.useChatDirectLink`."
enum UseChatDirectLinkErrorCode {
  """
    Authenticated `MyUser` is blocked by the responder.

    Status code: 403 Forbidden.
  """ BLOCKED
  """
    `ChatDirectLink` with the provided slug doesn't exist or is not active anymore.

    Status code: 404 Not Found.
  """ UNKNOWN_DIRECT_LINK
}

"Presence manually set by a `User` to himself."
enum UserPresence {
  """
    `User` is currently present and expected to see notifications right
    away.

    This is the default `UserPresence` all `User`s have.
  """ PRESENT
  """
    `User` is away and expected to see notifications as soon as he comes
    back.
  """ AWAY
}

"Possible error codes of performing `Mutation.validateConfirmationCode`."
enum ValidateConfirmationCodeErrorCode {
  """
    Provided `ConfirmationCode` is wrong or no `MyUser` exists by the provided `MyUserIdentifier`.

    Status code: 403 Forbidden.
  """ WRONG_CODE
}

"Input of `BankAccountRequisites`."
input BankAccountRequisitesInput {
  "`IBAN` of the account." iban: IBAN!
  "Requisites of the bank the account belongs to." bank: BankRequisitesInput!
}

"Input of `BankRequisites`."
input BankRequisitesInput {
  "`BIC` of the bank." bic: BIC!
  "Name of the bank." name: BankName!
  "Address of the bank." address: BankAddress!
}

"""
  Input type representing a record of a `ChatContact`.

  Exactly one field should be set.
"""
input ChatContactRecord {
  "`User` record." userId: UserId
  "`Chat`-group record." groupId: ChatId
  "`UserEmail` record." email: UserEmail
  "`UserPhone` record." phone: UserPhone
}

"`ChatItem`'s quote used as input of `Mutation.forwardChatItems`."
input ChatItemQuoteInput {
  "ID of the `ChatItem` to be forwarded." id: ChatItemId!
  """
    Indicator whether a forward should contain the full `ChatMessageText` of
    the original `ChatItem`, if it contains any.
  """ withText: Boolean!
  """
    IDs of the `ChatItem`'s `Attachment`s to be forwarded.

    - `null` means all the `ChatItem`'s `Attachment`s will be forwarded, if
      any.
    - `[]` (empty list) means no `Attachment`s will be forwarded.
  """ attachments: [AttachmentId!]
  """
    IDs of the `ChatItem`'s `Donation`s to be forwarded.

    - `null` means all the `ChatItem`'s `Donation`s will be forwarded, if
      any.
    - `[]` (empty list) means no `Donation`s will be forwarded.
  """ donations: [DonationId!]
}

"Criteria for filtering `ChatItem`s by, returned in a `ChatItemsConnection`."
input ChatItemsFilter {
  """
    Indicator whether to filter out all the `ChatItem`s without attachments.

    Applies to `ChatMessage`s and `ChatForward`s only.
  """ onlyAttachments: Boolean
  """
    `ChatMessageText` that returned `ChatItems`s should contain.

    The match is case-insensitive.

    Applies to `ChatMessage`s and `ChatForward`s only.
  """ withText: ChatMessageText
}

"`Attachment`s used as input of `Mutation.editChatMessage`."
input ChatMessageAttachmentsInput {
  """
    IDs of new `Attachment`s.

    Empty list means that the previous `Attachment`s should be deleted.
  """ new: [AttachmentId!]!
}

"Replied `ChatItem`s used as input of `Mutation.editChatMessage`."
input ChatMessageRepliesInput {
  """
    IDs of new replied `ChatItem`s.

    Empty list means that the previous `ChatItemQuote`s should be deleted.
  """ new: [ChatItemId!]!
}

"`ChatMessageText` used as input of `Mutation.editChatMessage`."
input ChatMessageTextInput {
  """
    New `ChatMessageText`.

    `null` means that the previous `ChatMessageText` should be deleted.
  """ new: ChatMessageText
}

"""
  Input area for an image cropping.

  Same as `CropArea`, but for using in arguments.

  Top left corner of the rotated by `angle` image is considered as `(0, 0)`
  coordinates start point. So, obviously, `CropAreaInput.bottomRight` point's
  coordinates should be bigger than the ones of `CropAreaInput.topLeft` point.
"""
input CropAreaInput {
  "`PointInput` of a top left corner of this cropping area." topLeft: PointInput!
  "`PointInput` of a bottom right corner of this cropping area." bottomRight: PointInput!
  "Angle to rotate image before cropping." angle: Angle
}

"Half-open range of `DateTime`s."
input DateTimeRange {
  """
    `DateTime` the range starts from (inclusive).

    If absent or `null` then no lower bound is applied.
  """ from: DateTime
  """
    `DateTime` the range ends at (exclusive).

    If absent or `null` then no upper bound is applied.
  """ to: DateTime
}

"Input of a `Donation` attached to a `Message`."
input DonationInput {
  """
    `Sum` of the `Donation` to be made.

    Cannot be zero.
  """ sum: Sum!
}

"""
  Details of a `ChatMessage` to be posted along with the forwarded `ChatItem`s
  used as input of `Mutation.forwardChatItems`.

  If all fields are not specified or `null`, then no `ChatMessage` will be
  posted.
"""
input ForwardChatItemsMessageInput {
  """
    Optional text to post a `ChatMessage` along with the forwarded
    `ChatItem`s.
  """ text: ChatMessageText
  """
    Optional IDs of `Attachment`s to be attached to the `ChatMessage`
    posted along with the forwarded `ChatItem`s.
  """ attachments: [AttachmentId!]
  """
    Optional `Donation` to be attached to the `ChatMessage` posted along
    with the forwarded `ChatItem`s.

    `Donation`s are allowed in dialog `Chat`s only.
  """ donation: DonationInput
}

"Input for updating or deleting `MonetizationSettingsDonation`."
input MonetizationSettingsDonationInput {
  """
    New `MonetizationSettingsDonation`.

    `null` means that the previous `MonetizationSettingsDonation` should be
    deleted.
  """ new: MonetizationSettingsDonationSettingsInput
}

"Input for creating or updating `MonetizationSettingsDonation`."
input MonetizationSettingsDonationSettingsInput {
  "Indicator whether the `Vendor` accepts `Donation`s or not." enabled: Boolean!
  """
    Minimal `Sum` of `Donation`s allowed in the `Chat` with the `Vendor`.

    Integer-only, meaning that its fractional part should be zero.
  """ min: Sum!
}

"Filter of the `Subscription.monetizationSettings`."
input MonetizationSettingsFilter {
  """
    Indicator whether to return only `MonetizationSettingsEvent`s related to
    `MonetizationSettingsDonation`.

    If no `MonetizationSettingsFilter` is provided, then this field defaults
    to `true`.
  """ donation: Boolean!
}

"Input for updating `MonetizationSettings`."
input MonetizationSettingsInput {
  """
    New `MonetizationSettingsDonation`.

    `null` means that the previous `MonetizationSettingsDonation` remain
    unchanged.
  """ donation: MonetizationSettingsDonationInput
}

"""
  [Arguments] for pagination over `MonetizationSettingsEdge`s.

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` `MonetizationSettingsCursor`s are equal.
  In such case, the returned page will include the `MonetizationSettings`
  pointed by that `MonetizationSettingsCursor` and the requested counts of
  `MonetizationSettings` preceding and following it.

  If it's desired to receive the `MonetizationSettings`, pointed by the
  `MonetizationSettingsCursor`, without querying in both directions, one can
  specify `first` or `last` count as `0`.

  If no parameters are provided, then `first` parameter will be considered as
  `50`.

  `after` and `before` `MonetizationSettingsCursor`s are only meaningful once
  other non-`MonetizationSettingsPagination` arguments remain the same between
  queries. Trying to query a page of some filtered `MonetizationSettings` with
  a `MonetizationSettingsCursor` pointing to a page of totally different
  filtered `MonetizationSettings` is nonsense and will produce an invalid
  result (usually, returning nothing).

  [Arguments]: https://tinyurl.com/gql-relay#sec-Arguments
"""
input MonetizationSettingsPagination {
  "Number of next `MonetizationSettingsEdge`s to return." first: Int
  """
    `MonetizationSettingsCursor` indicating the `MonetizationSettingsEdge`
    position to return next `MonetizationSettings` after.
  """ after: MonetizationSettingsCursor
  "Number of prior `MonetizationSettingsEdge`s to return." last: Int
  """
    `MonetizationSettingsCursor` indicating the `MonetizationSettingsEdge`
    position to return prior `MonetizationSettings` before.
  """ before: MonetizationSettingsCursor
}

"""
  Muting input argument for `Mutation.toggleChatMute` and
  `Mutation.toggleMyUserMute`.
"""
input Muting {
  """
    `DateTime` until a `Chat` (or the authenticated `MyUser`) is muted.

    `null` means indefinite muting.
  """ duration: DateTime
}

"Filter of the `Query.myMonetizationSettings`."
input MyMonetizationSettingsFilter {
  """
    Unique ID of a `User` the `MonetizationSettings` are specified
    individually for.

    Searching by `MyMonetizationSettingsFilter.userId` is exact, always
    returning a single `MonetizationSettingsEdge`.

    If the provided `UserId` is the same as `MyUser.id`, then a single
    `MonetizationSettingsEdge` will be returned, containing common
    `MonetizationSettings` of the authenticated `MyUser` (applied to all
    `User`s).

    If absent or `null` then individual `MonetizationSettings` for all
    `User`s will be returned, also including the common ones.
  """ userId: UserId
  """
    Indicator whether to return only `MonetizationSettings` which have
    `MonetizationSettings.donation` field specified.

    If no `MyMonetizationSettingsFilter` is provided, then this field
    defaults to `true`.
  """ donation: Boolean!
}

"""
  Possible credentials for authentication of a `MyUser`.

  Exactly one should be specified.
"""
input MyUserCredentials {
  """
    Single-use `ConfirmationCode` generated by the `MyUser`.

    Use the `Mutation.createConfirmationCode` to create and send a new one.
  """ code: ConfirmationCode
  "Current password of the `MyUser`." password: UserPassword
}

"""
  Possible identifiers of a `MyUser`.

  Exactly one should be specified.
"""
input MyUserIdentifier {
  "Unique `UserNum` identifying the `MyUser`." num: UserNum
  "Unique `UserLogin` identifying the `MyUser`." login: UserLogin
  "Unique `UserEmail` address identifying the `MyUser`." email: UserEmail
  "Unique `UserPhone` number identifying the `MyUser`." phone: UserPhone
}

"""
  Input for creating an `OperationDeposit` of a specific
  `OperationDepositKind`.

  Exactly one should be specified.
"""
input OperationDepositInput {
  "Input of an `OperationDepositKind.PAYPAL`." paypal: OperationDepositPayPalInput
}

"Input of an `OperationDepositKind.PAYPAL`."
input OperationDepositPayPalInput {
  """
    Nominal `Sum` to be deposited in XXX.

    Integer-only, meaning that its fractional part should be zero.
  """ nominal: Sum!
  """
    Secret for authenticating later client operations on the created
    `OperationDeposit`.
  """ secret: OperationDepositSecret!
}

"""
  Possible identifiers of an `Operation`.

  Exactly one should be specified.
"""
input OperationIdentifier {
  "Unique `OperationId` identifying the `Operation`." id: OperationId
  "Unique `OperationNum` identifying the `Operation`." num: OperationNum
}

"""
  Input for creating an `OperationWithdraw` of a specific
  `OperationWithdrawKind`.

  Exactly one should be specified.
"""
input OperationWithdrawInput {
  "Input of an `OperationWithdrawKind.SWIFT`." swift: OperationWithdrawSwiftInput
}

"Input of an `OperationWithdrawKind.SWIFT`."
input OperationWithdrawSwiftInput {
  "Information about the beneficiary bank account." beneficiary: BankAccountRequisitesInput!
  "Information about the intermediary bank account." intermediary: BankAccountRequisitesInput
}

"Filter of the `Query.operations`."
input OperationsFilter {
  """
    Unique ID of an `Operation` to search by.

    Searching by `OperationsFilter.id` is exact, always returning a single
    `Operation`.
  """ id: OperationId
  """
    Sequential number of an `Operation` to search by.

    Searching by `OperationsFilter.num` is exact, always returning a single
    `Operation`.
  """ num: OperationNum
  """
    `OperationStatus` of the `Operation`s to filter by.

    If absent or `null` then `Operation`s of all `OperationStatus`es will be
    returned.
  """ status: OperationStatus
  """
    Filtering `Operation`s by being in hold.

    If absent or `null` then `Operation`s with no filtering by being in hold
    will be returned.
  """ hold: OperationsFilterHold
  """
    `OperationDirection` of the `Operation`s to filter by.

    If absent or `null` then `Operation`s of all `OperationDirection`s will
    be returned.
  """ direction: OperationDirection
  """
    `DateTimeRange` to filter the `Operation`s by their
    `Operation.createdAt` field.
  """ createdAt: DateTimeRange
}

"""
  [Arguments] for pagination over `OperationsEdge`s.

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` `OperationsCursor`s are equal. In such
  case, the returned page will include the `Operation` pointed by that
  `OperationsCursor` and the requested counts of `Operation`s preceding and
  following it.

  If it's desired to receive the `Operation`, pointed by the
  `OperationsCursor`, without querying in both directions, one can specify
  `first` or `last` count as `0`.

  If no parameters are provided, then `first` parameter will be considered as
  `50`.

  `after` and `before` `OperationsCursor`s are only meaningful once other
  non-`OperationsPagination` arguments remain the same between queries. Trying
  to query a page of some filtered `Operation`s with an `OperationsCursor`
  pointing to a page of totally different filtered `Operation`s is nonsense
  and will produce an invalid result (usually, returning nothing).

  [Arguments]: https://tinyurl.com/gql-relay#sec-Arguments
"""
input OperationsPagination {
  "Number of next `OperationsEdge`s to return." first: Int
  """
    `OperationsCursor` indicating the `OperationsEdge` position to return
    next `Operation`s after.
  """ after: OperationsCursor
  "Number of prior `OperationsEdge`s to return." last: Int
  """
    `OperationsCursor` indicating the `OperationsEdge` position to return
    prior `Operation`s before.
  """ before: OperationsCursor
}

"""
  2D point on an image.

  Same as `Point`, but for using in arguments.
"""
input PointInput {
  "X coordinate of this `PointInput` in `px` (pixels)." x: Int!
  "Y coordinate of this `PointInput` in `px` (pixels)." y: Int!
}

"""
  Pagination arguments of the `Query.promoShareHistory`.

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `PromoShare` pointed by the cursor and the
  requested count of `PromoShare`s preceding and following it.

  If it's desired to receive the `PromoShare`, pointed by the cursor, without
  querying in both directions, one can specify `first` or `last` count as `0`.

  If no arguments are provided, then `first` argument will be considered
  as `50`.
"""
input PromoShareHistoryPagination {
  "Number of next `PromoShare`s to return." first: Int
  """
    Cursor indicating the `PromoShareHistoryEdge` position to return next
    `PromoShare`s after.
  """ after: PromoShareHistoryCursor
  "Number of prior `PromoShare`s to return." last: Int
  """
    Cursor indicating the `PromoShareHistoryEdge` position to return prior
    `PromoShare`s before.
  """ before: PromoShareHistoryCursor
}

"Settings of a push device registration."
input PushDeviceSettings {
  """
    Indicator whether the push device should receive cancellations for push
    notifications as well.

    Defaults to `false`.
  """ cancellation: Boolean! = false
}

"""
  Possible identifiers of `MyUser`'s push device token.

  Exactly one should be specified.
"""
input PushDeviceToken {
  """
    [Apple Push Notification service][0] device token.

    [0]: https://developer.apple.com/documentation/usernotifications
  """ apns: ApnsDeviceToken
  """
    [Apple Push Notification service][0] [VoIP] device token.

    [0]: https://developer.apple.com/documentation/usernotifications
    [VoIP]: https://wikipedia.org/wiki/Voice_over_IP
  """ apnsVoip: ApnsVoipDeviceToken
  """
    [Firebase Cloud Messaging][0] registration token.

    [0]: https://firebase.google.com/docs/cloud-messaging
  """ fcm: FcmRegistrationToken
}

"""
  Filter of the `Query.recentChats` and the
  `Subscription.recentChatsTopEvents`.
"""
input RecentChatsFilter {
  """
    Indicator whether favorite `Chat`s should be excluded from the result.

    `null` or `false` means omitting filtering by this criterion.

    To get list of favorite `Chat`s only, use `Query.favoriteChats`.
  """ noFavorite: Boolean
  """
    Indicator whether only `Chat`s with ongoing calls should be included
    into the result (`true`), or whether they should be excluded from the
    result (`false`).

    `null` means omitting filtering by this criterion.
  """ ongoingCalls: Boolean
  """
    Indicator whether only archived `Chat`s should be included into the
    result (`true`), or whether they should be excluded from the result
    (`false`).

    `null` means omitting filtering by this criterion.
  """ archived: Boolean
}

"""
  Pagination arguments of the `Query.recentChats`.

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `Chat` pointed by the cursor and the
  requested count of `Chat`s preceding and following it.

  If it's desired to receive the `Chat`, pointed by the cursor, without
  querying in both directions, one can specify `first` or `last` count as `0`.

  If no arguments are provided, then `first` parameter will be considered as
  `50`.
"""
input RecentChatsPagination {
  "Number of next `RecentChatsEdge`s to return." first: Int
  """
    Cursor indicating the `RecentChatsEdge` position to return next
    `RecentChatsEdge`s after.
  """ after: RecentChatsCursor
  "Number of prior `RecentChatsEdge`s to return." last: Int
  """
    Cursor indicating the `RecentChatsEdge` position to return prior
    `RecentChatsEdge`s before.
  """ before: RecentChatsCursor
}

"Client-provided secrets for `Mutation.refreshSession`."
input RefreshSessionSecretsInput {
  "New `AccessTokenSecretInput` for the `Session` being authenticated with." accessToken: AccessTokenSecretInput!
  "New `RefreshTokenSecretInput` for the `Session` being refreshed with." refreshToken: RefreshTokenSecretInput!
}

"""
  Arguments for affiliation of a created `MyUser` in `Mutation.createUser` and
  `Mutation.createSession`.
"""
input UserAffiliationInput {
  """
    [Slug][slug] value of the `ChatDirectLink` the `User` found the `Site`
    by.

    [slug]: https://en.wikipedia.org/wiki/Clean_URL#Slug
  """ slug: ChatDirectLinkSlug!
}

"""
  Content of a `WelcomeMessage`, used as an input of
  `Mutation.updateWelcomeMessage`.
"""
input WelcomeMessageInput {
  """
    New text to assign to the `WelcomeMessage`.

    - If `null`, then the previous `WelcomeMessage.text` will remain
      unchanged.
    - If `ChatMessageTextInput.new` is empty, then the previous
      `WelcomeMessage.text` will be deleted.
    - Otherwise, the specified `ChatMessageTextInput.new` will replace the
      previous `WelcomeMessage.text`.

    `ChatMessageTextInput.new` can be `null` only if the resulting
    `WelcomeMessage` has at least one `Attachment`.

    Mandatory, if the `attachments` argument is absent or `null`.
  """ text: ChatMessageTextInput
  """
    IDs of `Attachment`s to assign to the `WelcomeMessage`.

    - If `null`, then the previous `WelcomeMessage.attachments` will remain
      unchanged.
    - If `ChatMessageAttachmentsInput.new` is empty, then the previous
      `WelcomeMessage.attachments` will be deleted.
    - Otherwise, the specified `ChatMessageAttachmentsInput.new` will
      replace the previous `WelcomeMessage.attachments`.

    `ChatMessageAttachmentsInput.new` can be empty only if the resulting
    `WelcomeMessage` has its `ChatMessageText`.

    Mandatory, if the `text` argument is absent or `null`.
  """ attachments: ChatMessageAttachmentsInput
}

"""
  Attachment of a `ChatItem`.

  `Mutation.uploadAttachment` expects to find a `filename` in a
  [Content-Disposition][1] header.

  Field `original` will return path to the file named `orig`. To download this
  file with the original name, set the [`download`][2] attribute on `<a>` HTML
  element to the value of the `filename` field.

  [1]: https://mdn.io/Web/HTTP/Headers/Content-Disposition#directives
  [2]: https://mdn.io/Web/HTML/Element/A#attributes
"""
interface Attachment {
  "Unique ID of this `Attachment`."
  id: AttachmentId!
  "Original `File` representing this `Attachment`."
  original: File!
  "Uploaded `File`'s name."
  filename: String!
}

"Event of a `User` being added or removed to/from `Query.blocklist`."
interface BlocklistEvent {
  "`User` this `BlocklistEvent` is about."
  user: User!
  "`DateTime` when this `BlocklistEvent` happened."
  at: DateTime!
}

"Events happening in a `ChatCall`."
interface ChatCallEvent {
  "ID of the `ChatCall` this `ChatCallEvent` is related to."
  callId: ChatItemId!
  "ID of the `Chat` this `ChatCallEvent` is happened in."
  chatId: ChatId!
  "`DateTime` when this `ChatCallEvent` happened."
  at: DateTime!
}

"Events happening in a `ChatContact`."
interface ChatContactEvent {
  "ID of the `ChatContact` this `ChatContactEvent` is related to."
  contactId: ChatContactId!
  "`DateTime` when this `ChatContactEvent` happened."
  at: DateTime!
}

"Events happening in a `Chat`."
interface ChatEvent {
  "ID of the `Chat` this `ChatEvent` is related to."
  chatId: ChatId!
}

"Item posted in a `Chat` (its content)."
interface ChatItem {
  "Unique ID of this `ChatItem`."
  id: ChatItemId!
  "ID of the `Chat` this `ChatItem` is posted in."
  chatId: ChatId!
  "`User` who posted this `ChatItem`."
  author: User!
  """
    ID of the `ChatItem`s' batch this `ChatItem` is part of.

    `null` if this `ChatItem` is not posted in a batch.
  """
  batchId: ChatItemBatchId
  "`DateTime` when this `ChatItem` was posted."
  at: DateTime!
  """
    Version of this `ChatItem`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"Quote of a `ChatItem`."
interface ChatItemQuote {
  """
    Quoted `ChatItem`.

    `null` if the original `ChatMessage` was deleted or is unavailable for
    the authenticated `MyUser`.
  """
  original: ChatItemsEdge
  "`User` who created the quoted `ChatItem`."
  author: User!
  "`DateTime` when the quoted `ChatItem` was created."
  at: DateTime!
}

"Events happening in a `FavoriteChatsList`."
interface FavoriteChatsEvent {
  "ID of the `Chat` this `FavoriteChatsEvent` is happened in."
  chatId: ChatId!
  "`DateTime` when this `FavoriteChatsEvent` happened."
  at: DateTime!
}

"File on a file storage."
interface File {
  """
    [Relative reference][1] to this `File` on a file storage.

    Prepend it with a file storage URL to obtain the full link to this
    `File`.

    If `404` HTTP status code is returned while trying to download this
    `File` from a file storage, then the `File` is not ready yet. Back off,
    and retry again later.

    `403` HTTP status code, on the other hand, means that the link has been
    expired and this [relative reference][1] should be re-fetched to rebuild
    the link.

    [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!
  """
    [SHA-256] checksum of this `File`.

    May be `null` in case this `File` is not ready on a file storage yet.
    May be also computed on a client side, once this `File` is ready and
    successfully downloaded from a file storage.

    This checksum is especially useful if a client side requires to verify
    the integrity and authenticity of this `File`, downloaded from a file
    storage.

    Also, this checksum may be useful as a key in a client side cache,
    allowing to store `File`s in deduplicated manner.

    [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String
  """
    Size of this `File` (in bytes).

    May be `null` in case this `File` is not ready on a file storage yet.
    May be also computed on a client side, once this `File` is ready and
    successfully downloaded from a file storage.
  """
  size: Int
}

"Event happening with `MonetizationSettings`."
interface MonetizationSettingsEvent {
  """
    State of the `MonetizationSettings` after this
    `MonetizationSettingsEvent` being applied.

    `null` if the `MonetizationSettings` no longer exist.
  """
  monetizationSettings: MonetizationSettingsEdge
  "`User` the `MonetizationSettings` are specified individually for."
  user: User
  "`DateTime` when this `MonetizationSettingsEvent` happened."
  at: DateTime!
}

"Billing operation."
interface Operation {
  "ID of this `Operation`."
  id: OperationId!
  "Sequential number of this `Operation`."
  num: OperationNum!
  "Status of this `Operation`."
  status: OperationStatus!
  "`OperationOrigin` of this `Operation`."
  origin: OperationOrigin!
  "`OperationDirection` of this `Operation`."
  direction: OperationDirection!
  "Money `Sum` and `Currency` of this `Operation`."
  amount: Price!
  """
    `DateTime` until which this `Operation` is on hold.

    `null` if this `Operation` is not on hold.
  """
  holdUntil: DateTime
  "`OperationsEdge`s of the `Operation`s this `Operation` is linked to."
  linked: [OperationsEdge!]!
  "`DateTime` when this `Operation` was created."
  createdAt: DateTime!
  "Information about why this `Operation` was canceled, if it was."
  canceled: OperationCancellation
  """
    Version of this `Operation`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"Events happening with an `Operation`."
interface OperationEvent {
  "ID of the `Operation` this `OperationEvent` is related to."
  id: OperationId!
  "`OperationOrigin` this `OperationEvent` happened in."
  origin: OperationOrigin!
  "`OperationsEdge` of the `Operation` this `OperationEvent` is related to."
  operation: OperationsEdge!
  "`DateTime` when this `OperationEvent` happened."
  at: DateTime!
}

"Description of some method for performing an `OperationWithdraw`."
interface OperationWithdrawMethod {
  "Unique ID of this `OperationWithdrawKind`."
  id: OperationWithdrawMethodId!
  "`OperationWithdrawKind` of this `OperationWithdrawMethod`."
  kind: OperationWithdrawKind!
  """
    Criteria filtering this `OperationWithdrawMethod` availability for
    specific `CountryCode`s.

    `null` means that this `OperationWithdrawMethod` is available for all
    `CountryCode`s.
  """
  countries: CriteriaCountry
  """
    `OperationWithdrawMethodPricing` of this `OperationWithdrawMethod`.

    `null` in case this `OperationWithdrawMethod` is unavailable for the
    provided `CountryCode`.
  """
  pricing("""
    Nominal to calculate the returned `OperationWithdrawMethodPricing` for.

    If absent or `null` then the nominal `1` is assumed.
  """ nominal: Sum, "`CountryCode` to return the `OperationWithdrawMethodPricing` for." country: CountryCode!): OperationWithdrawMethodPricing
}

"Events happening in a `Session`."
interface SessionEvent {
  "ID of the `Session` this `SessionEvent` is related to."
  id: SessionId!
  "`DateTime` when this `SessionEvent` happened."
  at: DateTime!
}

"Events happening with a `User`."
interface UserEvent {
  "ID of the `User` this `UserEvent` is related to."
  userId: UserId!
}

"""
  Secret of an `AccessToken`.

  Its values are always considered to be non-empty and represent a
  [valid Base64 string][1].

  [1]: https://base64.guru/learn/base64-characters
"""
scalar AccessTokenSecret

"""
  Input for creating an `AccessTokenSecret`.

  Must represent 32 random bytes encoded as [valid Base64 string][1].

  __Use a [cryptographically secure random generator][1] to produce array of
  bytes for this value.__

  [1]: https://base64.guru/learn/base64-characters
  [2]: https://tinyurl.com/a958u37d
"""
scalar AccessTokenSecretInput

"""
  [Apple Push Notification service][0] device token.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - be maximum 512 bytes long.

  See [Apple Push Notification service][0] documentation for how to generate
  `ApnsDeviceToken`s for [iOS and macOS][1].

  [0]: https://developer.apple.com/documentation/usernotifications
  [1]: https://tinyurl.com/registering-your-app-with-apns
"""
scalar ApnsDeviceToken

"""
  [Apple Push Notification service][0] [VoIP] device token.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - be maximum 512 bytes long.

  See [Apple Push Notification service][0] documentation for how to generate
  `ApnsVoipDeviceToken`s for [iOS][1].

  [0]: https://developer.apple.com/documentation/usernotifications
  [1]: https://tinyurl.com/apns-voip-push-notifications
  [VoIP]: https://wikipedia.org/wiki/Voice_over_IP
"""
scalar ApnsVoipDeviceToken

"ID of an `Attachment`."
scalar AttachmentId

"""
  Business Identifier Code (BIC) of a bank in [ISO 9362:2022] format.

  [ISO 9362:2022]: https://iso.org/standard/84108.html
"""
scalar BIC

"Address of a bank."
scalar BankAddress

"Name of a bank."
scalar BankName

"Cursor of `BlocklistRecord`s."
scalar BlocklistCursor

"""
  Reason of blocking a `User` by the authenticated `MyUser`.

  Its values are always considered to be non-empty and meet the following
  requirements:
  - not start and end with space-like characters;
  - not contain line breaks;
  - be at least 1 and maximum 100 characters long.
"""
scalar BlocklistReason

"""
  Version of `MyUser`s `BlocklistRecord`s list.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar BlocklistVersion

"""
  Type of `MyUser`'s `ChatCall` credentials.

  Intended to be generated on a client side. Generate a new value for each new
  `ChatCall`.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - not start or end with space-like characters;
  - be at least 1 and maximum 250 characters long.
"""
scalar ChatCallCredentials

"ID of a `ChatCallMember`'s device."
scalar ChatCallDeviceId

"""
  Link for joining the room of a `ChatCall` on a media server.

  Always bound to a concrete device of the authenticated `MyUser`.
  This means that every device of the authenticated `MyUser` must obtain its
  own `ChatCallRoomJoinLink` via separate `Subscription.chatCallEvents`.

  This link requires addition authentication via `token` query parameter with
  the value of `ChatCallCredentials` that has been provided to
  `Mutation.startChatCall` or `Mutation.joinChatCall`.
"""
scalar ChatCallRoomJoinLink

"""
  Position of a `ChatContact` in a `MyUser`'s favorites list.

  Its values are always considered to be finite positive [`Float` values][1].

  [1]: https://spec.graphql.org/June2018#sec-Float-Value
"""
scalar ChatContactFavoritePosition

"ID of a `ChatContact`."
scalar ChatContactId

"""
  Version of `ChatContact`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar ChatContactVersion

"Cursor of `ChatContact`s."
scalar ChatContactsCursor

"""
  Version of a `ChatContact`s list.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar ChatContactsListVersion

"""
  [Slug][slug] value of a `ChatDirectLink`.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - have only latin letters (`A-Z`, `a-z`), digits (`0-9`) or `_-` symbols;
  - be at least 1 and maximum 100 characters long.

  `ChatDirectLink`s are unique in a case-insensitive manner, meaning that
  `direct-link` and `Direct-Link` [slug] values are considered as the same
  one.

  [slug]: https://en.wikipedia.org/wiki/Clean_URL#Slug
"""
scalar ChatDirectLinkSlug

"""
  Position of a `Chat` in `MyUser`'s favorites list.

  Its values are always considered to be finite positive [`Float` values][1].

  [1]: https://spec.graphql.org/June2018#sec-Float-Value
"""
scalar ChatFavoritePosition

"ID of a `Chat`."
scalar ChatId

"""
  ID of `ChatItem`s' batch grouping multiple `ChatItem`s posted by a single
  `User` action.
"""
scalar ChatItemBatchId

"ID of a `ChatItem`."
scalar ChatItemId

"""
  Version of `ChatItem`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar ChatItemVersion

"Cursor of `ChatItem`s within a `Chat`."
scalar ChatItemsCursor

"Cursor of `ChatMember`s in a `Chat`."
scalar ChatMembersCursor

"""
  Type of `ChatMessage`'s text.

  Its values are always considered to be non-empty and meet the following
  requirements:
  - be maximum 8192 UTF-8 characters long.
"""
scalar ChatMessageText

"""
  Type of `Chat`'s name.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - not start and end with space-like characters;
  - not contain line breaks;
  - be at least 1 and maximum 100 characters long.
"""
scalar ChatName

"""
  Version of `Chat`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar ChatVersion

"""
  Single-use secret code used for additional authentication of a `MyUser` on
  certain operations (like `UserEmail` address confirmation, `UserPhone`
  number confirmation, password recovery, etc.).
"""
scalar ConfirmationCode

"""
  Country code in [ISO 3166-1 alpha-2] format.

  [ISO 3166-1 alpha-2]: https://iso.org/iso-3166-country-codes.html
"""
scalar CountryCode

"""
  Currency as alphabetic code in [ISO 4217] format.

  [ISO 4217]: https://iso.org/iso-4217-currency-codes.html
"""
scalar Currency

"""
  Combined date and time (with time zone) in [RFC 3339] format with
  microseconds precision.

  Represents a description of an exact instant on the time-line (such as the
  instant that a user account was created).

  [`DateTime` scalar][1] compliant.

  [1]: https://graphql-scalars.dev/docs/scalars/date-time
  [RFC 3339]: https://datatracker.ietf.org/doc/html/rfc3339#section-5.6
"""
scalar DateTime

"ID of a `Donation`."
scalar DonationId

"Cursor of favorite `ChatContact`s."
scalar FavoriteChatContactsCursor

"Cursor of favorite `Chat`s."
scalar FavoriteChatsCursor

"""
  Version of a favorite `Chat`s list.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar FavoriteChatsListVersion

"""
  [Firebase Cloud Messaging][0] registration token.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - be maximum 512 bytes long.

  See [Firebase Cloud Messaging][0] documentation for how to generate
  `FcmRegistrationToken`s [for Flutter][1] and [for JavaScript][2].

  [0]: https://firebase.google.com/docs/cloud-messaging
  [1]: https://firebase.google.com/docs/cloud-messaging/flutter/client
  [2]: https://firebase.google.com/docs/cloud-messaging/js/client
"""
scalar FcmRegistrationToken

"""
  International Bank Account Number (IBAN) in [ISO 13616-1:2020] format.

  [ISO 13616-1:2020]: https://iso.org/standard/81090.html
"""
scalar IBAN

"""
  Either an [IPv4] or [IPv6] address.

  [IPv4]: https://en.wikipedia.org/wiki/IPv4
  [IPv6]: https://en.wikipedia.org/wiki/IPv6
"""
scalar IP

"Cursor of incoming `ChatCall`s."
scalar IncomingChatCallsCursor

"""
  [Base64]-encoded [PDF] invoice of an `Operation`.

  [Base64]: https://base64.guru/learn/base64-characters
  [PDF]: https://wikipedia.org/wiki/PDF
"""
scalar InvoiceFile

"Cursor over `MonetizationSettings`."
scalar MonetizationSettingsCursor

"""
  Version of `MonetizationSettings`' state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar MonetizationSettingsVersion

"""
  Version of `MyUser`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar MyUserVersion

"Arbitrary additional reason of an `OperationCancellation`."
scalar OperationCancellationReason

"ID of an `OperationDepositMethod`."
scalar OperationDepositMethodId

"""
  Secret authenticating client operations on an `OperationDeposit`.

  Must represent 32 random bytes encoded as [valid Base64 string][1].

  __Use a [cryptographically secure random generator][1] to produce array of
  bytes for this value.__

  [1]: https://base64.guru/learn/base64-characters
  [2]: https://tinyurl.com/a958u37d
"""
scalar OperationDepositSecret

"Reason of `Operation`'s failure."
scalar OperationFailureReason

"ID of an `Operation`."
scalar OperationId

"Sequential number of an `Operation`."
scalar OperationNum

"Reason of an `Operation` creation."
scalar OperationReason

"""
  Version of `Operation`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar OperationVersion

"ID of an `OperationWithdrawMethod`."
scalar OperationWithdrawMethodId

"Cursor of `Operation`s."
scalar OperationsCursor

"Percentage value in range between `0` (exclusively) and `100` (inclusively)."
scalar Percentage

"Cursor of `PromoShare`s in a historical order."
scalar PromoShareHistoryCursor

"""
  Version of `PromoShare`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar PromoShareVersion

"Cursor of recent `Chat`s."
scalar RecentChatsCursor

"""
  Type of `RefreshToken`'s secret.

  Its values are always considered to be non-empty and represent a
  [valid Base64 string][1].

  [1]: https://base64.guru/learn/base64-characters
"""
scalar RefreshTokenSecret

"""
  Input for creating a `RefreshTokenSecret`.

  Must represent 32 random bytes encoded as [valid Base64 string][1].

  __Use a [cryptographically secure random generator][1] to produce array of
  bytes for this value.__

  [1]: https://base64.guru/learn/base64-characters
  [2]: https://tinyurl.com/a958u37d
"""
scalar RefreshTokenSecretInput

"ID of a `Session`."
scalar SessionId

"""
  Version of `Session`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar SessionVersion

"""
  Version of a `Session`s list.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar SessionsListVersion

"""
  Type of `Site`'s [FQDN] (fully qualified domain name).

  Its values are always considered to be non-empty and meet the requirements
  of the [Domain Name Syntax format][1]. TLDs (top-level domains) are
  considered as valid [`Domain`]s.

  [FQDN]: https://en.wikipedia.org/wiki/Fully_qualified_domain_name
  [1]: https://en.wikipedia.org/wiki/Domain_name#Domain_name_syntax
"""
scalar SiteDomain

"Sum of money."
scalar Sum

"""
  [Base64URL]-encoded [ThumbHash].

  Its values are always considered to be non-empty and represent a
  [valid Base64URL string][Base64URL].

  [Base64URL]: https://base64.guru/standards/base64url
  [ThumbHash]: https://evanw.github.io/thumbhash
"""
scalar ThumbHash

"""
  URL in [RFC 3986] format.

  [`URL` scalar][1] compliant.

  [1]: https://graphql-scalars.dev/docs/scalars/url
  [RFC 3339]: https://www.ietf.org/rfc/rfc3986.txt
"""
scalar URL

"""
  Type of [GraphQL multipart request][1] upload.

  It's intended to be used as a `null`able type (e.g., `Upload`) only in GraphQL schema, and its values should always be `null`.

  [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
"""
scalar Upload

"Sequential number of an affiliated `User`."
scalar UserAffiliatedNum

"""
  Type of `MyUser`'s [user agent].

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - consist only from [ASCII] characters;
  - contain at least one non-space-like character.

  [ASCII]: https://en.wikipedia.org/wiki/ASCII
  [user agent]: https://en.wikipedia.org/wiki/User_agent
"""
scalar UserAgent

"""
  Type of `User`'s bio.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - be at least 1 and maximum 4096 characters long.
"""
scalar UserBio

"""
  Email address of a `User`.

  Its values are always considered to represent a valid email address.
"""
scalar UserEmail

"ID of a `User`."
scalar UserId

"""
  Login of a `MyUser`.

  Its values are always considered to be non-empty and meet the following
  requirements:
  - have only latin letters (`A-Z`, `a-z`), digits (`0-9`) or `_-` symbols;
  - start and end with letter or digit;
  - do not contain digits only;
  - be at least 3 and maximum 20 characters long.

  `UserLogin`s are unique in a case-insensitive manner, meaning that `loGin`
  and `LOgIN` values are considered as the same one.
"""
scalar UserLogin

"""
  Type of `User`'s name.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - not start and end with space-like characters;
  - not contain line breaks;
  - be at least 1 and maximum 100 characters long.
"""
scalar UserName

"""
  Type of `User`'s unique number.

  Its values are always in range between `1_000_000_000_000_000` and
  `9_999_999_999_999_999` inclusively.
"""
scalar UserNum

"""
  Password of a `MyUser`.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - not start and end with space-like characters;
  - be at least 1 and maximum 250 characters long.
"""
scalar UserPassword

"""
  Phone number of a `User`.

  Its values are always considered to represent a valid phone number in
  [E.164] standard international format (start with `+` sign, followed by
  7-15 digits).

  [E.164]: https://en.wikipedia.org/wiki/E.164
"""
scalar UserPhone

"""
  Type of `User`'s text status value.

  Its values are always considered to be non-empty, and meet the following
  requirements:
  - be at least 1 and maximum 33 characters long.
"""
scalar UserTextStatus

"""
  Version of `User`'s state.

  It increases monotonically, so may be used (and is intended to) for tracking
  state's actuality.
"""
scalar UserVersion

"Cursor of `User`s."
scalar UsersCursor

"Token used for authenticating a `Session`."
type AccessToken {
  """
    Secret part of this `AccessToken`.

    This one should be used as a [Bearer authentication token][1].

    [1]: https://tools.ietf.org/html/rfc6750#section-2.1
  """
  secret: AccessTokenSecret!
  """
    `DateTime` of this `AccessToken` expiration.

    Once expired, it's not usable anymore and the `Session` should be
    refreshed via `Mutation.refreshSession` to get a new `AccessToken`.

    Client applications are supposed to use this field for tracking
    `AccessToken`'s expiration and refresh the `Session` before an
    authentication error occurs.
  """
  expiresAt: DateTime!
}

"Error of performing `Mutation.addChatMember`."
type AddChatMemberError {
  "Code indicating why this error has happened."
  code: AddChatMemberErrorCode!
}

"Error of performing `Mutation.addUserEmail`."
type AddUserEmailError {
  "Code indicating why this error has happened."
  code: AddUserEmailErrorCode!
}

"Error of performing `Mutation.addUserPhone`."
type AddUserPhoneError {
  "Code indicating why this error has happened."
  code: AddUserPhoneErrorCode!
}

"Balance of some `BalanceOrigin`."
type Balance {
  "`Sum` of this `Balance`."
  sum: Sum!
  "Currency of this `Balance`."
  currency: Currency!
}

"Requisites of a bank account."
type BankAccountRequisites {
  "`IBAN` of the account."
  iban: IBAN!
  "Requisites of the bank the account belongs to."
  bank: BankRequisites!
}

"Requisites of a bank."
type BankRequisites {
  "`BIC` of the bank."
  bic: BIC!
  "Name of the bank."
  name: BankName!
  "Address of the bank."
  address: BankAddress!
}

"Error of performing `Mutation.blockUser`."
type BlockUserError {
  "Code indicating why this error has happened."
  code: BlockUserErrorCode!
}

"List of `BlocklistRecord`s."
type Blocklist {
  """
    Returns `User`s blocked by authenticated `MyUser` as `BlocklistRecord`s.

    Alias of `Query.blocklist`.

    ## Sorting

    Returned `User`s are sorted primarily by their blocking `DateTime`, and
    secondary by their IDs (if the blocking `DateTime` is the same), in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `BlocklistRecord` pointed by the cursor
    and the requested count of `BlocklistRecord`s preceding and following
    it.

    If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.
  """
  blocklist("Number of next `BlocklistRecord`s to return." first: Int, "Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after." after: BlocklistCursor, "Number of prior `BlocklistRecord`s to return." last: Int, "Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before." before: BlocklistCursor): BlocklistConnection!
}

"""
  [Connection] with `BlocklistRecord`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type BlocklistConnection {
  """
    List of `BlocklistRecord` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [BlocklistEdge!]!
  """
    List of `BlocklistRecord`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [BlocklistRecord!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  "Total count of `BlocklistRecord`s."
  totalCount: Int!
  """
    Version of this `BlocklistRecord`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: BlocklistVersion!
}

"""
  [Edge] with a `BlocklistRecord`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type BlocklistEdge {
  """
    `BlocklistRecord` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: BlocklistRecord!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: BlocklistCursor!
}

"`BlocklistEvent`s along with the corresponding `BlocklistVersion`."
type BlocklistEventsVersioned {
  "`BlocklistEvent`s themselves."
  events: [BlocklistEvent!]!
  """
    Version of the `BlocklistRecord`s list state updated by these
    `BlocklistEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: BlocklistVersion!
}

"`User`'s record in a `Query.blocklist` of the authenticated `MyUser`."
type BlocklistRecord {
  "Blocked `User`."
  user: User!
  "Reason of why the `User` was blocked."
  reason: BlocklistReason
  "`DateTime` when the `User` was blocked."
  at: DateTime!
}

"Changed `Attachment`s."
type ChangedChatMessageAttachments {
  """
    New `Attachment`s.

    Empty list means that the previous `Attachment`s were deleted.

    ## Sorting

    Returned `Attachment`s are sorted in the same order as were provided to
    the correspondent mutation.
  """
  changed: [Attachment!]!
}

"Changed replied `ChatItem`s of a `ChatMessage`."
type ChangedChatMessageReplies {
  """
    New `ChatItemQuote`s of the `ChatMessage`.

    Empty list means that the previous `ChatItemQuote`s were deleted.

    ## Sorting

    Returned `ChatItemQuote`s are sorted in the same order as were provided
    to the `Mutation.editChatMessage` by the `ChatMessage`'s author.
  """
  changed: [ChatItemQuote!]!
}

"Changed `ChatMessageText`."
type ChangedChatMessageText {
  """
    Changed `ChatMessageText`.

    `null` means that the previous `ChatMessageText` was deleted.
  """
  changed: ChatMessageText
}

"`Chat` is a conversation between `User`s."
type Chat {
  "Unique ID of this `Chat`."
  id: ChatId!
  "Avatar of this `Chat`."
  avatar: ChatAvatar
  """
    Name of this `Chat`.

    Only `Chat`-group can have a `name`.
  """
  name: ChatName
  """
    `ChatMember`s of this `Chat`.

    ## Sorting

    Returned `ChatMember`s are sorted primarily by their joining `DateTime`,
    and secondary by their IDs (if the joining `DateTime` is the same), in
    ascending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatMember` pointed by the cursor and
    the requested count of `ChatMember`s preceding and following it.

    If it's desired to receive the `ChatMember`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some filtered entries with a cursor pointing to a page
    of totally different filtered entries is nonsense and will produce an
    invalid result (usually returning nothing).
  """
  members("Number of next `ChatMember`s to return." first: Int, "Cursor indicating the `ChatMembersEdge` position to return next `ChatMember`s after." after: ChatMembersCursor, "Number of prior `ChatMember`s to return." last: Int, "Cursor indicating the `ChatMembersEdge` position to return prior `ChatMember`s before." before: ChatMembersCursor, """
    ID of the `ChatItem` that should be read by returned `ChatMember`s.
    `null` means omitting filtering by this criterion.
  """ readItem: ChatItemId): ChatMembersConnection!
  "Kind of this `Chat`."
  kind: ChatKind!
  "Indicator whether this `Chat` is hidden by the authenticated `MyUser`."
  isHidden: Boolean!
  "Indicator whether this `Chat` is archived by the authenticated `MyUser`."
  isArchived: Boolean!
  """
    Mute condition of this `Chat` for the authenticated `MyUser`.

    Muted `Chat` implies that its events don't produce sounds and
    notifications on a client side. This, however, has nothing to do with a
    server and is the responsibility to be satisfied by a client side.
    Server side may try to optimize this in some cases (like omit sending
    notifications), but a client side should not rely on any such behaviour
    and should implement best-effort muting by itself.

    Note, that `Chat.muted` doesn't correlate with `MyUser.muted`. Muted
    `Chat` of unmuted `MyUser` (and unmuted `Chat` of muted `MyUser`) should
    not produce any sounds.
  """
  muted: MuteDuration
  """
    Position of this `Chat` in the favorites list of the authenticated
    `MyUser`.
  """
  favoritePosition: ChatFavoritePosition
  "`ChatDirectLink` to this `Chat`."
  directLink: ChatDirectLink
  "`DateTime` when this `Chat` was created."
  createdAt: DateTime!
  """
    `DateTime` when the last `ChatItem` was posted.

    The main difference from `Chat.lastItem.at` query is that this field is
    guaranteed to be monotonic. It's used for ordering `Chat`s by their
    recent updates in `Subscription.recentChatsTopEvents`.

    Only the following `ChatEvent` updates this field:
    - `EventChatItemPosted`.
  """
  updatedAt: DateTime!
  """
    List of this `Chat`'s members which have read it, along with the reading
    `DateTime`s.

    Limited with up to 10 `LastChatRead`s.
  """
  lastReads: [LastChatRead!]!
  """
    `DateTime` until which the posted `ChatItem`s were delivered to
    `ChatMember`s, excluding the authenticated `MyUser`.

    Can be used to determine whether the last `ChatItem` posted by the
    authenticated `MyUser` was delivered to other `ChatMember`s by checking
    it was posted not later than this `DateTime`.

    Points to [UNIX epoch][0] if `ChatItem`s have been never delivered
    before.

    [0]: https://en.wikipedia.org/wiki/Unix_time
  """
  lastDelivery: DateTime!
  """
    Last `ChatItem` posted in this `Chat`.

    `null` if there are no visible `ChatItem`s for the authenticated
    `MyUser` in this `Chat`.
  """
  lastItem: ChatItemsEdge
  """
    Last `ChatItem` read by the authenticated `MyUser` in this `Chat`.

    `null` if there are no visible `ChatItem`s for the authenticated
    `MyUser` in this `Chat`, or it hasn't been read yet.
  """
  lastReadItem: ChatItemsEdge
  """
    `ChatItem`s of this `Chat` ordered by their posting time.

    Specifying `filter` argument allows to filter out returned `ChatItem`s
    by the desired criteria.

    ## Sorting

    Returned `ChatItem`s are sorted primarily by their posting `DateTime`,
    and secondary by their IDs (if the posting `DateTime` is the same), in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatItem` pointed by the cursor and the
    requested count of `ChatItem`s preceding and following it.

    If it's desired to receive the `ChatItem`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some filtered entries with a cursor pointing to a page
    of totally different filtered entries is nonsense and will produce an
    invalid result (usually returning nothing).
  """
  items("Optional criteria to filter out returned `ChatItem`s by." filter: ChatItemsFilter, "Number of next `ChatItem`s to return." first: Int, "Cursor indicating the `ChatItemsEdge` position to return next `ChatItem`s after." after: ChatItemsCursor, "Number of prior `ChatItem`s to return." last: Int, "Cursor indicating the `ChatItemsEdge` position to return prior `ChatItem`s before." before: ChatItemsCursor): ChatItemsConnection!
  "`ChatItem` of this `Chat` by its ID."
  item(id: ChatItemId!): ChatItemsEdge
  """
    Count of `ChatItem`s unread by the authenticated `MyUser` in this
    `Chat`.
  """
  unreadCount: Int!
  """
    Count of `ChatItem`s visible to the authenticated `MyUser` in this
    `Chat` (it doesn't include deleted or hidden `ChatItem`s).
  """
  totalCount: Int!
  "Current ongoing `ChatCall` of this `Chat`, if any."
  ongoingCall: ChatCall
  """
    Version of this `Chat`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatVersion!
}

"Avatar of a `Chat`."
type ChatAvatar {
  """
    `CropArea` applied to the `original` `ImageFile` for creating this
    `ChatAvatar`.
  """
  crop: CropArea
  "Original `ImageFile` representing this `ChatAvatar`."
  original: ImageFile!
  """
    Full-sized `ImageFile` representing this `ChatAvatar`, keeping the
    `original` dimensions.
  """
  full: ImageFile!
  """
    `big` view `ImageFile` of this `ChatAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to
    `250px`x`250px`.
  """
  big: ImageFile!
  """
    `medium` view `ImageFile` of this `ChatAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to
    `100px`x`100px`.
  """
  medium: ImageFile!
  """
    `small` view `ImageFile` of this `ChatAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to `46px`x`46px`.
  """
  small: ImageFile!
}

"Call in a `Chat`."
type ChatCall implements ChatItem {
  "Unique ID of this `ChatCall`."
  id: ChatItemId!
  "ID of the `Chat` where this `ChatCall` is organized."
  chatId: ChatId!
  """
    `ChatMember`s being dialed by this `ChatCall` at the moment.

    Unanswered `ChatCall`s (neither accepted, nor declined) are considered
    incoming (unless the dialing timeout passes) and should be present in
    results of `Query.incomingChatCalls` and
    `Subscription.incomingChatCallsTopEvents`. Although all 3 methods are
    suitable for notifying about incoming calls, this field contains the
    most recent and accurate information, as other methods may introduce a
    delay.

    To understand whether the authenticated `MyUser` is dialed by this
    `ChatCall` at the moment, check whether the `ChatCall.dialed.members`
    contain him or the `ChatCall.dialed.answeredMembers` do not while the
    `ChatCall.dialed` is not `null`.
  """
  dialed: ChatMembersDialed
  """
    `User` who started this `ChatCall`.

    Note, that this `User` may not be a member of this `ChatCall` at the
    moment.
  """
  author: User!
  """
    ID of the `ChatItem`s' batch this `ChatCall` is part of.

    Always `null` as `ChatCall`s are never posted in batches.
  """
  batchId: ChatItemBatchId
  "Indicator whether this `ChatCall` is intended to start with video."
  withVideo: Boolean!
  """
    `ChatCallMember`s of this `ChatCall`.

    New `ChatCallMember`s always join a `ChatCall` with a lowered hand.

    ## Sorting

    Returned `ChatCallMember`s are sorted primarily by their joining
    `DateTime`, and secondary by their IDs (if the joining `DateTime` is the
    same), in ascending order.
  """
  members: [ChatCallMember!]!
  "`DateTime` when this `ChatCall` was started."
  at: DateTime!
  """
    `DateTime` when the actual conversation in this `ChatCall` was started
    (after ringing had been finished).
  """
  conversationStartedAt: DateTime
  "`DateTime` when this `ChatCall` was finished (if it was)."
  finishedAt: DateTime
  "Reason of why this `ChatCall` was finished (if it was)."
  finishReason: ChatCallFinishReason
  """
    Version of this `ChatCall`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"`ChatCallEvent`s along with the corresponding `ChatItemVersion`."
type ChatCallEventsVersioned {
  "`ChatCallEvent`s themselves."
  events: [ChatCallEvent!]!
  """
    Version of the `ChatCall`'s state updated by these `ChatCallEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"Member of a `ChatCall`."
type ChatCallMember {
  "`User` representing this `ChatCallMember`."
  user: User!
  "ID of this `ChatCallMember`'s device."
  deviceId: ChatCallDeviceId!
  "Indicator whether this `ChatCallMember` raised a hand."
  handRaised: Boolean!
  "`DateTime` when this `ChatCallMember` joined the `ChatCall`."
  joinedAt: DateTime!
}

"`ChatItemQuote` of a `ChatCall`."
type ChatCallQuote implements ChatItemQuote {
  """
    Quoted `ChatCall`.

    `null` if the quoted `ChatCall` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  original: ChatItemsEdge
  "`User` who started the quoted `ChatCall`."
  author: User!
  "`DateTime` when the quoted `ChatCall` was started."
  at: DateTime!
}

"""
  Record in an address book of the authenticated `MyUser`.

  It may be linked with some real `User`s, but also may not.
"""
type ChatContact {
  "Unique ID of this `ChatContact`."
  id: ChatContactId!
  """
    Custom `UserName` of this `ChatContact` given by the authenticated
    `MyUser`.
  """
  name: UserName!
  """
    `User`s linked to this `ChatContact`.

    Guaranteed to have no duplicates.
  """
  users: [User!]!
  """
    `Chat`-groups linked to this `ChatContact`.

    Guaranteed to have no duplicates.
  """
  groups: [Chat!]!
  """
    List of `UserEmail`s provided by this `ChatContact`.

    Guaranteed to have no duplicates.
  """
  emails: [ChatContactEmail!]!
  """
    List of `UserPhone`s provided by this `ChatContact`.

    Guaranteed to have no duplicates.
  """
  phones: [ChatContactPhone!]!
  """
    Position of this `ChatContact` in the favorites list of the
    authenticated `MyUser`.
  """
  favoritePosition: ChatContactFavoritePosition
  """
    Version of this `ChatContact`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatContactVersion!
}

"Email address provided by a `ChatContact`."
type ChatContactEmail {
  "`UserEmail` of this `ChatContactEmail`."
  email: UserEmail!
  "`User` behind this `ChatContactEmail`, if any."
  user: User
}

"""
  `ChatContactEvent`s along with the corresponding `ChatContactVersion`.
  and `ChatContactsListVersion`.
"""
type ChatContactEventsVersioned {
  "`ChatContactEvent`s themselves."
  events: [ChatContactEvent!]!
  """
    Version of the `ChatContact` state updated by these `ChatContactEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking concrete `ChatContact` state's actuality.

    If the `events` contain `ChatContactEvent`s related to different
    `ChatContact`s, then this version is applicable for all of them.
  """
  ver: ChatContactVersion!
  """
    Version of the `ChatContact`s list updated by these `ChatContactEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking list state's actuality.

    Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  listVer: ChatContactsListVersion!
}

"Phone number provided by a `ChatContact`."
type ChatContactPhone {
  "`UserPhone` of this `ChatContactPhone`."
  phone: UserPhone!
  "`User` behind this `ChatContactPhone`, if any."
  user: User
}

"""
  [Connection] with `ChatContact`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatContactsConnection {
  """
    List of `ChatContact` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatContactsEdge!]!
  """
    List of `ChatContact`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatContact!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  """
    Version of this `ChatContact`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking list state's actuality.

    Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  ver: ChatContactsListVersion!
}

"""
  [Edge] with a `ChatContact`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatContactsEdge {
  """
    `ChatContact` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatContact!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatContactsCursor!
}

"List of `ChatContact`s."
type ChatContactsList {
  """
    Returns address book of the authenticated `MyUser` ordered
    alphabetically by `ChatContact` names.

    Alias of `Query.chatContacts`.
  """
  chatContacts("Number of next `ChatContact`s to return." first: Int, "Cursor indicating the `ChatContactsEdge` position to return next `ChatContact`s after." after: ChatContactsCursor, "Number of prior `ChatContact`s to return." last: Int, "Cursor indicating the `ChatContactsEdge` position to return prior `ChatContact`s before." before: ChatContactsCursor, "Indicator whether favorite `ChatContact`s should be excluded from the result." noFavorite: Boolean = false): ChatContactsConnection! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns favorited `ChatContact`s of the authenticated `MyUser` ordered
    by the custom order of `MyUser`'s favorites list (using
    `ChatContact.favoritePosition` field).

    Aliases `Query.favoriteChatContacts`.
  """
  favoriteChatContacts("Number of next `ChatContact`s to return." first: Int, "Cursor indicating the `FavoriteChatContactsEdge` position to return next `ChatContact`s after." after: FavoriteChatContactsCursor, "Number of prior `ChatContact`s to return." last: Int, "Cursor indicating the `FavoriteChatContactsEdge` position to return prior `ChatContact`s before." before: FavoriteChatContactsCursor): FavoriteChatContactsConnection! @deprecated(reason: "Unimplemented. Do not use it.")
}

"Direct link to a `Chat`."
type ChatDirectLink {
  """
    Unique [slug] associated with this `ChatDirectLink`.

    `ChatDirectLink`s are unique in a case-insensitive manner, meaning that
    `direct-link` and `Direct-Link` [slug] values are considered as the same
    one.

    [slug]: https://en.wikipedia.org/wiki/Clean_URL#Slug
  """
  slug: ChatDirectLinkSlug!
  "Counter of this `ChatDirectLink` being used."
  usageCount: Int!
  "`DateTime` when this `ChatDirectLink` was created."
  createdAt: DateTime!
}

"`ChatEvent`s along with the corresponding `ChatVersion`."
type ChatEventsVersioned {
  "`ChatEvent`s themselves."
  events: [ChatEvent!]!
  """
    Version of the `Chat`'s state updated by these `ChatEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatVersion!
}

"Quote of a `ChatItem` forwarded to some `Chat`."
type ChatForward implements ChatItem {
  "Unique ID of this `ChatForward`."
  id: ChatItemId!
  "ID of the `Chat` this `ChatForward` is posted in."
  chatId: ChatId!
  "`User` who posted this `ChatForward`."
  author: User!
  """
    ID of the `ChatItem`s' batch this `ChatForward` is part of.

    `null` if this `ChatForward` is not posted in a batch.
  """
  batchId: ChatItemBatchId
  """
    `ChatItemQuote` of the forwarded `ChatItem`.

    Re-forwarding a `ChatForward` is indistinguishable from just forwarding
    its inner `ChatMessage` (`ChatItemQuote` depth will still be just 1).
  """
  quote: ChatItemQuote!
  "`DateTime` when this `ChatForward` was posted."
  at: DateTime!
  """
    Version of this `ChatForward`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"Information about an action taken upon a `Chat`."
type ChatInfo implements ChatItem {
  "Unique ID of this `ChatInfo`."
  id: ChatItemId!
  "ID of the `Chat` this `ChatInfo` was posted in."
  chatId: ChatId!
  "`User` who triggered this `ChatInfo`."
  author: User!
  """
    ID of the `ChatItem`s' batch this `ChatInfo` is part of.

    Always `null` as `ChatInfo`s are never posted in batches.
  """
  batchId: ChatItemBatchId
  "`ChatInfoAction` taken upon the `Chat`."
  action: ChatInfoAction!
  "`DateTime` when this `ChatInfo` was posted."
  at: DateTime!
  """
    Version of this `ChatInfo`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"`ChatInfoAction` about a `ChatAvatar` being updated."
type ChatInfoActionAvatarUpdated {
  """
    New `ChatAvatar` of the `Chat`.

    `null` means that the old `ChatAvatar` was removed.
  """
  avatar: ChatAvatar
}

"`ChatInfoAction` about a `Chat` being created."
type ChatInfoActionCreated {
  "`ChatDirectLinkSlug` used to create the `Chat`, if any."
  directLinkSlug: ChatDirectLinkSlug
}

"`ChatInfoAction` about a `ChatMember` being added to a `Chat`."
type ChatInfoActionMemberAdded {
  """
    `User` who became a `ChatMember`.

    If the same as `ChatItem.authorId`, then the `User` joined the `Chat` by
    himself.
  """
  user: User!
  """
    `ChatDirectLinkSlug` used by the `ChatMember` to join the `Chat`, if
    any.
  """
  directLinkSlug: ChatDirectLinkSlug
}

"`ChatInfoAction` about a `ChatMember` being removed from a `Chat`."
type ChatInfoActionMemberRemoved {
  """
    `User` who was removed from the `Chat`.

    If the same as `ChatItem.authorId`, then the `User` left the `Chat` by
    himself.
  """
  user: User!
}

"`ChatInfoAction` about a `ChatName` being updated."
type ChatInfoActionNameUpdated {
  """
    New `ChatName` of the `Chat`.

    `null` means that the old `ChatName` was removed.
  """
  name: ChatName
}

"`ChatItemQuote` of a `ChatInfo`."
type ChatInfoQuote implements ChatItemQuote {
  """
    Quoted `ChatInfo`.

    `null` if the quoted `ChatInfo` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  original: ChatItemsEdge
  "`User` who triggered the quoted `ChatInfo`."
  author: User!
  "`ChatInfoAction` of the quoted `ChatInfo`."
  action: ChatInfoAction!
  "`DateTime` when the quoted `ChatInfo` was created."
  at: DateTime!
}

"""
  [Connection] with `ChatItem`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatItemsConnection {
  """
    List of `ChatItem` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatItemsEdge!]!
  """
    List of `ChatItem`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatItem!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""
  [Edge] with a `ChatItem`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatItemsEdge {
  """
    `ChatItem` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatItem!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatItemsCursor!
}

"Member of a `Chat`."
type ChatMember {
  "`User` represented by this `ChatMember`."
  user: User!
  "`DateTime` when the `User` became a `ChatMember`."
  joinedAt: DateTime!
}

"""
  [Connection] with `ChatMember`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatMembersConnection {
  """
    List of `ChatMember` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatMembersEdge!]!
  """
    List of `ChatMember`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatMember!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  "Total count of `ChatMember`s in this `Chat`."
  totalCount: Int!
}

"""
  Information about all `ChatMember`s of a `Chat` being dialed (or redialed)
  by a `ChatCall`.
"""
type ChatMembersDialedAll {
  """
    `ChatMember`s who answered (joined or declined) the `ChatCall` already,
    so are not dialed anymore.
  """
  answeredMembers: [ChatMember!]!
}

"""
  Information about concrete `ChatMember`s of a `Chat` being dialed (or
  redialed) by a `ChatCall`.
"""
type ChatMembersDialedConcrete {
  """
    Concrete `ChatMember`s who are dialed (or redialed) by the `ChatCall`.

    Guaranteed to be non-empty.
  """
  members: [ChatMember!]!
}

"""
  [Edge] with a `ChatMember`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatMembersEdge {
  """
    `ChatMember` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatMember!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatMembersCursor!
}

"Message in a `Chat`."
type ChatMessage implements ChatItem {
  "Unique ID of this `ChatMessage`."
  id: ChatItemId!
  "ID of the `Chat` this `ChatMessage` is posted in."
  chatId: ChatId!
  "`User` who posted this `ChatMessage`."
  author: User!
  """
    ID of the `ChatItem`s' batch this `ChatMessage` is part of.

    `null` if this `ChatMessage` is not posted in a batch.
  """
  batchId: ChatItemBatchId
  "`ChatItemQuote`s of the `ChatItem`s this `ChatMessage` replies to."
  repliesTo: [ChatItemQuote!]!
  "Text of this `ChatMessage`."
  text: ChatMessageText
  "`DateTime` when this `ChatMessage` was edited."
  editedAt: DateTime
  """
    `Attachment`s of this `ChatMessage`.

    ## Sorting

    Returned `Attachment`s are sorted in the same order as was provided to
    the `Mutation.postChatMessage` by this `ChatMessage`'s author.
  """
  attachments: [Attachment!]!
  "`Donation`s attached to this `ChatMessage`."
  donations: [Donation!]!
  "`DateTime` when this `ChatMessage` was posted."
  at: DateTime!
  """
    Version of this `ChatMessage`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"`ChatItemQuote` of a `ChatMessage`."
type ChatMessageQuote implements ChatItemQuote {
  """
    Quoted `ChatMessage` or `ChatForward` (only if it's replied).

    `null` if the quoted `ChatMessage` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  original: ChatItemsEdge
  "`User` who posted the quoted `ChatMessage`."
  author: User!
  """
    `ChatMessageText` the quoted `ChatMessage` had when this `ChatItemQuote`
    was made.
  """
  text: ChatMessageText
  """
    `Attachment`s the quoted `ChatMessage` had when this `ChatItemQuote` was
    made.
  """
  attachments: [Attachment!]!
  """
    `Donation`s the quoted `ChatMessage` had when this `ChatItemQuote` was
    made.
  """
  donations: [Donation!]!
  "`DateTime` when the quoted `ChatMessage` was posted."
  at: DateTime!
}

"Error of performing `Mutation.clearChat`."
type ClearChatError {
  "Code indicating why this error has happened."
  code: ClearChatErrorCode!
}

"Error of performing `Mutation.completeOperationDeposit`."
type CompleteOperationDepositError {
  "Code indicating why this error has happened."
  code: CompleteOperationDepositErrorCode!
}

"Error of performing `Mutation.createChatContact`."
type CreateChatContactError {
  "Code indicating why this error has happened."
  code: CreateChatContactErrorCode!
}

"Error of performing `Mutation.createChatContactRecord`."
type CreateChatContactRecordError {
  "Code indicating why this error has happened."
  code: CreateChatContactRecordErrorCode!
}

"Error of performing `Mutation.createChatContactRecords`."
type CreateChatContactRecordsError {
  "Code indicating why this error has happened."
  code: CreateChatContactRecordsErrorCode!
}

"Error of performing `Mutation.createChatDirectLink`."
type CreateChatDirectLinkError {
  "Code indicating why this error has happened."
  code: CreateChatDirectLinkErrorCode!
}

"Error of performing `Mutation.createDialogChat`."
type CreateDialogChatError {
  "Code indicating why this error has happened."
  code: CreateDialogChatErrorCode!
}

"Error of performing `Mutation.createGroupChat`."
type CreateGroupChatError {
  "Code indicating why this error has happened."
  code: CreateGroupChatErrorCode!
}

"Error of performing `Mutation.createOperationDeposit`."
type CreateOperationDepositError {
  "Code indicating why this error has happened."
  code: CreateOperationDepositErrorCode!
}

"Error of performing `Mutation.createOperationWithdraw`."
type CreateOperationWithdrawError {
  "Code indicating why this error has happened."
  code: CreateOperationWithdrawErrorCode!
}

"Error of performing `Mutation.createSession`."
type CreateSessionError {
  "Code indicating why this error has happened."
  code: CreateSessionErrorCode!
}

"""
  Result of successful performing `Mutation.createSession`,
  `Mutation.refreshSession` or `Mutation.createUser`.
"""
type CreateSessionOk {
  "Created or refreshed `AccessToken` for authenticating the `Session`."
  accessToken: AccessToken!
  """
    Created or refreshed `RefreshToken` for refreshing the `Session`.

    Use it instead of the previous one for the next
    `Mutation.refreshSession` execution.

    Expiration of the refreshed `RefreshToken` is not prolonged comparing to
    the previous one, and remains the same for all the `RefreshToken`s
    obtained via `Mutation.refreshSession`. Use the `Mutation.createSession`
    to obtain a `RefreshToken` with new expiration.
  """
  refreshToken: RefreshToken!
  "Created or refreshed `Session`."
  session: Session!
  "`MyUser` owning the `Session`."
  user: MyUser!
}

"Error of performing `Mutation.createUser`."
type CreateUserError {
  "Code indicating why this error has happened."
  code: CreateUserErrorCode!
}

"`CountryCode`s being excluded from entities' match."
type CriteriaCountryExcept {
  "`CountryCode`s excluded from the match."
  except: [CountryCode!]!
}

"`CountryCode`s being included into entities' match."
type CriteriaCountryOnly {
  "`CountryCode`s included into the match."
  only: [CountryCode!]!
}

"""
  Area for an image cropping.

  Top left corner of the rotated by `angle` image is considered as `(0, 0)`
  coordinates start point. So, obviously, `CropArea.bottomRight` point's
  coordinates should be bigger than the ones of `CropArea.topLeft` point.

  For raster images use pixels as the coordinate system. For [SVG] images use
  [viewport coordinate system][1].

  [SVG]: https://en.wikipedia.org/wiki/Portable_Network_Graphics
  [1]: https://w3.org/TR/SVG/coords.html
"""
type CropArea {
  "`Point` of a top left corner of this cropping area."
  topLeft: Point!
  "`Point` of a bottom right corner of this cropping area."
  bottomRight: Point!
  "Angle to rotate image before cropping."
  angle: Angle
}

"Error of performing `Mutation.declineChatCall`."
type DeclineChatCallError {
  "Code indicating why this error has happened."
  code: DeclineChatCallErrorCode!
}

"Error of performing `Mutation.declineOperationDeposit`."
type DeclineOperationDepositError {
  "Code indicating why this error has happened."
  code: DeclineOperationDepositErrorCode!
}

"Error of performing `Mutation.deleteChatContactRecord`."
type DeleteChatContactRecordError {
  "Code indicating why this error has happened."
  code: DeleteChatContactRecordErrorCode!
}

"Error of performing `Mutation.deleteChatDirectLink`."
type DeleteChatDirectLinkError {
  "Code indicating why this error has happened."
  code: DeleteChatDirectLinkErrorCode!
}

"Error of performing `Mutation.deleteChatForward`."
type DeleteChatForwardError {
  "Code indicating why this error has happened."
  code: DeleteChatForwardErrorCode!
}

"Error of performing `Mutation.deleteChatMessage`."
type DeleteChatMessageError {
  "Code indicating why this error has happened."
  code: DeleteChatMessageErrorCode!
}

"Error of performing `Mutation.deleteMyUser`."
type DeleteMyUserError {
  "Code indicating why this error has happened."
  code: DeleteMyUserErrorCode!
}

"Error of performing `Mutation.deleteSession`."
type DeleteSessionError {
  "Code indicating why this error has happened."
  code: DeleteSessionErrorCode!
}

"Donation attached to a `ChatMessage`."
type Donation {
  "Unique ID of this `Donation`."
  id: DonationId!
  """
    `Sum` of this `Donation`.

    Guaranteed to not be zero.
  """
  amount: Sum!
  """
    `Operation` representing this `Donation`.

    ## Result

    One of the following `Operation`s may be returned:
    - `OperationPurchaseDonation` (if the authenticated `MyUser` is the
      sender of this `Donation`);
    - `OperationEarnDonation` (if the authenticated `MyUser` is the
      receiver of this `Donation`).

    Returns `null` when the authenticated `MyUser` is:
    - neither sender nor receiver of this `Donation`;
    - receiver of this `Donation`, but its `ChatItem` is:
        - not read by him yet;
        - read, but the corresponding `OperationEarnDonation` hasn't been
          created yet (a small delay is expected).

    ## Versioning

    This field and the returned `Operation` are versioned by its own
    `OperationVersion` and not by the `ChatItemVersion` of the `ChatItem`
    this `Donation` is attached to.

    Changes of this field should be tracked via
    `Subscription.operationsEvents`.
  """
  operation: OperationsEdge
}

"Error of performing `Mutation.editChatMessage`."
type EditChatMessageError {
  "Code indicating why this error has happened."
  code: EditChatMessageErrorCode!
}

"""
  Event of a `BlocklistRecord` being added to `Query.blocklist` of the
  authenticated `MyUser`.
"""
type EventBlocklistRecordAdded implements BlocklistEvent {
  "Blocked `User`."
  user: User!
  "Reason of why the `User` was blocked."
  reason: BlocklistReason
  "`DateTime` when the `User` was blocked."
  at: DateTime!
}

"""
  Event of a `BlocklistRecord` being removed from `Query.blocklist` of the
  authenticated `MyUser`.
"""
type EventBlocklistRecordRemoved implements BlocklistEvent {
  "Unblocked `User`."
  user: User!
  "`DateTime` when the `User` was unblocked."
  at: DateTime!
}

"""
  Event of a `Chat` being archived by the authenticated `MyUser`.

  Once new `ChatItem` is posted to an unmuted `Chat`, it should be considered
  by a client side as automatically unarchived.
"""
type EventChatArchived implements ChatEvent {
  "ID of the `Chat` being archived by the authenticated `MyUser`."
  chatId: ChatId!
  "`DateTime` when the `Chat` was archived."
  at: DateTime!
}

"""
  Event of an answer timeout being reached in a `ChatCall`.

  Not emitted for `ChatCall`s in `Chat`-monologs.
"""
type EventChatCallAnswerTimeoutPassed implements ChatCallEvent & ChatEvent {
  "ID of the `ChatCall` where the answer timeout was reached."
  callId: ChatItemId!
  "`ChatCall` where the answer timeout was reached."
  call: ChatCall!
  "ID of the `Chat` the `ChatCall` belongs to."
  chatId: ChatId!
  "`Chat` the `ChatCall` belongs to."
  chat: Chat!
  """
    ID of the `User` whose answer timeout was reached.

    If `null`, then the answer timeout was reached for all the dialed
    `ChatMember`s, not listed in the `ChatMembersDialedAll.answeredMembers`
    or the `ChatMembersDialedConcrete.concrete` fields.
  """
  userId: UserId
  """
    `User` whose answer timeout was reached.

    If `null`, then the answer timeout was reached for all the dialed
    `ChatMember`s, not listed in the `ChatMembersDialedAll.answeredMembers`
    or the `ChatMembersDialedConcrete.concrete` fields.
  """
  user: User
  "`DateTime` when the answer timeout in the `ChatCall` was reached."
  at: DateTime!
}

"""
  Event of an audio/video conversation being started in a `ChatCall`, meaning
  that enough `ChatCallMember`s joined the [Medea] room after ringing had been
  finished.

  [Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallConversationStarted implements ChatCallEvent & ChatEvent {
  "ID of the `ChatCall` the conversation started in."
  callId: ChatItemId!
  "`ChatCall` the conversation started in."
  call: ChatCall!
  "ID of the `Chat` the conversation's `ChatCall` belongs to."
  chatId: ChatId!
  "`DateTime` when the conversation started."
  at: DateTime!
}

"Event of a `ChatCall` being declined by a `ChatMember`."
type EventChatCallDeclined implements ChatCallEvent & ChatEvent {
  "ID of the `ChatCall` being declined."
  callId: ChatItemId!
  "Declined `ChatCall`."
  call: ChatCall!
  "ID of the `Chat` the declined `ChatCall` belongs to."
  chatId: ChatId!
  "`User` who declined the `ChatCall`."
  user: User!
  "`DateTime` when the `ChatCall` was declined."
  at: DateTime!
}

"""
  Event of a `ChatCall` being finished.

  Client side may preliminarily disconnect from [Medea] media server when this
  event is received.

  [Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallFinished implements ChatCallEvent & ChatEvent {
  "ID of the finished `ChatCall`."
  callId: ChatItemId!
  "Finished `ChatCall`."
  call: ChatCall!
  "ID of the `Chat` the finished `ChatCall` belongs to."
  chatId: ChatId!
  "Reason of why the `ChatCall` was finished."
  reason: ChatCallFinishReason!
  "`DateTime` when the `ChatCall` was finished."
  at: DateTime!
}

"Event of a `ChatMember`'s hand being lowered in a `ChatCall`."
type EventChatCallHandLowered implements ChatCallEvent {
  "ID of the `ChatCall` the `ChatMember`'s hand being lowered in."
  callId: ChatItemId!
  "`ChatCall` the `ChatMember`'s hand being lowered in."
  call: ChatCall!
  "ID of the `Chat` the `ChatCall` belongs to."
  chatId: ChatId!
  """
    `User` representing the `ChatMember` who lowered a hand in the
    `ChatCall`.
  """
  user: User!
  "ID of the `ChatMember`'s device where his hand being lowered from."
  deviceId: ChatCallDeviceId!
  "`DateTime` when the `ChatMember` lowered his hand in the `ChatCall`."
  at: DateTime!
}

"Event of a `ChatMember`'s hand being raised in a `ChatCall`."
type EventChatCallHandRaised implements ChatCallEvent {
  "ID of the `ChatCall` the `ChatMember`'s hand being raised in."
  callId: ChatItemId!
  "`ChatCall` the `ChatMember`'s hand being raised in."
  call: ChatCall!
  "ID of the `Chat` the `ChatCall` belongs to."
  chatId: ChatId!
  """
    `User` representing the `ChatMember` who raised a hand in the
    `ChatCall`.
  """
  user: User!
  "ID of the `ChatMember`'s device where his hand being raised from."
  deviceId: ChatCallDeviceId!
  "`DateTime` when the `ChatMember` raised his hand in the `ChatCall`."
  at: DateTime!
}

"Event of a `User` joined a `ChatCall`."
type EventChatCallMemberJoined implements ChatCallEvent & ChatEvent {
  "ID of the joined `ChatCall`."
  callId: ChatItemId!
  "Joined `ChatCall`."
  call: ChatCall!
  "ID of the `Chat` the joined `ChatCall` belongs to."
  chatId: ChatId!
  "`User` who joined the `ChatCall`."
  user: User!
  "`ChatCallDeviceId` of the joined `User`."
  deviceId: ChatCallDeviceId!
  "`DateTime` when the `User` joined the `ChatCall`."
  at: DateTime!
}

"Event of a `User` leaving a `ChatCall`."
type EventChatCallMemberLeft implements ChatCallEvent & ChatEvent {
  "ID of the left `ChatCall`."
  callId: ChatItemId!
  "Left `ChatCall`."
  call: ChatCall!
  "ID of the `Chat` the left `ChatCall` belongs to."
  chatId: ChatId!
  "`User` who left the `ChatCall`."
  user: User!
  """
    Initiator of the `User` removing from the `ChatCall`.

    If this is another `User`, then the left `User` was kicked.
  """
  by: User!
  "`ChatCallDeviceId` of the `User` who left the `ChatCall`."
  deviceId: ChatCallDeviceId!
  "`DateTime` when the `User` left the `ChatCall`."
  at: DateTime!
}

"Event of a `User` being redialed in a `ChatCall`."
type EventChatCallMemberRedialed implements ChatCallEvent & ChatEvent {
  "ID of the `ChatCall` the `User` is redialed in."
  callId: ChatItemId!
  "`ChatCall` the `User` is redialed in."
  call: ChatCall!
  "ID of the `Chat` the `ChatCall` belongs to."
  chatId: ChatId!
  "`User` representing the `ChatMember` who was redialed in the `ChatCall`."
  user: User!
  """
    `User` representing the `ChatMember` who redialed the `User` in the
    `ChatCall`.
  """
  byUser: User!
  "`DateTime` when the `ChatMember` was redialed in the `ChatCall`."
  at: DateTime!
}

"Event of a dialed `User` being undialed in a `ChatCall`."
type EventChatCallMemberUndialed implements ChatCallEvent & ChatEvent {
  "ID of the `ChatCall` the dialed `User` was undialed in."
  callId: ChatItemId!
  "`ChatCall` the dialed `User` was undialed in."
  call: ChatCall!
  "ID of the `Chat` the `ChatCall` belongs to."
  chatId: ChatId!
  """
    `User` representing the dialed `ChatMember` being undialed in the
    `ChatCall`.
  """
  user: User!
  """
    `User` representing the `ChatMember` who undialed the dialed `User` in
    the `ChatCall`.
  """
  by: User!
  "`DateTime` when the dialed `ChatMember` was undialed in the `ChatCall`."
  at: DateTime!
}

"""
  Event of a `ChatCall` being moved from its `Chat`-dialog to a newly created
  `Chat`-group.

  Once this event is fired, it's required to establish a new
  `Subscription.chatCallEvents` using the emitted
  `EventChatCallMoved.newCallId`. Note, that the connection to the [Medea]
  room of the moved `ChatCall` should not be dropped, as it's simply moved to
  the returned `EventChatCallMoved.newCall`, ensuring smooth experience for
  the `ChatCall` members.

  [Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallMoved implements ChatCallEvent & ChatEvent {
  "ID of the moved `ChatCall` in the `Chat`-dialog."
  callId: ChatItemId!
  "Moved `ChatCall` in the `Chat`-dialog."
  call: ChatCall!
  "ID of the `Chat`-dialog the `ChatCall` was moved from."
  chatId: ChatId!
  "ID of the newly created `Chat`-group the `ChatCall` was moved to."
  newChatId: ChatId!
  "Newly created `Chat`-group the `ChatCall` was moved to."
  newChat: Chat!
  "ID of the moved `ChatCall` in the newly created `Chat`-group."
  newCallId: ChatItemId!
  "Moved `ChatCall` in the newly created `Chat`-group."
  newCall: ChatCall!
  "`User` who moved the `ChatCall`."
  user: User!
  "`DateTime` when the `ChatCall` was moved."
  at: DateTime!
}

"""
  Event of a [Medea] room being ready to accept the connection with the
  authenticated `MyUser`.

  Client side should connect to [Medea] media server when this event is
  received. Use `EventChatCallRoomReady.joinLink` to reach [Medea] media
  server and the `ChatCallCredentials` (generated for
  `Mutation.startChatCall` or `Mutation.joinChatCall`) to authenticate.
  Otherwise, the authenticated `MyUser` will be kicked from the `ChatCall` by
  timeout.

  This event may be emitted multiple times during the same `Call`. Each time
  client side should reconnect to [Medea] media server using the changed
  `EventChatCallRoomReady.joinLink`. If it hasn't changed, then the [Medea]
  room remains the same, and client side may continue use the already
  established connection.

  [Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallRoomReady implements ChatCallEvent {
  """
    ID of the `ChatCall` the [Medea] room is ready for.

    [Medea]: https://github.com/instrumetisto/medea
  """
  callId: ChatItemId!
  """
    `ChatCall` the [Medea] room is ready for.

    [Medea]: https://github.com/instrumetisto/medea
  """
  call: ChatCall!
  "ID of the `Chat` the ready `ChatCall` belongs to."
  chatId: ChatId!
  """
    Link for joining the `ChatCall`'s room on [Medea] media server.

    Use `ChatCallCredentials` (generated for `Mutation.startChatCall` or
    `Mutation.joinChatCall`) to authenticate.

    Should be used in conjunction with `ChatCallCredentials` (generated for
    `Mutation.startChatCall` or `Mutation.joinChatCall`) to properly
    authenticate on [Medea] media server.

    Bound to the current device of the authenticated `MyUser`, meaning that
    every device of the authenticated `MyUser` must obtain its own unique
    `ChatCallRoomJoinLink` via separate `Subscription.chatCallEvents`.

    If this value has changed during the same `Call`, it means that the
    correspondent [Medea] room has been re-created, and so, client side
    should reconnect o [Medea] media server using the changed
    `ChatCallRoomJoinLink`. If it hasn't changed, then the [Medea] room
    remains the same, and client side may continue use the already
    established connection.

    [Medea]: https://github.com/instrumetisto/medea
  """
  joinLink: ChatCallRoomJoinLink!
  """
    `DateTime` when the [Medea] room became ready.

    [Medea]: https://github.com/instrumetisto/medea
  """
  at: DateTime!
}

"""
  Event of a `ChatCall` being started.

  Either `Mutation.joinChatCall` or `Mutation.declineChatCall` should be
  executed when this event is received. Otherwise, the authenticated `MyUser`
  will be considered as timed out to answer the `ChatCall`.
"""
type EventChatCallStarted implements ChatEvent {
  "ID of the `ChatCall` being started."
  callId: ChatItemId!
  "Started `ChatCall`."
  call: ChatCall!
  "ID of the `Chat` the started `ChatCall` belongs to."
  chatId: ChatId!
  "`DateTime` when the `ChatCall` was started."
  at: DateTime!
}

"Event of a `Chat` being cleared by the authenticated `MyUser`."
type EventChatCleared implements ChatEvent {
  "ID of the `Chat` being cleared by the authenticated `MyUser`."
  chatId: ChatId!
  "`DateTime` when the `Chat` was cleared."
  at: DateTime!
}

"Event of a new `ChatContact` being created."
type EventChatContactCreated implements ChatContactEvent {
  "ID of the created `ChatContact`."
  contactId: ChatContactId!
  "Name of the created `ChatContact`."
  name: UserName!
  "`DateTime` when the `ChatContact` was created."
  at: DateTime!
}

"Event of a `ChatContact` being deleted."
type EventChatContactDeleted implements ChatContactEvent {
  "ID of the deleted `ChatContact`."
  contactId: ChatContactId!
  "`DateTime` when the `ChatContact` was deleted."
  at: DateTime!
}

"Event of a `ChatContactEmail` being added to the `ChatContact`."
type EventChatContactEmailAdded implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "Added `ChatContactEmail`."
  email: ChatContactEmail!
  "`DateTime` when the `ChatContactEmail` was added to the `ChatContact`."
  at: DateTime!
}

"Event of a `ChatContactEmail` being removed from the `ChatContact`."
type EventChatContactEmailRemoved implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "Removed `ChatContactEmail`."
  email: ChatContactEmail!
  """
    `DateTime` when the `ChatContactEmail` was removed from the
    `ChatContact`.
  """
  at: DateTime!
}

"Event of a `ChatContact` being favorited."
type EventChatContactFavorited implements ChatContactEvent {
  "ID of the favorited `ChatContact`."
  contactId: ChatContactId!
  "Position of the `ChatContact` in the favorites list."
  position: ChatContactFavoritePosition!
  "`DateTime` when the `ChatContact` was favorited."
  at: DateTime!
}

"Event of a `Chat`-group being added to the `ChatContact`."
type EventChatContactGroupAdded implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "`Chat`-group added to the `ChatContact`."
  group: Chat!
  "`DateTime` when the `Chat`-group was added to the `ChatContact`."
  at: DateTime!
}

"Event of a `Chat`-group being removed from a `ChatContact`."
type EventChatContactGroupRemoved implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "ID of removed `Chat`-group."
  groupId: ChatId!
  "`DateTime` when the `Chat`-group was removed from the `ChatContact`."
  at: DateTime!
}

"Event of a `ChatContact`'s name being updated."
type EventChatContactNameUpdated implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "Updated name of the `ChatContact`."
  name: UserName!
  "`DateTime` when the `ChatContact`'s name was updated."
  at: DateTime!
}

"Event of a `ChatContactPhone` being added to the `ChatContact`."
type EventChatContactPhoneAdded implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "Added `ChatContactPhone`."
  phone: ChatContactPhone!
  "`DateTime` when the `UserPhone` was added to the `ChatContact`."
  at: DateTime!
}

"Event of an `ChatContactPhone` being removed from a `ChatContact`."
type EventChatContactPhoneRemoved implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "Removed `ChatContactPhone`."
  phone: ChatContactPhone!
  "`DateTime` when the `UserPhone` was removed from the `ChatContact`."
  at: DateTime!
}

"Event of a `ChatContact` being unfavorited."
type EventChatContactUnfavorited implements ChatContactEvent {
  "ID of the unfavorited `ChatContact`."
  contactId: ChatContactId!
  "`DateTime` when the `ChatContact` was unfavorited."
  at: DateTime!
}

"Event of a `User` being added to the `ChatContact`."
type EventChatContactUserAdded implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "`User` added to the `ChatContact`."
  user: User!
  "`DateTime` when the `User` was added to the `ChatContact`."
  at: DateTime!
}

"Event of a `User` being removed from a `ChatContact`."
type EventChatContactUserRemoved implements ChatContactEvent {
  "ID of the `ChatContact`."
  contactId: ChatContactId!
  "ID of the removed `User`."
  userId: UserId!
  "`DateTime` when the `User` was removed from the `ChatContact`."
  at: DateTime!
}

"""
  Event of posted `ChatItem`s being delivered to `ChatMember`s other than
  the authenticated `MyUser`.
"""
type EventChatDelivered implements ChatEvent {
  "ID of the `Chat` where `ChatItem`s are delivered."
  chatId: ChatId!
  """
    `DateTime` until which the `ChatItem`s in `Chat` were delivered.

    Can be used to determine whether the last `ChatItem` posted by the
    authenticated `MyUser` was delivered to other `ChatMember`s by checking
    it was posted not later than this `DateTime`.
  """
  until: DateTime!
}

"Event of a `Chat`'s `ChatDirectLink` being deleted."
type EventChatDirectLinkDeleted implements ChatEvent {
  "ID of the `Chat` which `ChatDirectLink` was deleted."
  chatId: ChatId!
}

"Event of a `Chat`'s `ChatDirectLink` being updated."
type EventChatDirectLinkUpdated implements ChatEvent {
  "ID of the `Chat` which `ChatDirectLink` was updated."
  chatId: ChatId!
  "New `Chat`'s `ChatDirectLink`."
  directLink: ChatDirectLink!
}

"Event of a `Chat`'s `ChatDirectLink.usageCount` being updated."
type EventChatDirectLinkUsageCountUpdated implements ChatEvent {
  "ID of the `Chat` which `ChatDirectLink` was updated."
  chatId: ChatId!
  "New `Chat`'s `ChatDirectLink.usageCount`."
  usageCount: Int!
}

"""
  Event of a `Chat` being added to the favorites list of the authenticated
  `MyUser`.
"""
type EventChatFavorited implements ChatEvent & FavoriteChatsEvent {
  "ID of the favorited `Chat`."
  chatId: ChatId!
  "Position of the `Chat` in the favorites list."
  position: ChatFavoritePosition!
  "`DateTime` when the `Chat` was favorited."
  at: DateTime!
}

"Event of a `Chat` being hidden by the authenticated `MyUser`."
type EventChatHidden implements ChatEvent {
  "ID of the `Chat` being hidden by the authenticated `MyUser`."
  chatId: ChatId!
  "`DateTime` when the `Chat` was hidden."
  at: DateTime!
}

"Event of a `ChatItem` being deleted by some `User`."
type EventChatItemDeleted implements ChatEvent {
  "ID of the `Chat` where `ChatItem` is being deleted by some `User`."
  chatId: ChatId!
  "ID of the deleted `ChatItem`."
  itemId: ChatItemId!
}

"Event of a `ChatItem` being edited by its author."
type EventChatItemEdited implements ChatEvent {
  "ID of the `Chat` where the `ChatItem` was edited by its author."
  chatId: ChatId!
  "ID of the edited `ChatItem`."
  itemId: ChatItemId!
  """
    Edited `ChatItem`'s text.

    `null` means that the previous `ChatItem`'s text remains unchanged.
  """
  text: ChangedChatMessageText
  """
    Edited `Attachment`s of the `ChatItem`.

    `null` means that the previous `Attachment`s remain unchanged.
  """
  attachments: ChangedChatMessageAttachments
  """
    `ChatItemQuote`s the edited `ChatItem` replies to.

    `null` means that the previous `ChatItemQuote`s remain unchanged.
  """
  repliesTo: ChangedChatMessageReplies
}

"Event of a `ChatItem` being hidden by the authenticated `MyUser`."
type EventChatItemHidden implements ChatEvent {
  """
    ID of the `Chat` where `ChatItem` is being hidden by the authenticated
    `MyUser`.
  """
  chatId: ChatId!
  "ID of the hidden `ChatItem`."
  itemId: ChatItemId!
}

"""
  Event of a new `ChatItem` being posted in a `Chat`.

  If the `item` field contains a `ChatCall` this event is immediately followed
  by a `EventChatCallStarted` right after. Making a `Subscription.chatEvents`
  starting from the version of this event won't emit the related
  `EventChatCallStarted`, however.
"""
type EventChatItemPosted implements ChatEvent {
  "ID of the `Chat` where `ChatItem` is being posted."
  chatId: ChatId!
  "Posted `ChatItem`."
  item: ChatItemsEdge!
}

"Event of a `Chat` last item being updated."
type EventChatLastItemUpdated implements ChatEvent {
  "ID of the `Chat` where last item was updated."
  chatId: ChatId!
  "Updated last `ChatItem`."
  lastItem: ChatItemsEdge
}

"""
  Event of a `Chat` being muted by the authenticated `MyUser`.

  Once `duration` pasts (or is in the past already), it should be considered
  by a client side as automatically unmuted. Server won't notify a client side
  about that.
"""
type EventChatMuted implements ChatEvent {
  "ID of the `Chat` being muted by the authenticated `MyUser`."
  chatId: ChatId!
  "Duration the `Chat` should be muted until."
  duration: MuteDuration!
}

"Event of a `Chat` being read by a `User`."
type EventChatRead implements ChatEvent {
  "ID of the `Chat` being read by the `User`."
  chatId: ChatId!
  "`User` who read the `Chat`."
  byUser: User!
  "`DateTime` when the `Chat` was read by the `User`."
  at: DateTime!
}

"Event of a `Chat` total items count being updated."
type EventChatTotalItemsCountUpdated implements ChatEvent {
  "ID of the `Chat` where total items count was updated."
  chatId: ChatId!
  "Updated total `ChatItem`s count."
  count: Int!
}

"Event of a `ChatMember` started typing in a `Chat`."
type EventChatTypingStarted implements ChatEvent {
  "ID of the `Chat` where `User` started typing."
  chatId: ChatId!
  "`User` who started typing."
  user: User!
}

"Event of a `ChatMember` stopped typing in a `Chat`."
type EventChatTypingStopped implements ChatEvent {
  "ID of the `Chat` where `User` stopped typing."
  chatId: ChatId!
  "`User` who stopped typing."
  user: User!
}

"""
  Event of a `Chat` being manually unarchived by the authenticated `MyUser`.

  This event means only that the authenticated `MyUser` manually unarchived
  the `Chat`, and doesn't indicate situations when the `Chat` is unarchived
  automatically (new `ChatItem` is posted to an unmuted `Chat`).
"""
type EventChatUnarchived implements ChatEvent {
  """
    ID of the `Chat` being manually unarchived by the authenticated
    `MyUser`.
  """
  chatId: ChatId!
  "`DateTime` when the `Chat` was manually unarchived."
  at: DateTime!
}

"""
  Event of a `Chat` being removed from the favorites list of the authenticated
  `MyUser`.
"""
type EventChatUnfavorited implements ChatEvent & FavoriteChatsEvent {
  "ID of the unfavorited `Chat`."
  chatId: ChatId!
  "`DateTime` when the `Chat` was unfavorited."
  at: DateTime!
}

"""
  Event of a `Chat` being unmuted by the authenticated `MyUser`.

  This event means that `MyUser` had manually unmuted the `Chat` before
  `MuteDuration` expired.
"""
type EventChatUnmuted implements ChatEvent {
  "ID of the `Chat` being unmuted by the authenticated `MyUser`."
  chatId: ChatId!
}

"Event of a `Chat` unread items count being updated."
type EventChatUnreadItemsCountUpdated implements ChatEvent {
  "ID of the `Chat` where unread items count was updated."
  chatId: ChatId!
  "Updated unread `ChatItem`s count."
  count: Int!
}

"""
  Event of a `ChatCall` becoming the topmost in `Query.incomingChatCalls`
  list.
"""
type EventIncomingChatCallsTopChatCallAdded {
  "`ChatCall` becoming the topmost one."
  call: ChatCall!
}

"Event of a `ChatCall` being removed from `Query.incomingChatCalls` list."
type EventIncomingChatCallsTopChatCallRemoved {
  "`ChatCall` removed from the top."
  call: ChatCall!
}

"Event of `MonetizationSettingsDonation` being deleted."
type EventMonetizationSettingsDonationDeleted implements MonetizationSettingsEvent {
  """
    `User` the `MonetizationSettings` are specified individually for.

    ## Versioning

    Returned `EventMonetizationSettingsDonationDeleted.user` field is
    versioned by its own `UserVersion` and not by the
    `MonetizationSettingsVersion` of this `MonetizationSettingsEvent`.
  """
  user: User!
  """
    `MonetizationSettingsEdge` of the changed `MonetizationSettings` the
    deleted `MonetizationSettingsDonation` were part of.

    # Result

    `null` if the `MonetizationSettings` no longer exist.
  """
  monetizationSettings: MonetizationSettingsEdge
  "`DateTime` when the `MonetizationSettingsDonation` were deleted."
  at: DateTime!
}

"Event of a `MonetizationSettingsDonation.min` `Price` being updated."
type EventMonetizationSettingsDonationMinPriceUpdated implements MonetizationSettingsEvent {
  """
    `User` the updated `MonetizationSettingsDonation` are specified
    individually for.

    ## Result

    `null` if:
    - The updated `MonetizationSettingsDonation` are common (applied to all
      `User`s);
    - The authenticated `MyUser` is not owner of the updated
      `MonetizationSettingsDonation`.

    ## Versioning

    Returned `EventMonetizationSettingsDonationMinPriceUpdated.user` field
    is versioned by its own `UserVersion` and not by the
    `MonetizationSettingsVersion` of this `MonetizationSettingsEvent`.
  """
  user: User
  "Updated `MonetizationSettingsDonation.min` `Price`."
  min: Price!
  """
    `MonetizationSettingsEdge` of the changed `MonetizationSettings` the
    updated `MonetizationSettingsDonation` are part of.

    # Result

    `null` if the `MonetizationSettings` no longer exist.
  """
  monetizationSettings: MonetizationSettingsEdge
  """
    `DateTime` when the `MonetizationSettingsDonation.min` `Price` was
    updated.
  """
  at: DateTime!
}

"Event of a `MonetizationSettingsDonation.enabled` state being updated."
type EventMonetizationSettingsDonationToggled implements MonetizationSettingsEvent {
  """
    `User` the updated `MonetizationSettingsDonation` are specified
    individually for.

    ## Result

    `null` if:
    - The updated `MonetizationSettingsDonation` are common (applied to all
      `User`s);
    - The authenticated `MyUser` is not owner of the updated
      `MonetizationSettingsDonation`.

    ## Versioning

    Returned `EventMonetizationSettingsDonationToggled.user` field
    is versioned by its own `UserVersion` and not by the
    `MonetizationSettingsVersion` of this `MonetizationSettingsEvent`.
  """
  user: User
  "Updated `MonetizationSettingsDonation.enabled` state."
  enabled: Boolean!
  """
    `MonetizationSettingsEdge` of the changed `MonetizationSettings` the
    updated `MonetizationSettingsDonation` are part of.

    # Result

    `null` if the `MonetizationSettings` no longer exist.
  """
  monetizationSettings: MonetizationSettingsEdge
  """
    `DateTime` when the `MonetizationSettingsDonation.enabled` state was
    updated.
  """
  at: DateTime!
}

"Event of an `Operation` being canceled."
type EventOperationCanceled implements OperationEvent {
  "ID of the canceled `Operation`."
  id: OperationId!
  """
    `OperationOrigin` of the canceled `Operation`.

    Alias to the `EventOperationCanceled.operation.node.origin` field.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the canceled `Operation`."
  operation: OperationsEdge!
  "Information about why the `Operation` was canceled."
  canceled: OperationCancellation!
  "`DateTime` when the `Operation` was canceled."
  at: DateTime!
}

"Event of a new `OperationCharge` being created."
type EventOperationChargeCreated implements OperationEvent {
  "Unique ID of the created `OperationCharge`."
  id: OperationId!
  "Sequential number of the created `OperationCharge`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationCharge`.

    Could be either `OperationOrigin.PURSE` or `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationCharge`."
  operation: OperationsEdge!
  """
    Money `Sum` and `Currency` of the created `OperationCharge`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Reason of the `OperationCharge` creation."
  reason: OperationReason!
  """
    `OperationsEdge`s of the `Operation`s the created `OperationCharge` is
    linked to.
  """
  linked: [OperationsEdge!]!
  "`DateTime` when the `OperationCharge` was created."
  at: DateTime!
}

"Event of a new `OperationDepositBonus` being created."
type EventOperationDepositBonusCreated implements OperationEvent {
  "Unique ID of the created `OperationDepositBonus`."
  id: OperationId!
  "Sequential number of the created `OperationDepositBonus`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationDepositBonus`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationDepositBonus`."
  operation: OperationsEdge!
  """
    `OperationsEdge` of the `OperationDeposit` the created
    `OperationDepositBonus` is linked to.

    Guaranteed to contain the `OperationDeposit` inside.
  """
  deposit: OperationsEdge!
  """
    Money `Sum` and `Currency` of the created `OperationDepositBonus`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationsEdge` of the `OperationDeposit` the created
    `OperationDepositBonus` is linked to.

    Guaranteed to return exactly a single `OperationsEdge` with the
    `OperationDeposit` inside.
  """
  linked: [OperationsEdge!]!
  "`DateTime` when the `OperationDepositBonus` was created."
  at: DateTime!
}

"Event of an `OperationDeposit` being completed."
type EventOperationDepositCompleted implements OperationEvent {
  "ID of the completed `OperationDeposit`."
  id: OperationId!
  """
    `OperationOrigin` of the completed `OperationDeposit`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the completed `OperationDeposit`."
  operation: OperationsEdge!
  "`DateTime` when the `OperationDeposit` was completed."
  at: DateTime!
}

"Event of a new `OperationDeposit` being created."
type EventOperationDepositCreated implements OperationEvent {
  "Unique ID of the created `OperationDeposit`."
  id: OperationId!
  "Sequential number of the created `OperationDeposit`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationDeposit`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationDeposit`."
  operation: OperationsEdge!
  "Kind of the created `OperationDeposit`."
  kind: OperationDepositKind!
  """
    Pricing of the created `OperationDeposit`.

    `null` means that the pricing is not yet determined.
  """
  price: OperationDepositPricing
  "Billing country of the created `OperationDeposit`."
  billingCountry: CountryCode!
  "`DateTime` when the `OperationDeposit` was created."
  at: DateTime!
}

"Event of an `OperationDeposit` being declined."
type EventOperationDepositDeclined implements OperationEvent {
  "ID of the declined `OperationDeposit`."
  id: OperationId!
  """
    `OperationOrigin` of the declined `OperationDeposit`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the declined `OperationDeposit`."
  operation: OperationsEdge!
  "`DateTime` when the `OperationDeposit` was declined."
  at: DateTime!
}

"Event of an `OperationDeposit` being failed."
type EventOperationDepositFailed implements OperationEvent {
  "ID of the failed `OperationDeposit`."
  id: OperationId!
  """
    `OperationOrigin` of the failed `OperationDeposit`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the failed `OperationDeposit`."
  operation: OperationsEdge!
  "`DateTime` when the `OperationDeposit` was failed."
  at: DateTime!
}

"Event of a new `OperationDividend` being created."
type EventOperationDividendCreated implements OperationEvent {
  "Unique ID of the created `OperationDividend`."
  id: OperationId!
  "Sequential number of the created `OperationDividend`."
  num: OperationNum!
  """
    Money `Sum` and `Currency` of the created `OperationDividend`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationOrigin` of the created `OperationDividend`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationDividend`."
  operation: OperationsEdge!
  "ID of the source `Operation` the `OperationDividend` was created for."
  sourceId: OperationId!
  "`DateTime` when the `OperationDividend` was created."
  at: DateTime!
}

"Event of a new `OperationEarnDonation` being created."
type EventOperationEarnDonationCreated implements OperationEvent {
  "Unique ID of the created `OperationEarnDonation`."
  id: OperationId!
  "Sequential number of the created `OperationEarnDonation`."
  num: OperationNum!
  """
    Money `Sum` and `Currency` of the created `OperationEarnDonation`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationOrigin` of the created `OperationEarnDonation`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationEarnDonation`."
  operation: OperationsEdge!
  """
    `ChatItem` the earned `Donation` is part of.

    `null` if the `ChatItem` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  chatItem: ChatItemsEdge
  """
    `Chat` the related `ChatItem` of the earned `Donation` belongs to.

    Always non-`null` at this moment.
  """
  chat: Chat
  "ID of the `Donation` earned by the created `OperationEarnDonation`."
  donationId: DonationId!
  """
    `User` who made the `Donation` triggering the `OperationEarnDonation`
    creation.
  """
  customer: User!
  "`DateTime` when the `OperationEarnDonation` was created."
  at: DateTime!
}

"Event of a new `OperationGrant` being created."
type EventOperationGrantCreated implements OperationEvent {
  "Unique ID of the created `OperationGrant`."
  id: OperationId!
  "Sequential number of the created `OperationGrant`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationGrant`.

    Could be either `OperationOrigin.PURSE` or `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationGrant`."
  operation: OperationsEdge!
  """
    Money `Sum` and `Currency` of the created `OperationGrant`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Reason of the `OperationGrant` creation."
  reason: OperationReason!
  """
    `OperationsEdge`s of the `Operation`s the created `OperationGrant` is
    linked to.
  """
  linked: [OperationsEdge!]!
  "`DateTime` when the `OperationGrant` was created."
  at: DateTime!
}

"Event of a new `OperationPurchaseDonation` being created."
type EventOperationPurchaseDonationCreated implements OperationEvent {
  "Unique ID of the created `OperationPurchaseDonation`."
  id: OperationId!
  "Sequential number of the created `OperationPurchaseDonation`."
  num: OperationNum!
  """
    Money `Sum` and `Currency` of the created `OperationPurchaseDonation`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationOrigin` of the created `OperationPurchaseDonation`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationPurchaseDonation`."
  operation: OperationsEdge!
  """
    `ChatItem` the made `Donation` is part of.

    `null` if the `ChatItem` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  chatItem: ChatItemsEdge
  """
    `Chat` the related `ChatItem` of the made `Donation` belongs to.

    Always non-`null` at this moment.
  """
  chat: Chat
  "ID of the `Donation` made by the created `OperationPurchaseDonation`."
  donationId: DonationId!
  """
    `Vendor` receiving the `Donation` made by the created
    `OperationPurchaseDonation`.

    Always a `User`.
  """
  vendor: Vendor!
  "`DateTime` when the `OperationPurchaseDonation` was created."
  at: DateTime!
}

"Event of a new `OperationReward` being created."
type EventOperationRewardCreated implements OperationEvent {
  "Unique ID of the created `OperationReward`."
  id: OperationId!
  "Sequential number of the created `OperationReward`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationReward`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationReward`."
  operation: OperationsEdge!
  """
    Money `Sum` and `Currency` of the created `OperationReward`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Cause of the created `OperationReward`."
  cause: OperationRewardCause!
  """
    Sequential number of the affiliated `User` causing the created
    `OperationReward`.
  """
  affiliatedNum: UserAffiliatedNum!
  "`DateTime` when the `OperationReward` was created."
  at: DateTime!
}

"Event of a new `OperationWithdraw` being created."
type EventOperationWithdrawCreated implements OperationEvent {
  "Unique ID of the created `OperationWithdraw`."
  id: OperationId!
  "Sequential number of the created `OperationWithdraw`."
  num: OperationNum!
  """
    `OperationOrigin` of the created `OperationWithdraw`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  "`OperationsEdge` of the created `OperationWithdraw`."
  operation: OperationsEdge!
  "Kind of the created `OperationWithdraw`."
  kind: OperationWithdrawKind!
  "Pricing of the created `OperationWithdraw`."
  price: OperationWithdrawPricing!
  "Billing country of the created `OperationWithdraw`."
  billingCountry: CountryCode!
  "Beneficiary `BankAccountRequisites` of the created `OperationWithdraw`."
  beneficiary: BankAccountRequisites!
  "Intermediary `BankAccountRequisites` of the created `OperationWithdraw`."
  intermediary: BankAccountRequisites
  "`DateTime` when the `OperationWithdraw` was created."
  at: DateTime!
}

"Event of a `PromoShare` being removed."
type EventPromoShareRemoved {
  "ID of the `User` whose `PromoShare` was removed."
  ownerId: UserId!
  "`Percentage` that was removed."
  percentage: Percentage!
  "`DateTime` when the `PromoShare` was removed."
  at: DateTime!
}

"Event of a `PromoShare` being updated."
type EventPromoShareUpdated {
  "ID of the `User` whose `PromoShare` was updated."
  ownerId: UserId!
  "New `Percentage` being set."
  newPercentage: Percentage!
  "Previous `Percentage` that was set before, if any."
  oldPercentage: Percentage
  "`DateTime` when the `PromoShare` was updated."
  at: DateTime!
}

"Event of a `Chat` being removed from a top of `Query.recentChats` list."
type EventRecentChatsTopChatRemoved {
  "ID of the `Chat` removed from the top."
  chatId: ChatId!
}

"Event of a `Chat` becoming the topmost in `Query.recentChats` list."
type EventRecentChatsTopChatUpdated {
  "`Chat` becoming the topmost one."
  chat: RecentChatsEdge!
}

"Event of a new `Session` being created."
type EventSessionCreated implements SessionEvent {
  "ID of the created `Session`."
  id: SessionId!
  "`SiteDomain` of the `Site` the `Session` was created on."
  siteDomain: SiteDomain!
  "`UserAgent` the `Session` was created by."
  userAgent: UserAgent!
  "`IP` of the device the `Session` was created from."
  ip: IP!
  """
    Indicator whether the created `Session` is remembered and is allowed to
    be refreshed via `Mutation.refreshSession`.
  """
  remembered: Boolean!
  "`DateTime` when the `Session` was created."
  at: DateTime!
}

"Event of a `Session` being deleted."
type EventSessionDeleted implements SessionEvent {
  "ID of the deleted `Session`."
  id: SessionId!
  "`DateTime` when the `Session` was deleted."
  at: DateTime!
}

"Event of a `Session` being refreshed."
type EventSessionRefreshed implements SessionEvent {
  "ID of the refreshed `Session`."
  id: SessionId!
  "`UserAgent` the `Session` was refreshed by."
  userAgent: UserAgent!
  "`IP` of the device the `Session` was refreshed from."
  ip: IP!
  "`DateTime` when the `Session` was refreshed."
  at: DateTime!
}

"Event of a `UserAvatar` being removed."
type EventUserAvatarRemoved implements UserEvent {
  "ID of the `User` whose `UserAvatar` was removed."
  userId: UserId!
  "`DateTime` when the `UserAvatar` was removed."
  at: DateTime!
}

"Event of a `UserAvatar` being updated."
type EventUserAvatarUpdated implements UserEvent {
  "ID of the `User` whose `UserAvatar` was updated."
  userId: UserId!
  "New `UserAvatar`."
  avatar: UserAvatar!
  "`DateTime` when the `UserAvatar` was updated."
  at: DateTime!
}

"Event of a `UserBio` being removed."
type EventUserBioRemoved implements UserEvent {
  "ID of the `User` whose `UserBio` was removed."
  userId: UserId!
  "`DateTime` when the `UserBio` was removed."
  at: DateTime!
}

"Event of a `UserBio` being updated."
type EventUserBioUpdated implements UserEvent {
  "ID of the `User` whose `UserBio` was updated."
  userId: UserId!
  "New `UserBio`."
  bio: UserBio!
  "`DateTime` when the `UserBio` was updated."
  at: DateTime!
}

"Event of a `UserCallCover` being removed."
type EventUserCallCoverRemoved implements UserEvent {
  "ID of the `User` whose `UserCallCover` was removed."
  userId: UserId!
  "`DateTime` when the `UserCallCover` was removed."
  at: DateTime!
}

"Event of a `UserCallCover` being updated."
type EventUserCallCoverUpdated implements UserEvent {
  "ID of the `User` whose `UserCallCover` was updated."
  userId: UserId!
  "New `UserCallCover`."
  callCover: UserCallCover!
  "`DateTime` when the `UserCallCover` was updated."
  at: DateTime!
}

"Event of a `User` coming offline."
type EventUserCameOffline implements UserEvent {
  "ID of the `User` who came offline."
  userId: UserId!
  "`DateTime` when the `User` was online the last time."
  at: DateTime!
}

"Event of a `User` coming online."
type EventUserCameOnline implements UserEvent {
  "ID of the `User` who came online."
  userId: UserId!
}

"Event of a `User` being deleted."
type EventUserDeleted implements UserEvent {
  "ID of the deleted `User`."
  userId: UserId!
  "`DateTime` when the `User` was deleted."
  at: DateTime!
}

"Event of a `User`'s `ChatDirectLink` being deleted."
type EventUserDirectLinkDeleted {
  "ID of the `User` whose `ChatDirectLink` was deleted."
  userId: UserId!
}

"Event of a `User`'s `ChatDirectLink` being updated."
type EventUserDirectLinkUpdated {
  "ID of the `User` whose `ChatDirectLink` was updated."
  userId: UserId!
  "New `User`'s `ChatDirectLink`."
  directLink: ChatDirectLink!
}

"Event of a `User`'s `ChatDirectLink.usageCount` being updated."
type EventUserDirectLinkUsageCountUpdated {
  "ID of the `User` whose `ChatDirectLink` was updated."
  userId: UserId!
  "New `User`'s `ChatDirectLink.usageCount`."
  usageCount: Int!
}

"Event of a new `UserEmail` address being added to `MyUser.emails`."
type EventUserEmailAdded {
  "ID of the `User` who added the `UserEmail` address."
  userId: UserId!
  "Added `UserEmail` address."
  email: UserEmail!
  """
    Indicator whether the added `UserEmail` address is `confirmed`.

    If `true`, then the `UserEmail` address was added to the
    `MyUser.emails.confirmed` ones, otherwise was set as the
    `MyUser.emails.unconfirmed` one.
  """
  confirmed: Boolean!
  "`DateTime` when the `UserEmail` address was added."
  at: DateTime!
}

"Event of a `UserEmail` address being removed from `MyUser.emails`."
type EventUserEmailRemoved {
  "ID of the `User` who removed his `UserEmail` address."
  userId: UserId!
  "Removed `UserEmail` address."
  email: UserEmail!
  "`DateTime` when the `UserEmail` address was removed."
  at: DateTime!
}

"Event of a `UserLogin` being removed."
type EventUserLoginRemoved {
  "ID of the `User` whose `UserLogin` was removed."
  userId: UserId!
  "`DateTime` when the `UserLogin` was removed."
  at: DateTime!
}

"Event of a `UserLogin` being updated."
type EventUserLoginUpdated {
  "ID of the `User` whose `UserLogin` was updated."
  userId: UserId!
  "New `UserLogin`."
  login: UserLogin!
  "`DateTime` when the `UserLogin` was updated."
  at: DateTime!
}

"Event of a `User` being muted."
type EventUserMuted {
  "ID of the muted `User`."
  userId: UserId!
  "Duration of the mute."
  until: MuteDuration!
}

"Event of a `UserName` being removed."
type EventUserNameRemoved implements UserEvent {
  "ID of the `User` whose `UserName` was removed."
  userId: UserId!
  "`DateTime` when the `UserName` was removed."
  at: DateTime!
}

"Event of a `UserName` being updated."
type EventUserNameUpdated implements UserEvent {
  "ID of the `User` whose `UserName` was updated."
  userId: UserId!
  "New `UserName`."
  name: UserName!
  "`DateTime` when the `UserName` was updated."
  at: DateTime!
}

"Event of a `User`'s password being removed."
type EventUserPasswordRemoved {
  "ID of the `User` whose password was removed."
  userId: UserId!
  "`DateTime` when the `User`'s password was removed."
  at: DateTime!
}

"Event of a `User`'s password being updated."
type EventUserPasswordUpdated {
  "ID of the `User` whose password was updated."
  userId: UserId!
  "`DateTime` when the `User`'s password was updated."
  at: DateTime!
}

"Event of a new `UserPhone` number being added to `MyUser.phones`."
type EventUserPhoneAdded {
  "ID of the `User` who added the `UserPhone` number."
  userId: UserId!
  "Added `UserPhone` number."
  phone: UserPhone!
  """
    Indicator whether the added `UserPhone` number is `confirmed`.

    If `true`, then the `UserPhone` number was added to the
    `MyUser.phones.confirmed` ones, otherwise was set as the
    `MyUser.phones.unconfirmed` one.
  """
  confirmed: Boolean!
  "`DateTime` when the `UserPhone` number was added."
  at: DateTime!
}

"Event of a `UserPhone` number being removed from `MyUser.phones`."
type EventUserPhoneRemoved {
  "ID of the `User` who removed his `UserPhone` number."
  userId: UserId!
  "Removed `UserPhone` number."
  phone: UserPhone!
  "`DateTime` when the `UserPhone` number was removed."
  at: DateTime!
}

"Event of a `User`'s `UserPresence` being updated."
type EventUserPresenceUpdated implements UserEvent {
  "ID of the `User` whose `UserPresence` was updated."
  userId: UserId!
  "New `User`'s `UserPresence`."
  presence: UserPresence!
  "`DateTime` when the `User`'s `UserPresence` was updated."
  at: DateTime!
}

"Event of a `UserTextStatus` being removed."
type EventUserStatusRemoved implements UserEvent {
  "ID of the `User` whose `UserTextStatus` was removed."
  userId: UserId!
  "`DateTime` when the `UserTextStatus` was removed."
  at: DateTime!
}

"Event of a `UserTextStatus` being updated."
type EventUserStatusUpdated implements UserEvent {
  "ID of the `User` whose `UserTextStatus` was updated."
  userId: UserId!
  "New `UserTextStatus`."
  status: UserTextStatus!
  "`DateTime` when the `UserTextStatus` was updated."
  at: DateTime!
}

"Event of a `User` being unmuted."
type EventUserUnmuted {
  "ID of the unmuted `User`."
  userId: UserId!
}

"Event of a `User`'s unread `Chat`s count being updated."
type EventUserUnreadChatsCountUpdated {
  "ID of the `User` whose unread `Chat`s count was updated."
  userId: UserId!
  "New `User`'s unread `Chat`s count."
  count: Int!
}

"Event of a `WelcomeMessage` being deleted by its author."
type EventUserWelcomeMessageDeleted implements UserEvent {
  "ID of the `User` whose `WelcomeMessage` was deleted."
  userId: UserId!
  "`DateTime` when the `WelcomeMessage` was deleted."
  at: DateTime!
}

"Event of a `WelcomeMessage` being updated by its author."
type EventUserWelcomeMessageUpdated implements UserEvent {
  "ID of the `User` whose `WelcomeMessage` was updated."
  userId: UserId!
  """
    Edited `WelcomeMessage.text`.

    `null` means that the previous `WelcomeMessage.text` remains unchanged.
  """
  text: ChangedChatMessageText
  """
    Edited `WelcomeMessage.attachments`.

    `null` means that the previous `WelcomeMessage.attachments` remain
    unchanged.
  """
  attachments: ChangedChatMessageAttachments
  "`DateTime` when the `WelcomeMessage` was updated."
  at: DateTime!
}

"Error of performing `Mutation.favoriteChatContact`."
type FavoriteChatContactError {
  "Code indicating why this error has happened."
  code: FavoriteChatContactErrorCode!
}

"""
  [Connection] with favorite `ChatContact`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type FavoriteChatContactsConnection {
  """
    List of favorite `ChatContact` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [FavoriteChatContactsEdge!]!
  """
    List of favorite `ChatContact`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatContact!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  """
    Version of this `ChatContact`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking list state's actuality.

    Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  ver: ChatContactsListVersion!
}

"""
  [Edge] with a favorite `ChatContact`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type FavoriteChatContactsEdge {
  """
    `ChatContact` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatContact!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: FavoriteChatContactsCursor!
}

"Error of performing `Mutation.favoriteChat`."
type FavoriteChatError {
  "Code indicating why this error has happened."
  code: FavoriteChatErrorCode!
}

"""
  [Connection] with favorite `Chat`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type FavoriteChatsConnection {
  """
    List of favorite `Chat` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [FavoriteChatsEdge!]!
  """
    List of favorite `Chat`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [Chat!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  """
    Version of this favorite `Chat`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking list state's actuality.

    Also, intended to be used in `Subscription.favoriteChatsEvents`.
  """
  ver: FavoriteChatsListVersion!
}

"""
  [Edge] with a favorite `Chat`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type FavoriteChatsEdge {
  """
    `Chat` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: Chat!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: FavoriteChatsCursor!
}

"""
  `FavoriteChatsEvent`s along with the corresponding
  `FavoriteChatsListVersion`.
"""
type FavoriteChatsEventsVersioned {
  "`FavoriteChatsEvent`s themselves."
  events: [FavoriteChatsEvent!]!
  """
    Version of the `FavoriteChatsList`'s state updated by these
    `FavoriteChatsEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: FavoriteChatsListVersion!
}

"List of favorite `Chat`s."
type FavoriteChatsList {
  """
    Returns favorite `Chat`s of the authenticated `MyUser` ordered by the
    custom order of `MyUser`'s favorites list (using `Chat.favoritePosition`
    field).

    Aliases `Query.favoriteChats`.
  """
  chats("Number of next `Chat`s to return." first: Int, "Cursor indicating the `FavoriteChatsEdge` position to return next `Chat`s after." after: FavoriteChatsCursor, "Number of prior `Chat`s to return." last: Int, "Cursor indicating the `FavoriteChatsEdge` position to return prior `Chat`s before." before: FavoriteChatsCursor): FavoriteChatsConnection!
}

"Plain file `Attachment`."
type FileAttachment implements Attachment {
  "Unique ID of this `FileAttachment`."
  id: AttachmentId!
  "Original `PlainFile` representing this `FileAttachment`."
  original: PlainFile!
  "Uploaded `PlainFile`'s name."
  filename: String!
}

"Error of performing `Mutation.forwardChatItems`."
type ForwardChatItemsError {
  "Code indicating why this error has happened."
  code: ForwardChatItemsErrorCode!
}

"Error of performing `Mutation.hideChat`."
type HideChatError {
  "Code indicating why this error has happened."
  code: HideChatErrorCode!
}

"Error of performing `Mutation.hideChatItem`."
type HideChatItemError {
  "Code indicating why this error has happened."
  code: HideChatItemErrorCode!
}

"Image `Attachment`."
type ImageAttachment implements Attachment {
  "Unique ID of this `ImageAttachment`."
  id: AttachmentId!
  "Original `ImageFile` representing this `ImageAttachment`."
  original: ImageFile!
  "Uploaded `ImageFile`'s name."
  filename: String!
  """
    `big` view `ImageFile` of this `ImageAttachment`, scaled proportionally
    to `800px` of its maximum dimension (either width or height).
  """
  big: ImageFile!
  """
    `medium` view `ImageFile` of this `ImageAttachment`, scaled
    proportionally to `200px` of its maximum dimension (either width or
    height).
  """
  medium: ImageFile!
  """
    `small` view `ImageFile` of this `ImageAttachment`, scaled
    proportionally to `60px` of its maximum dimension (either width or
    height).
  """
  small: ImageFile!
}

"Image-`File` on a file storage."
type ImageFile implements File {
  """
    [Relative reference][1] to this `ImageFile` on a file storage.

    Prepend it with a file storage URL to obtain the full link to this
    `ImageFile`.

    If `404` HTTP status code is returned while trying to download this
    `ImageFile` from a file storage, then the `ImageFile` is not ready yet.
    Back off, and retry again later.

    `403` HTTP status code, on the other hand, means that the link has been
    expired and this [relative reference][1] should be re-fetched to rebuild
    the link.

    [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!
  "Width of this `ImageFile` in pixels."
  width: Int
  "Height of this `ImageFile` in pixels."
  height: Int
  """
    [SHA-256] checksum of this `ImageFile`.

    May be `null` in case this `ImageFile` is not ready on a file storage
    yet. May be also computed on a client side, once this `ImageFile`
    is ready and successfully downloaded from a file storage.

    This checksum is especially useful if a client side requires to verify
    the integrity and authenticity of this `ImageFile`, downloaded from
    a file storage.

    Also, this checksum may be useful as a key in a client side cache,
    allowing to store `ImageFile`s in deduplicated manner.

    [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String
  """
    Size of this `ImageFile` (in bytes).

    May be `null` in case this `ImageFile` is not ready on a file storage
    yet. May be also computed on a client side, once this `ImageFile`
    is ready and successfully downloaded from a file storage.
  """
  size: Int
  """
    [Base64URL]-encoded [ThumbHash] of this `ImageFile`.

    May be `null` in case this `ImageFile` is an `original`, or it is not
    ready on a file storage yet.

    This [ThumbHash] is especially useful on a client side to pre-render
    this `ImageFile` before downloading it from a file storage.

    > __WARNING__: As [ThumbHash] dimensions are 32 pixels at most, the
    >              aspect ratio of this `thumbhash` may differ a little bit
    >              from the one of `width` and `height` fields, due to
    >              precision loss in rescaling process. That's why, to
    >              pre-render this `ImageFile` properly, just scaling the
    >              `thumbhash` proportionally won't be enough, and it rather
    >              should be stretched to fill the whole area of `width` and
    >              `height` dimensions.

    [Base64URL]: https://base64.guru/standards/base64url
    [ThumbHash]: https://evanw.github.io/thumbhash
  """
  thumbhash: ThumbHash
}

"""
  [Connection] used in `Query.incomingChatCalls`.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type IncomingChatCallsConnection {
  """
    List of incoming `ChatCall` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [IncomingChatCallsEdge!]!
  """
    List of incoming `ChatCall`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatCall!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""
  [Edge] used in `Query.incomingChatCalls`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type IncomingChatCallsEdge {
  """
    Incoming `ChatCall` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatCall!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: IncomingChatCallsCursor!
}

"""
  Initial top of `Query.incomingChatCalls` list emitted by
  `Subscription.incomingChatCallsTopEvents`.
"""
type IncomingChatCallsTop {
  """
    List of top incoming `ChatCall`s.

    ## Sorting

    Returned `ChatCall`s are sorted primarily by their starting `DateTime`,
    and secondary by their IDs (if the starting `DateTime` is the same), in
    descending order.
  """
  list: [ChatCall!]!
}

"""
  Information about some `User` being present in a `Query.blocklist` of the
  authenticated `MyUser`.
"""
type IsBlocked {
  """
    `BlocklistRecord` of the `User` in the `Query.blocklist`.

    `null` if the `User` is not blocked by the authenticated `MyUser`.
  """
  record: BlocklistRecord
  "Version of the authenticated `MyUser`'s `Blocklist`."
  ver: BlocklistVersion!
}

"Error of performing `Mutation.joinChatCall`."
type JoinChatCallError {
  "Code indicating why this error has happened."
  code: JoinChatCallErrorCode!
}

"Result of a successful performing `Mutation.joinChatCall`."
type JoinChatCallOk {
  """
    ID of the device the authenticated `MyUser` joined the `ChatCall` from.

    Use this ID in `Subscription.chatCallEvents` and
    `Mutation.leaveChatCall` to distinguish between different devices of the
    authenticated `MyUser`.
  """
  deviceId: ChatCallDeviceId!
  """
    The only `ChatEvent` which may be produced by performing
    `Mutation.joinChatCall`:
    - `EventChatCallMemberJoined`.

    `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

"Information about a `Chat` being read last time by a `User`."
type LastChatRead {
  "ID of the `User` who read the `Chat`."
  memberId: UserId!
  "`DateTime` when the `Chat` was read last time."
  at: DateTime!
}

"Error of performing `Mutation.leaveChatCall`."
type LeaveChatCallError {
  "Code indicating why this error has happened."
  code: LeaveChatCallErrorCode!
}

"Monetization settings of a `Vendor`."
type MonetizationSettings {
  """
    Monetization settings of `Donation`s.

    `null` if no settings are specified.
  """
  donation: MonetizationSettingsDonation
  """
    `User` these `MonetizationSettings` are specified individually for.

    ## Result

    `null` if:
    - these `MonetizationSettings` are common (applied to all `User`s);
    - the authenticated `MyUser` is not owner of these
      `MonetizationSettings`.

    ## Versioning

    Returned `MonetizationSettings.user` field is versioned by its own
    `UserVersion` and not by the `MonetizationSettingsVersion` of these
    `MonetizationSettings`.
  """
  user: User
  "`DateTime` when these `MonetizationSettings` were created."
  createdAt: DateTime!
  """
    `Version` of these `MonetizationSettings`' state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: MonetizationSettingsVersion!
}

"""
  [Connection] with `MonetizationSettings`.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type MonetizationSettingsConnection {
  """
    List of `MonetizationSettings` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [MonetizationSettingsEdge!]!
  """
    List of `MonetizationSettings` in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [MonetizationSettings!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  "Total count of `MonetizationSettings` in this list."
  totalCount: Int!
  """
    Version of this `MonetizationSettings` list.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: MonetizationSettingsVersion!
}

"Monetization settings of `Donation`s."
type MonetizationSettingsDonation {
  "Indicator whether the `Vendor` accepts `Donation`s or not."
  enabled: Boolean!
  "Minimal `Price` of `Donation`s allowed in the `Chat` with the `Vendor`."
  min: Price!
}

"""
  [Edge] with `MonetizationSettings`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type MonetizationSettingsEdge {
  """
    `MonetizationSettings` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: MonetizationSettings!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: MonetizationSettingsCursor!
}

"""
  `MonetizationSettingsEvent`s along with the corresponding
  `MonetizationSettingsVersion`.
"""
type MonetizationSettingsEventsVersioned {
  "`MonetizationSettingsEvent`s themselves."
  events: [MonetizationSettingsEvent!]!
  """
    Version of the `MonetizationSettings`' state updated by these
    `MonetizationSettingsEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: MonetizationSettingsVersion!
  """
    Version of the `MonetizationSettingsList`'s state updated by these
    `MonetizationSettingsEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  listVer: MonetizationSettingsVersion!
}

"List of `MonetizationSettings`."
type MonetizationSettingsList {
  """
    Returns `MonetizationSettings` set by the `User` specified via
    `MonetizationSettingsFilter.userId` of this `MonetizationSettingsList`
    for the authenticated `MyUser`.

    If the `User` specified via `MonetizationSettingsFilter.userId` is the
    authenticated `MyUser`, then effectively returns common
    `MonetizationSettings` of the authenticated `MyUser` (applied to all
    `User`s).

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when no `User` specified via
    `MonetizationSettingsFilter.userId` exists.
  """
  monetizationSettings: MonetizationSettings
  """
    Returns `MonetizationSettings` set by the authenticated `MyUser`, and
    filtered by the `MonetizationSettingsFilter` of this
    `MonetizationSettingsList`.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `MonetizationSettings` are sorted primarily by their
    `MonetizationSettings.createdAt` field, and secondary by IDs of the
    `User`s they are specified for, in descending order.
  """
  myMonetizationSettings("Arguments for pagination over returned `MonetizationSettings`." pagination: MonetizationSettingsPagination): MonetizationSettingsConnection!
}

type Mutation {
  """
    Creates a new `MyUser` having only `id` and unique `num` fields, along
    with a `Session` for him (valid for the returned expiration).

    `AccessToken` of the created `Session` may be prolonged via
    `Mutation.refreshSession`.

    Once the created `Session` expires and cannot be refreshed, the created
    `MyUser` looses its access, if he doesn't provide the `password`
    argument now or sets it later via `Mutation.updateUserPassword` within
    that period of time.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    None.

    ## Non-idempotent

    Each time creates a new unique `MyUser` and a new `Session`.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  createUser("Optional login to create the `MyUser` with." login: UserLogin, "Optional password to create the `MyUser` with." password: UserPassword, "Optional affiliation of the created `MyUser`." affiliate: UserAffiliationInput): CreateUserResult!
  """
    Adds a new `email` address for the authenticated `MyUser`.

    Sets the provided `email` address as the `MyUser.emails.unconfirmed`
    field and sends to this address an email message with a new
    `ConfirmationCode`. If the sent `ConfirmationCode` is provided as the
    `confirmation` argument, then moves the provided `email` address to the
    `MyUser.emails.confirmed` field, unlocking the related capabilities.

    To resend a new `ConfirmationCode` to the provided `email` address, just
    call this mutation again with the same arguments, or use the
    `Mutation.createConfirmationCode` with this `email` address provided.

    `MyUser` can have maximum one `MyUser.emails.unconfirmed` address at the
    same time.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Localization

    You may provide the preferred locale via the
    [`Accept-Language` HTTP header][3], which will localize the sent email
    message with a new `ConfirmationCode` using the [best match][4] of the
    supported locales.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserEmailAdded`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the provided `email`
    address is already present in a `MyUser.emails` field (either in
    `confirmed` or `unconfirmed` sub-field).

    However, always sends a new `ConfirmationCode` to the provided `email`
    address if the `confirmation` argument is not provided, and always uses
    the provided `ConfirmationCode` otherwise, disallowing to use it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
    [3]: https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Language
    [4]: https://www.ietf.org/rfc/rfc4647.html#section-3.3
  """
  addUserEmail("Email address to add to `MyUser.emails`." email: UserEmail!, """
    Single-use `ConfirmationCode` confirming ownership of the added `email` address for the authenticated `MyUser`.

    If absent or `null` then the `email` address is added as an `unconfirmed` and a new `ConfirmationCode` is sent to this address.
  """ confirmation: ConfirmationCode): AddUserEmailResult
  """
    Adds a new `phone` number for the authenticated `MyUser`.

    Sets the provided `phone` number as the `MyUser.phones.unconfirmed`
    field and sends to this number an SMS with a new `ConfirmationCode`.
    If the sent `ConfirmationCode` is provided as the `confirmation`
    argument, then moves the provided `phone` number to the
    `MyUser.phones.confirmed` field, unlocking the related capabilities.

    To resend a new `ConfirmationCode` to the provided `phone` number, just
    call this mutation again with the same arguments, or use the
    `Mutation.createConfirmationCode` with this `phone` number provided.

    `MyUser` can have maximum one `MyUser.phones.unconfirmed` number at the
    same time.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Localization

    You may provide the preferred locale via the
    [`Accept-Language` HTTP header][3], which will localize the sent SMS
    with a new `ConfirmationCode` using the [best match][4] of the supported
    locales.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserPhoneAdded`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the provided `phone`
    number is already present in a `MyUser.phones` field (either in
    `confirmed` or `unconfirmed` sub-field).

    However, always sends a new `ConfirmationCode` to the provided `phone`
    number if the `confirmation` argument is not provided, and always uses
    the provided `ConfirmationCode` otherwise, disallowing to use it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
    [3]: https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Language
    [4]: https://www.ietf.org/rfc/rfc4647.html#section-3.3
  """
  addUserPhone("Phone number to add to `MyUser.phones`." phone: UserPhone!, """
    Single-use `ConfirmationCode` confirming ownership of the added `phone` number for the authenticated `MyUser`.

    If absent or `null` then the `phone` number is added as an `unconfirmed` and a new `ConfirmationCode` is sent to this number.
  """ confirmation: ConfirmationCode): AddUserPhoneResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Removes the provided `email` address from the `MyUser.emails` field of
    the authenticated `MyUser`.

    If the provided `email` address is still `unconfirmed`, then the
    `confirmation` argument is not required. Otherwise, it's mandatory to
    authenticate this operation additionally by providing the `confirmation`
    argument.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserEmailRemoved`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` doesn't have the provided `email` in his `MyUser.emails`
    already.

    However, always uses the provided `ConfirmationCode`, disallowing to use
    it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  removeUserEmail("`UserEmail` address to remove from `MyUser.emails`." email: UserEmail!, """
    `MyUserCredentials` confirming and authenticating this operation by the authority of the `MyUser`.

    May be absent or `null` if the removed `UserEmail` address is still `unconfirmed`.
  """ confirmation: MyUserCredentials): RemoveUserEmailResult
  """
    Removes the provided `phone` number from the `MyUser.phones` field of
    the authenticated `MyUser`.

    If the provided `phone` number is still `unconfirmed`, then the
    `confirmation` argument is not required. Otherwise, it's mandatory to
    authenticate this operation additionally by providing the `confirmation`
    argument.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserPhoneRemoved`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` doesn't have the provided `phone` in his `MyUser.phones`
    already.

    However, always uses the provided `ConfirmationCode`, disallowing to use
    it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  removeUserPhone("`UserPhone` number to remove from `MyUser.phones`." phone: UserPhone!, """
    `MyUserCredentials` confirming and authenticating this operation by the authority of the `MyUser`.

    May be absent or `null` if the removed `UserPhone` number is still `unconfirmed`.
  """ confirmation: MyUserCredentials): RemoveUserPhoneResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Updates or resets the `MyUser.login` field of the authenticated
    `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserLoginUpdated` (if `login` argument is specified);
    - `EventUserLoginRemoved` (if `login` argument is absent or `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` uses the provided `login` already.
  """
  updateUserLogin("""
    Login to update `MyUser` with.

    If absent or `null` then the `MyUser.login` field will be reset.
  """ login: UserLogin): UpdateUserLoginResult
  """
    Updates or resets the `MyUser.name` field of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserNameUpdated` (if `name` argument is specified);
    - `EventUserNameRemoved` (if `name` argument is absent or `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` uses the provided `name` already.
  """
  updateUserName("""
    Name to update `MyUser` with.

    If absent or `null` then the `MyUser.name` field will be reset.
  """ name: UserName): MyUserEventsVersioned
  """
    Updates or resets the `MyUser.bio` field of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserBioUpdated` (if the `bio` argument is specified);
    - `EventUserBioRemoved` (if the `bio` argument is absent or `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` uses the provided `bio` already.
  """
  updateUserBio("""
    Bio to update the authenticated `MyUser` with.

    If absent or `null` then the `MyUser.bio` field will be reset.
  """ bio: UserBio): MyUserEventsVersioned
  """
    Updates or resets password of the authenticated `MyUser` or the one
    identified by the provided `MyUserIdentifier`.

    If the `MyUser` has no password yet, then the `confirmation` argument is
    not required. Otherwise, it's mandatory to authenticate this operation
    additionally by providing the `confirmation` argument.

    This mutation can be used for changing the `MyUser`'s password,
    recovering it, or removing it. Use the `Mutation.createConfirmationCode`
    to create a new `ConfirmationCode` for authenticating the password
    recovery, and provide it as the `confirmation` argument along with the
    `ident` argument to this mutation.

    If the concrete `MyUserIdentifier.email` address or
    `MyUserIdentifier.phone` number is provided, then the provided
    `ConfirmationCode` is validated against it exclusively, meaning that
    providing `ConfirmationCode`s sent to any other
    `MyUser.emails.confirmed` or `MyUser.phones.confirmed` is invalid.
    Otherwise, if a `MyUserIdentifier.num` or a `MyUserIdentifier.login` is
    provided, then a `ConfirmationCode` sent to any of
    `MyUser.emails.confirmed` or `MyUser.phones.confirmed` is suitable.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    Mandatory if the `ident` argument is absent or `null`.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserPasswordUpdated` (always, if the `password` argument is
      specified).
    - `EventUserPasswordRemoved` (idempotently, if the `password` argument
      is absent or `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` has no password already, when the `password` argument is absent
    or `null`.

    ## Non-idempotent

    Each time renews the password (recalculates hash) even if it's the same
    one, when the `password` argument is specified.

    Additionally, always uses the provided `ConfirmationCode`, disallowing
    to use it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  updateUserPassword("""
    `MyUserIdentifier` of the `MyUser` to reset password of.

    Exactly one should be specified.

    Mandatory when there is no authentication.
  """ ident: MyUserIdentifier, """
    New password to update the `MyUser` with.

    If absent or `null` then the current password will be removed.
  """ password: UserPassword, """
    `MyUserCredentials` confirming and authenticating this operation by the authority of the `MyUser`.

    May be absent or `null` if the `MyUser` has no password yet.
  """ confirmation: MyUserCredentials): UpdateUserPasswordResult
  """
    Updates or resets the `MyUser.avatar` field with the provided image
    file.

    HTTP request for this mutation must be
    `Content-Type: multipart/form-data` containing the uploaded file and the
    `file` argument itself must be `null`, otherwise this mutation will
    fail.

    See [GraphQL multipart request specification][1] for details.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserAvatarUpdated` (if image `file` is provided);
    - `EventUserAvatarRemoved` (if image `file` is not provided).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` uses the specified image `file` already as his `avatar` with
    the same `crop` area.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  updateUserAvatar("""
    File to use as a `UserAvatar`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """ file: Upload, """
    Optional area to crop the uploaded image.

    Only makes sense if the image file is provided.
  """ crop: CropAreaInput): UpdateUserAvatarResult
  """
    Updates or resets the `MyUser.callCover` field with the provided image
    file.

    HTTP request for this mutation must be
    `Content-Type: multipart/form-data` containing the uploaded file and the
    `file` argument itself must be `null`, otherwise this mutation will
    fail.

    See [GraphQL multipart request specification][1] for details.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserCallCoverUpdated` (if image file is provided);
    - `EventUserCallCoverRemoved` (if image file is not provided).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` uses the specified image `file` already as his `callCover` with
    the same `crop` area.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  updateUserCallCover("""
    File to use as a `UserCallCover`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """ file: Upload, """
    Optional area to crop the uploaded image.

    Only makes sense if the image file is provided.
  """ crop: CropAreaInput): UpdateUserCallCoverResult
  """
    Mutes or unmutes all the `Chat`s of the authenticated `MyUser`.
    Overrides any already existing mute even if it's longer.

    Muted `MyUser` implies that all his `Chat`s events don't produce sounds
    and notifications on a client side. This, however, has nothing to do
    with a server and is the responsibility to be satisfied by a client
    side. Server side may try to optimize this in some cases (like omit
    sending notifications), but a client side should not rely on any such
    behaviour and should implement best-effort muting by itself.

    Note, that `Mutation.toggleMyUserMute` doesn't correlate with
    `Mutation.toggleChatMute`. Unmuted `Chat` of muted `MyUser` should not
    produce any sounds, and so, muted `Chat` of unmuted `MyUser` should not
    produce any sounds too.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserMuted` (if `mute` argument is not `null`);
    - `EventUserUnmuted` (if `mute` argument is `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` is muted already `until` the specified `DateTime` (or unmuted).
  """
  toggleMyUserMute("""
    Muting options for the authenticated `MyUser`.

    `null` means unmuting.
  """ mute: Muting): ToggleMyUserMuteResult
  """
    Updates the `MyUser.presence` field of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserPresenceUpdated`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` has the provided `presence` value already.
  """
  updateUserPresence("`UserPresence` to update `MyUser` with." presence: UserPresence!): MyUserEventsVersioned
  """
    Updates or resets the `MyUser.status` field of the authenticated
    `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserStatusUpdated` (if `text` argument is specified);
    - `EventUserStatusRemoved` (if `text` argument is absent or `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` has the provided `text` as his `status` value already.
  """
  updateUserStatus("""
    `UserTextStatus` to update `MyUser` with.

    If absent or `null` then the `MyUser.status` field will be reset.
  """ text: UserTextStatus): MyUserEventsVersioned
  """
    Deletes the authenticated `MyUser` completely.

    **This action cannot be reverted.**

    Also deletes all the `Session`s of the authenticated `MyUser`.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `MyUserEvent` may be produced on success:
    - `EventUserDeleted`.

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser` has been deleted already.

    However, always uses the provided `ConfirmationCode`, disallowing to use
    it again.

    Also, beware that short after the deletion all the `Session`s of the
    authenticated `MyUser` will be deleted.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  deleteMyUser("""
    `MyUserCredentials` confirming and authenticating this operation by the authority of the `MyUser`.

    May be absent or `null` if the deleted `MyUser` doesn't have its `UserPassword` set or any means to send a `ConfirmationCode` to.
  """ confirmation: MyUserCredentials): DeleteMyUserResult
  """
    Generates and sends a new single-use `ConfirmationCode` for the `MyUser`
    identified by the provided `MyUserIdentifier`.

    If the concrete `MyUserIdentifier.email` address or
    `MyUserIdentifier.phone` number is provided, then sends the generated
    `ConfirmationCode` only there. Otherwise, if a `MyUserIdentifier.num` or
    a `MyUserIdentifier.login` is provided, then sends the generated
    `ConfirmationCode`s to all the possessed `MyUser.emails.confirmed` and
    `MyUser.phones.confirmed`.

    If the `MyUser` has no password yet, then this mutation still may be
    used for recovering his sign-in capability.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Localization

    You may provide the preferred locale via the
    [`Accept-Language` HTTP header][3], which will localize the sent email
    messages (or SMS) with the generated `ConfirmationCode` using the
    [best match][4] of the supported locales.

    ## Authentication

    None.

    ## Result

    Always returns `true` on success.

    ## Non-idempotent

    Each time generates and sends a new unique `ConfirmationCode`.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
    [3]: https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Language
    [4]: https://www.ietf.org/rfc/rfc4647.html#section-3.3
  """
  createConfirmationCode("""
    `MyUserIdentifier` of the `MyUser` to generate and send a new `ConfirmationCode` for.

    Exactly one should be specified.
  """ ident: MyUserIdentifier!): Boolean!
  """
    Validates the provided `ConfirmationCode` for the `MyUser` identified by
    the provided `MyUserIdentifier` without using it.

    If the concrete `MyUserIdentifier.email` address or
    `MyUserIdentifier.phone` number is provided, then the provided
    `ConfirmationCode` is validated against it exclusively, meaning that
    providing `ConfirmationCode`s sent to any other
    `MyUser.emails.confirmed` or `MyUser.phones.confirmed` is invalid.
    Otherwise, if a `MyUserIdentifier.num` or a `MyUserIdentifier.login` is
    provided, then a `ConfirmationCode` sent to any of
    `MyUser.emails.confirmed` or `MyUser.phones.confirmed` is suitable.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    None.

    ## Result

    Always returns `null` on success.

    ## Idempotent

    `ConfirmationCode` can be validated unlimited number of times (for now).

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  validateConfirmationCode("""
    `MyUserIdentifier` of the `MyUser` to validate the provided `ConfirmationCode` for.

    Exactly one should be specified.
  """ ident: MyUserIdentifier!, "`ConfirmationCode` to be validated." code: ConfirmationCode!): ValidateConfirmationCodeErrorCode
  """
    Updates `MonetizationSettings` of the authenticated `MyUser`.

    If the `userId` argument is specified, then `MonetizationSettings` will
    be updated individually for that `User`. Otherwise, common
    `MonetizationSettings` are updated, affecting all `User`s. Naturally,
    individual `MonetizationSettings` take precedence over common
    `MonetizationSettings`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MonetizationSettingsEvent`s may be produced on
    success:
    - `EventMonetizationSettingsDonationDeleted`;
    - `EventMonetizationSettingsDonationMinPriceUpdated`;
    - `EventMonetizationSettingsDonationToggled`.

    ## Idempotent

    Succeeds as no-op (and returns no `MonetizationSettingsEvent`) if the
    specified `MonetizationSettings`' fields are set already to the provided
    values.
  """
  updateMonetizationSettings("""
    Optional ID of the `User` to update individual `MonetizationSettings` for.

    If absent or `null` then common `MonetizationSettings` will be updated (affecting all `User`s).
  """ userId: UserId, "`MonetizationSettings` to be set." settings: MonetizationSettingsInput!): UpdateMonetizationSettingsResult
  """
    Creates a new `Session` for the `MyUser` identified by the provided
    `MyUserIdentifier`.

    Represents a sign-in action.

    `AccessToken` of the created `Session` may be prolonged via
    `Mutation.refreshSession`.

    If the provided `MyUserIdentifier.email` address (or
    `MyUserIdentifier.phone` number) is not occupied by any existing
    `MyUser` yet, then, along with provided `MyUserCredentials.code`,
    creates a new `MyUser` with the authenticated `UserEmail` address (or
    `UserPhone` number) being assigned to him. This means, that there is no
    difference between sing-in and sign-up actions in this mutation when a
    `UserEmail` address (or `UserPhone` number) is used in combination with
    a `ConfirmationCode`.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    None.

    ## Non-idempotent

    Each time creates a new `Session`.

    Additionally, always uses the provided `ConfirmationCode`, disallowing
    to use it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  createSession("""
    `MyUserIdentifier` of the `MyUser` to create the `Session` for.

    Exactly one should be specified.
  """ ident: MyUserIdentifier!, "`MyUserCredentials` to authenticate with." credentials: MyUserCredentials!, "Optional affiliation of the created `MyUser`, if he will be created." affiliate: UserAffiliationInput): CreateSessionResult!
  """
    Refreshes a `Session` of the `MyUser` identified by the provided
    `RefreshTokenSecret`.

    Invalidates the provided `RefreshTokenSecret` and returns a new one
    for the same `RefreshToken`, which should be used instead.

    The refreshed `AccessToken` has its own expiration, so to refresh it
    again, use this mutation with the new returned `RefreshTokenSecret`
    (omit using old ones).

    `RefreshToken` doesn't change at all, only the new `RefreshTokenSecret`
    is generated for it, which means its expiration is not prolonged
    comparing to the `AccessToken`. Once the `RefreshToken` is expired, the
    `Session` cannot be either refreshed or accessed anymore. To create a
    new `Session` use the `Mutation.createSession`.

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    For delivery guarantees, the client may provide self-generated
    `newSecrets`, which can be used for idempotent processing. Each time
    the client receives the `CreateSessionOk` response, it should
    re-generate its secrets.

    ## Authentication

    None.

    ## Idempotent

    If the same `new` secrets are provided twice, then does nothing,
    returning the `CreateSessionOk` with the last refreshed `Session` and
    its tokens.

    ## Non-idempotent

    Non-idempotent in case no `new` secrets are provided, or they are
    different from the previous one.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  refreshSession("`RefreshTokenSecret` for mutation authentication and `MyUser` identification." secret: RefreshTokenSecret!, """
    New secrets to refresh the `Session` with.

    Could be used as idempotency key.

    If absent or `null`, then secrets will be auto-generated.
  """ new: RefreshSessionSecretsInput): RefreshSessionResult!
  """
    Destroys the specified `Session` of the authenticated `MyUser`, or the
    current one (if the `id` argument is not provided).

    If the `id` argument is provided, then the `confirmation` argument is
    mandatory, unless the authenticated `MyUser` has no means for it (has
    neither `MyUser.hasPassword`, nor
    `MyUser.emails.confirmed`/`MyUser.phones.confirmed`).

    [`User-Agent` HTTP header][0] must be specified for this mutation and
    meet the `UserAgent` scalar format.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `SessionEvent` may be produced on success:
    - `EventSessionDeleted`.

    ## Idempotent

    Succeeds as no-op (and returns no `SessionEvent`) if the specified
    `Session` has been deleted already.

    However, always uses the provided `ConfirmationCode`, disallowing to use
    it again.

    [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  deleteSession("""
    ID of the `Session` to destroy.

    Only makes sense if the `confirmation` argument is provided.
  """ id: SessionId, """
    `MyUserCredentials` confirming and authenticating this operation by the authority of the `MyUser`.

    Only makes sense if the `id` argument is provided.
  """ confirmation: MyUserCredentials): DeleteSessionResult
  """
    Creates a `Chat`-monolog for the authenticated `MyUser`.

    There can be only one `Chat`-monolog for the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Idempotent

    Succeeds as no-op if the `Chat`-monolog for the authenticated `MyUser`
    exists already, and returns it.
  """
  createMonologChat(name: ChatName, "Indicates whether the created `Chat`-monolog should be hidden." isHidden: Boolean): Chat!
  """
    Creates a `Chat`-dialog with the provided responder `User` for the
    authenticated `MyUser`.

    There can be only one `Chat`-dialog between two `User`s.

    ## Authentication

    Mandatory.

    ## Idempotent

    Succeeds as no-op if a `Chat` with the given responder `User` exists
    already, and returns this `Chat`.
  """
  createDialogChat("ID of the responder `User` to create a `Chat`-dialog with." responderId: UserId!): CreateDialogChatResult!
  """
    Creates a `Chat`-group with the provided `User`s as members and the
    authenticated `MyUser`.

    There can be many `Chat`-group between the same `User`s.

    ## Authentication

    Mandatory.

    ## Non-idempotent

    Each time creates a new `Chat`-group.
  """
  createGroupChat("IDs of the `User`s to create a `Chat`-group with." memberIds: [UserId!]!, "Optional name to assign to the created `Chat`-group." name: ChatName): CreateGroupChatResult!
  """
    Marks the specified `Chat` as favorited for the authenticated `MyUser`
    and sets its position in the favorites list.

    To move the `Chat` to a concrete position in a favorites list, provide
    the average value of two other `Chat`s positions surrounding it.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatFavorited`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already favorited at the same position.
  """
  favoriteChat("ID of the `Chat` to mark as favorited." id: ChatId!, "Position of the `Chat` in a favorites list." pos: ChatFavoritePosition!): FavoriteChatResult
  """
    Removes the specified `Chat` from the favorites list of the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatUnfavorited`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is not in the favorites list already.
  """
  unfavoriteChat("ID of the `Chat` to remove from the favorites list." id: ChatId!): UnfavoriteChatResult
  """
    Adds the specified `User` to the specified `Chat`-group by authority of
    the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionMemberAdded`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
    is a member of the specified `Chat` already.
  """
  addChatMember("ID of the `User` to become a member of the `Chat`-group." userId: UserId!, "ID of the `Chat`-group to add the `User` to." chatId: ChatId!): AddChatMemberResult
  """
    Removes the specified `User` from the specified `Chat`-group by
    authority of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`s may be produced on success:
    - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionMemberRemoved`);
    - `EventChatCallDeclined` (if the authenticated `MyUser` removed himself
      from the group's ongoing `ChatCall`, not answered by him yet);
    - `EventChatCallMemberUndialed` (if the removed `User` was dialed, but
      didn't answer the group's ongoing `ChatCall`);
    - `EventChatCallMemberLeft` (if the removed `User` participated in the
      group's ongoing `ChatCall`);
    - `EventChatCallFinished` (if the removed `User` was the last member of
      the group's ongoing `ChatCall`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
    is not a member of the specified `Chat` already.
  """
  removeChatMember("ID of the `User` to be removed from the `Chat`-group." userId: UserId!, "ID of the `Chat`-group to remove the `User` from." chatId: ChatId!): RemoveChatMemberResult
  """
    Updates the `Chat.avatar` field with the provided image, or resets it to
    `null`, by authority of the authenticated `MyUser`.

    HTTP request for this mutation must be
    `Content-Type: multipart/form-data` containing the uploaded file and the
    `file` argument must be `null`, otherwise this mutation will fail.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionAvatarUpdated`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    uses the specified `file` already as an `avatar` with the same `crop`
    area.
  """
  updateChatAvatar("ID of the `Chat` to update `avatar` of." chatId: ChatId!, """
    File to use as a `ChatAvatar`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """ file: Upload, """
    Optional area to crop the provided image file.

    Only makes sense if the image file is provided.
  """ crop: CropAreaInput): UpdateChatAvatarResult
  """
    Renames the specified `Chat` by authority of the authenticated `MyUser`.

    `Chat`-dialogs cannot be named or renamed.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionNameUpdated`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    has the specified `name` already.
  """
  renameChat("ID of the `Chat` to rename." id: ChatId!, """
    `ChatName` to rename the `Chat` with.

    `null` removes the current `ChatName`.
  """ name: ChatName): RenameChatResult
  """
    Clears an existing `Chat` (hides all its `ChatItem`s) for the
    authenticated `MyUser` until the specified `ChatItem` inclusively.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatCleared`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already cleared until the specified `ChatItem`.
  """
  clearChat("ID of the `Chat` to be cleared." id: ChatId!, "ID of the `ChatItem` to clear the `Chat` until (inclusively)." untilId: ChatItemId!): ClearChatResult
  """
    Marks the specified `Chat` as hidden for the authenticated `MyUser`.

    Hidden `Chat` is excluded from `Query.recentChats`, but preserves all
    its content. Once a new `ChatItem` posted in a `Chat` it becomes visible
    again, and so included into `Query.recentChats` as well.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatHidden`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already hidden by the authenticated `MyUser`.
  """
  hideChat("ID of the `Chat` to be hidden." id: ChatId!): HideChatResult
  """
    Mutes or unmutes the specified `Chat` for the authenticated `MyUser`.
    Overrides an existing mute even if it's longer.

    Muted `Chat` implies that its events don't produce sounds and
    notifications on a client side. This, however, has nothing to do with
    a server and is the responsibility to be satisfied by a client side.
    Server side may try to optimize this in some cases (like omit sending
    notifications), but a client side should not rely on any such behaviour
    and should implement best-effort muting by itself.

    Note, that `Mutation.toggleChatMute` doesn't correlate with
    `Mutation.toggleMyUserMute`. Muted `Chat` of unmuted `MyUser` should not
    produce any sounds, and so, unmuted `Chat` of muted `MyUser` should not
    produce any sounds too.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `ChatEvent`s may be produced on success:
    - `EventChatMuted` (if `until` argument is not `null`);
    - `EventChatUnmuted` (if `until` argument is `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already muted `until` the specified `DateTime` (or unmuted) for the
    authenticated `MyUser`.
  """
  toggleChatMute("ID of the `Chat` to be muted." id: ChatId!, """
    Muting options for the `Chat`.

    `null` means unmuting.
  """ mute: Muting): ToggleChatMuteResult
  """
    Archives or unarchives the specified `Chat` for the authenticated
    `MyUser`.

    Archived `Chat`s are excluded from the `Query.recentChats` when its
    `with.archived` argument is set to `false`.

    Once a new `ChatItem` is posted in an archived unmuted `Chat`, it
    automatically becomes unarchived again, despite no `EventChatUnarchived`
    is emitted (which means manual unarchivation only). Muted `Chat`s,
    however, are not unarchived automatically once new `ChatItem`s are
    posted.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `ChatEvent`s may be produced on success:
    - `EventChatArchived` (if `archive` argument is `true`);
    - `EventChatUnarchived` (if `archive` argument is `false`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already archived (or unarchived) for the authenticated `MyUser`.
  """
  toggleChatArchivation("ID of the `Chat` to be archived." id: ChatId!, "Indicator whether the `Chat` should be archived." archive: Boolean!): ToggleChatArchivationResult
  """
    Posts a new `ChatMessage` to the specified `Chat` by the authenticated
    `MyUser`.

    For the posted `ChatMessage` to be meaningful, at least one of the
    `text` or `attachments` arguments must be specified and non-empty.

    To attach some `Attachment`s to the posted `Message`, first, they should
    be uploaded with `Mutation.uploadAttachment`, and only then, the
    returned `Attachment.id`s may be used as the `attachments` argument of
    this mutation.

    `repliesTo` argument should be specified if the posted `ChatMessage` is
    going to be a reply to some other `ChatItem`s.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemPosted`.

    ## Non-idempotent

    Each time creates a new unique `ChatMessage`, producing a new
    `ChatEvent`.
  """
  postChatMessage("ID of the `Chat` to post a new `ChatMessage` in." chatId: ChatId!, "Optional text of the posted `ChatMessage`. If not specified then `attachments` argument must be specified and non-empty." text: ChatMessageText, "Optional IDs of `Attachment`s to be attached to the posted `ChatMessage`. If not specified or empty then `text` argument must be specified." attachments: [AttachmentId!], "IDs of the `ChatItem`s that the posted `ChatMessage` is replying to. The replied `ChatItem`s may belong to the current `Chat` only." repliesTo: [ChatItemId!]!, """
    Optional `Donation` to be attached to the posted `ChatMessage`.

    `Donation`s are allowed in dialog `Chat`s only.
  """ donation: DonationInput): PostChatMessageResult!
  """
    Updates the `WelcomeMessage` of the authenticated `MyUser`.

    For the `WelcomeMessage` to be meaningful, at least one of the
    `content.text` or `content.attachments` arguments must be specified and
    non-empty.

    To attach some `Attachment`s to the `WelcomeMessage`, first, they should
    be uploaded with `Mutation.uploadAttachment`, and only then, the
    returned `Attachment.id`s may be used as the `content.attachments`
    argument of this mutation.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `MyUserEvent`s may be produced on success:
    - `EventUserWelcomeMessageUpdated` (if `content` argument is specified);
    - `EventUserWelcomeMessageDeleted` (if `content` argument is absent or
      `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
    `MyUser`'s `WelcomeMessage` already has the specified `content.text` and
    `content.attachments` in the same order.
  """
  updateWelcomeMessage("""
    Content to update the `WelcomeMessage` with.

    If absent or `null` then the `MyUser.welcomeMessage` field will be reset.
  """ content: WelcomeMessageInput): UpdateWelcomeMessageResult
  """
    Updates the current `PromoShare` of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `PromoShareEvent`s may be produced on success:
    - `EventPromoShareUpdated` (if `percentage` argument is specified);
    - `EventPromoShareRemoved` (if `percentage` argument is absent or
      `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `PromoShareEvent`) if the
    authenticated `MyUser`'s current `PromoShare` already has the specified
    `percentage` being set.
  """
  updatePromoShare("""
    `Percentage` to set the `MyUser.promo.share.current` field to.

    If absent or `null` then the `MyUser.promo.share.current` field will be reset.
  """ percentage: Percentage): PromoShareEventsVersioned
  """
    Marks the specified `Chat` as read for the authenticated `MyUser` until
    the specified `ChatItem` inclusively.

    There is no notion of a single `ChatItem` being read or not separately
    in a `Chat`. Only a whole `Chat` as a sequence of `ChatItem`s can be
    read until some its position (concrete `ChatItem`). So, any `ChatItem`
    may be considered as read (or not) by comparing its `ChatItem.at` field
    with the `Chat.lastReads.at` field of the authenticated `MyUser`: if
    it's below (less or equal) then the `ChatItem` is read, otherwise it's
    unread.

    This mutation should be called whenever the authenticated `MyUser` reads
    new `ChatItem`s appeared in the `Chat`'s UI and directly influences the
    `Chat.unreadCount` value.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatEvent`s may be produced on success:
    - `EventChatRead`;
    - `EventChatDelivered` (if some of read `ChatItem`s were not delivered
       yet).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
    is already read by the authenticated `MyUser` until the specified
    `ChatItem`.
  """
  readChat("ID of the `Chat` to be read." id: ChatId!, "ID of the `ChatItem` to read the `Chat` until (inclusively)." untilId: ChatItemId!): ReadChatResult
  """
    Creates a new `Attachment` linked to the authenticated `MyUser` for a
    later use in `Mutation.postChatMessage`.

    HTTP request for this mutation must be
    `Content-Type: multipart/form-data` containing the uploaded file and the
    `attachment` argument must be `null`, otherwise this mutation will fail.

    See [GraphQL multipart request specification][1] for details.

    ## Authentication

    Mandatory.

    ## Non-idempotent

    Each time creates a new unique `Attachment`.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  uploadAttachment("""
    File to be uploaded as an `Attachment`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real attachment data must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """ file: Upload): UploadAttachmentResult!
  """
    Deletes the specified `ChatMessage` posted by the authenticated
    `MyUser`.

    `ChatMessage` is allowed to be deleted only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but:
        - doesn't contain any paid content;
        - and 5 minutes haven't passed since its posting time
          (`ChatMessage.at` field).

    Once deleted, `ChatMessage` is not visible for anyone in the `Chat`.

    If this mutation returns `UNEDITABLE` (or `QUOTED`) error, use the
    `Mutation.hideChatItem` to "remove" the `ChatMessage` for the
    authenticated `MyUser` only.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemDeleted`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified
    `ChatMessage` is deleted already.
  """
  deleteChatMessage("ID of the `ChatMessage` to delete." id: ChatItemId!): DeleteChatMessageResult
  """
    Edits a `ChatMessage` by the authenticated `MyUser` with the provided
    `text`/`attachments`/`repliesTo` (at least one of three must be
    specified).

    `ChatMessage` is allowed to be edited only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but:
        - doesn't contain any paid content;
        - and 5 minutes haven't passed since its posting time
          (`ChatMessage.at` field).

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemEdited`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`s) if the specified
    `ChatMessage` already has the specified `text`, `attachments` and
    `replies_to` in the same order.
  """
  editChatMessage("ID of the `ChatMessage` to edit." id: ChatItemId!, """
    New text to assign to the `ChatMessage`.

    - If `null`, then the previous `ChatMessageText` will remain unchanged.
    - If `ChatMessageTextInput.new` is empty, then the previous `ChatMessageText` will be deleted.
    - Otherwise, `ChatMessageTextInput.new` will replace the previous `ChatMessageText`.

    `ChatMessageTextInput.new` can be `null` only if the resulting `ChatMessage` has at least one `Attachment`.

    Mandatory, if `attachments` and `repliesTo` arguments are missing.
  """ text: ChatMessageTextInput, """
    IDs of `Attachment`s to assign to the `ChatMessage`.

    - If `null`, then the previous `Attachment`s will remain unchanged.
    - If `ChatMessageAttachmentsInput.new` is empty, then the previous `ChatMessage`'s `Attachment`s will be deleted.
    - Otherwise, `ChatMessageAttachmentsInput.new` will replace the previous `Attachment`s.

    `ChatMessageAttachmentsInput.new` can be empty only if the resulting `ChatMessage` has a `ChatMessageText`.

    Mandatory, if `text` and `repliesTo` arguments are missing.
  """ attachments: ChatMessageAttachmentsInput, """
    IDs of the `ChatItem`s that the edited `ChatMessage` is replying to.

    - If `null`, then the previous `ChatItemQuote`s will remain unchanged.
    - If `ChatMessageRepliesInput.new` is empty, then the previous `ChatItemQuote`s will be deleted.
    - Otherwise, `ChatMessageRepliesInput.new` will replace the previous `ChatItemQuote`s.

    The replied `ChatItem`s may belong to the current `Chat` only.

    Mandatory, if `text` and `attachments` arguments are missing.
  """ repliesTo: ChatMessageRepliesInput): EditChatMessageResult
  """
    Hides the specified `ChatItem` for the authenticated `MyUser`.

    Hidden `ChatItem` is not visible only for the one who hid it, remaining
    visible for other `User`s.

    Use this mutation for "deleting" a `ChatItem` for the authenticated
    `MyUser` only in `Chat`'s UI in case the `Mutation.deleteChatMessage`
    (or `Mutation.deleteChatForward`) returns `UNEDITABLE` (or `QUOTED`)
    error.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemHidden`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified
    `ChatItem` is hidden by the authenticated `MyUser` already.
  """
  hideChatItem("ID of the `ChatItem` to hide." id: ChatItemId!): HideChatItemResult
  """
    Forwards `ChatItem`s to the specified `Chat` by the authenticated
    `MyUser`.

    Supported `ChatItem`s are `ChatMessage` and `ChatForward`.

    If the `message` argument is specified, then the forwarded `ChatItem`s
    will be followed with a posted `ChatMessage` containing the specified
    `message.text`, `message.attachments` and/or `message.donation`.

    When re-forwarding a `ChatForward`, the `ChatItemQuoteInput` arguments
    should be filled, as operation is performed on the inner `ChatMessage`.
    This allows to re-forward only part of the existing `ChatForward`.
    Re-forwarding a `ChatForward` is indistinguishable from just forwarding
    its inner `ChatMessage` (`ChatItemQuote` depth will still be just 1).

    The forwarded `ChatItem`s, along with the posted `ChatMessage` (if any),
    will have its `ChatItem.batchId` field set to the same non-`null` value,
    indicating that all these `ChatItem`s belong to the same forwarded
    batch.

    The maximum number of forwarded `ChatItem`s at once is 100.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`s may be produced on success:
    - `EventChatItemPosted` (`ChatForward` and optionally `ChatMessage`).

    ## Non-idempotent

    Each time posts a new `ChatForward`.
  """
  forwardChatItems("ID of the `Chat` to forward `ChatItem`s from." from: ChatId!, "ID of the `Chat` to forward `ChatItem`s into." to: ChatId!, "Quotes of the `ChatItem`s to be forwarded." items: [ChatItemQuoteInput!]!, """
    Optional `ChatMessage` to be posted along with the forwarded `ChatItem`s.

    If all fields are not specified or `null`, then no `ChatMessage` will be posted.
  """ message: ForwardChatItemsMessageInput): ForwardChatItemsResult!
  """
    Deletes the specified `ChatForward` posted by the authenticated
    `MyUser`.

    `ChatForward` is allowed to be deleted only if it:
    - hasn't been read by any other `ChatMember` yet;
    - has been read by other `ChatMember`, but 5 minutes haven't passed
      since its posting time (`ChatForward.at` field).

    Once deleted, `ChatForward` is not visible for anyone in the `Chat`.

    If this mutation returns `UNEDITABLE` (or `QUOTED`) error, use the
    `Mutation.hideChatItem` to "remove" the `ChatForward` for the
    authenticated `MyUser` only.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatItemDeleted`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified
    `ChatForward` is deleted already.
  """
  deleteChatForward("ID of the `ChatForward` to delete." id: ChatItemId!): DeleteChatForwardResult
  """
    Starts a new `ChatCall` in the specified `Chat` by the authenticated
    `MyUser`.

    Once this mutation succeeds the `EventChatCallStarted` is fired to all
    `ChatMember`s via `Subscription.chatEvents`, and it's required to use
    the `Subscription.chatCallEvents` (use the `StartChatCallOk.deviceId`
    returned by this mutation) for the authenticated `MyUser` to be able to
    react to all the `ChatCallEvent`s happening during the started
    `ChatCall`.

    Firing an `EventChatCallStarted` means that all the `ChatMember`s, at
    the moment of the `ChatCall` beginning, are dialed until the
    `EventChatCallAnswerTimeoutPassed` happens (with the `user` field set to
    `null`), or they take an explicit action about the `ChatCall` (accept it
    or decline it). Any `User`, joining the `Chat` after the
    `EventChatCallStarted`, is not dialed automatically, and if needed,
    should be explicitly dialed via `Mutation.redialChatCallMember`, and so,
    will have its own `EventChatCallAnswerTimeoutPassed` with the `user`
    field pointing to him.

    Firing an `EventChatCallAnswerTimeoutPassed` (with the `user` field set
    to `null`) means that all the dialed `ChatMember`s, not listed in the
    `ChatMembersDialedAll.answeredMembers` or the
    `ChatMembersDialedConcrete.concrete` fields, are not dialed anymore.

    ## Lifecycle

    The best-effort `ChatCall` lifecycle on a client side should look like:
    1. Initiate (start or join) a `ChatCall` via `Mutation.startChatCall` or
       `Mutation.joinChatCall`.
    2. Make a `Subscription.chatCallEvents` using the `deviceId` from the
       previous step.
    3. Once an `EventChatCallRoomReady` is emitted (or in case a
       `ChatCall.joinLink` is present already in the initial `ChatCall`
       returned by the `Subscription.chatCallEvents` from the previous
       step), establish a WebSocket connection with a media server using the
       emitted `joinLink`.
    4. Whenever an `EventChatCallRoomReady` is emitted again, reestablish a
       WebSocket connection with a media server forcefully, using the new
       emitted `joinLink`, even if the previous one is healthy.
    5. Finish or leave the ongoing `ChatCall` via executing
       `Mutation.leaveChatCall` first, then dropping the
       `Subscription.chatCallEvents`, and, finally, dropping the WebSocket
       connection with a media server. Do not try to reconnect if the media
       server drops it earlier, after execution of the
       `Mutation.leaveChatCall`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`s may be produced on success:
    - `EventChatItemPosted` (if no `ChatCall` exists);
    - `EventChatCallStarted` (if no `ChatCall` exists);
    - `EventChatCallMemberJoined` (if `ChatCall` exists already).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`s) if there is a `ChatCall`
    in this `Chat` already and the authenticated `MyUser` is a member of it.
    Joins it if the authenticated `MyUser` is not a member yet.
  """
  startChatCall("ID of the `Chat` to start a `ChatCall` in." chatId: ChatId!, """
    One-time `MyUser`'s secret credentials to authorize him with on a media server for this `ChatCall`.

    Use these credentials to establish a WebSocket connection with a media server after `EventChatCallRoomReady` is received via `Subscription.chatCallEvents`.

    Must be different per each `MyUser`'s device. Reuse these credentials for the same `ChatCall` (distinguish by `ChatCall.id`) and the same client device. Generate new credentials in any other case.
  """ creds: ChatCallCredentials!, "Indicates whether the `ChatCall` is intended to start with video." withVideo: Boolean = false): StartChatCallResult!
  """
    Moves an ongoing `ChatCall` in a `Chat`-dialog to a newly created
    `Chat`-group, optionally adding new members.

    The ongoing `ChatCall` should have its [Medea] room being created before
    moving, otherwise the `ChatCall` is not considered by this mutation as
    an ongoing one.

    Once this mutation succeeds the `EventChatCallMoved` is fired to all
    `Chat`-dialog members via `Subscription.chatCallEvents`, and it's
    required to establish a new `Subscription.chatCallEvents` using the
    emitted `EventChatCallMoved.newCallId`. Note, that the connection to the
    [Medea] room of the moved `ChatCall` should not be dropped, as it's
    simply moved to the returned `EventChatCallMoved.newCall`, ensuring
    smooth experience for the `ChatCall` members.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`s are produced on success:
    - `EventChatCallMoved`;
    - `EventChatCallFinished`.

    ## Non-idempotent

    Each time tries to move the ongoing `ChatCall` into a new unique
    `Chat`-group.

    [Medea]: https://github.com/instrumetisto/medea
  """
  transformDialogCallIntoGroupCall("ID of the `Chat`-dialog to move the ongoing `ChatCall` from." chatId: ChatId!, """
    ID of the `MyUser`'s device to initiate the ongoing `ChatCall` transformation from.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
  """ deviceId: ChatCallDeviceId!, "IDs of `User`s to create the new `Chat`-group with (in addition to the existing `Chat`-dialog members)." additionalMemberIds: [UserId!]!, "Optional name to assign to the new `Chat`-group." groupName: ChatName): TransformDialogCallIntoGroupCallResult
  """
    Declines the ongoing `ChatCall` in the specified `Chat` by the
    authenticated `MyUser`.

    Use this mutation when an `EventChatCallStarted` is received via
    `Subscription.chatEvents` and `MyUser` doesn't want to accept the
    `ChatCall`.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `ChatEvent`s may be produced on success:
    - `EventChatCallDeclined` (for `Chat`-groups);
    - `EventChatCallFinished` (for `Chat`-dialogs).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if there is no current
    `ChatCall`, or it is declined by the authenticated `MyUser` already.
  """
  declineChatCall("ID of the `Chat` to decline a `ChatCall` in." chatId: ChatId!): DeclineChatCallResult
  """
    Joins the ongoing `ChatCall` in the specified `Chat` by the
    authenticated `MyUser`.

    Use this mutation when an `EventChatCallStarted` is received via
    `Subscription.chatEvents` and `MyUser` wants to accept the `ChatCall`,
    or he wants to join an ongoing `ChatCall`.

    Once this mutation succeeds the `EventChatCallMemberJoined` is fired
    to all `ChatCall` members via `Subscription.chatCallEvents`, and it's
    required to use `Subscription.chatCallEvents` (use the
    `JoinChatCallOk.deviceId` returned by this mutation) for the
    authenticated `MyUser` to be able to react on all `ChatCallEvent`s
    happening during the accepted `ChatCall`.

    ## Lifecycle

    The best-effort `ChatCall` lifecycle on a client side should look like:
    1. Initiate (start or join) a `ChatCall` via `Mutation.startChatCall` or
       `Mutation.joinChatCall`.
    2. Make a `Subscription.chatCallEvents` using the `deviceId` from the
       previous step.
    3. Once an `EventChatCallRoomReady` is emitted (or in case a
       `ChatCall.joinLink` is present already in the initial `ChatCall`
       returned by the `Subscription.chatCallEvents` from the previous
       step), establish a WebSocket connection with a media server using the
       emitted `joinLink`.
    4. Whenever an `EventChatCallRoomReady` is emitted again, reestablish a
       WebSocket connection with a media server forcefully, using the new
       emitted `joinLink`, even if the previous one is healthy.
    5. Finish or leave the ongoing `ChatCall` via executing
       `Mutation.leaveChatCall` first, then dropping the
       `Subscription.chatCallEvents`, and, finally, dropping the WebSocket
       connection with a media server. Do not try to reconnect if the media
       server drops it earlier, after execution of the
       `Mutation.leaveChatCall`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatCallMemberJoined`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
    `MyUser` joined the current `ChatCall` already (is a member of it).
  """
  joinChatCall("ID of the `Chat` to accept a `ChatCall` in." chatId: ChatId!, """
    One-time `MyUser`'s secret credentials to authorize him with on a media server for this `ChatCall`.

    Use these credentials to establish a WebSocket connection with a media server after `EventChatCallRoomReady` is received via `Subscription.chatCallEvents`.

    Must be different per each `MyUser`'s device. Reuse these credentials for the same `ChatCall` (distinguish by `ChatCall.id`) and the same client device. Generate new credentials in any other case.
  """ creds: ChatCallCredentials!): JoinChatCallResult!
  """
    Leaves the ongoing `ChatCall` in the specified `Chat` by the
    authenticated `MyUser`.

    Use this mutation when the authenticated `MyUser` wants to finish or
    leave the `ChatCall` he's participating in at the moment.

    Once the authenticated `MyUser` lefts the ongoing `ChatCall` from all
    his devices, then the state of his hand specified by
    `Mutation.toggleChatCallHand` changes to lowered.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `ChatEvent`s may be produced on success:
    - `EventChatCallMemberLeft` (for `Chat`-groups);
    - `EventChatCallFinished` (for `Chat`-dialogs).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) when:
    - There is no ongoing `ChatCall` in the specified `Chat` at the moment.
    - The authenticated `MyUser` is not a member of the specified `Chat`
      already.
    - The authenticated `MyUser` is not a member of the ongoing `ChatCall`
      already.
  """
  leaveChatCall("ID of the `Chat` to leave the ongoing `ChatCall` of." chatId: ChatId!, """
    ID of the `MyUser`'s device to leave the ongoing `ChatCall` from.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
  """ deviceId: ChatCallDeviceId!): LeaveChatCallResult
  """
    Removes the specified `User` from the `ChatCall` of the specified
    `Chat`-group by authority of the authenticated `MyUser`.

    If the specified `User` participates in the `ChatCall` from multiple
    devices simultaneously, then removes all the devices at once.

    Lowers the specified `User`'s hand raised by
    `Mutation.toggleChatCallHand`, if any.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatEvent`s may be produced on success:
    - `EventChatCallMemberLeft` (for each device of the `User`);
    - `EventChatCallFinished`;
    - `EventChatCallMemberUndialed` (for dialed `User`);
    - `EventChatCallDeclined` (for dialed `MyUser`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
    is not a `ChatCallMember` of the specified `ChatCall` already.
  """
  removeChatCallMember("ID of the `User` to be removed from the `ChatCall`." userId: UserId!, "ID of the `Chat`-group to remove the `User` from ongoing `ChatCall` of." chatId: ChatId!): RemoveChatCallMemberResult
  """
    Redials a `ChatMember` who left or declined the ongoing `ChatCall` in
    the specified `Chat`-group by the authenticated `MyUser`.

    For using this mutation the authenticated `MyUser` must be a member of
    the ongoing `ChatCall`.

    Redialed `ChatMember` should see the `ChatCall.answered` indicator as
    `false`, and the ongoing `ChatCall` appearing in his
    `Query.incomingChatCallsTop` and
    `Subscription.incomingChatCallsTopEvents` again.

    Redialed `ChatMember` can be found in the
    `ChatMembersDialedConcrete.concrete` list, and once the answer timeout
    passes, the `Subscription.chatCallEvents` emits the
    `EventChatCallAnswerTimeoutPassed` with the `user` field pointing to
    him, meaning that he is not dialed anymore. Any received
    `EventChatCallAnswerTimeoutPassed`, with the `user` field set to `null`,
    should be ignored for explicitly redialed `ChatMember`s.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent` may be produced on success:
    - `EventChatCallMemberRedialed`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the redialed
    `ChatMember` didn't decline or leave the `ChatCall` yet, or has been
    redialed already.
  """
  redialChatCallMember("ID of the `Chat` where the `ChatCall` is going on." chatId: ChatId!, "ID of the `User` (being `ChatMember`) to be redialed." memberId: UserId!): RedialChatCallMemberResult
  """
    Raises/lowers a hand of the authenticated `MyUser` in the specified
    `ChatCall`.

    Use this mutation when the authenticated `MyUser` wants to notify other
    `ChatCall` members about his desire to start talking. New
    `ChatCallMember`s always join a `ChatCall` with a lowered hand.

    For using this mutation the authenticated `MyUser` must be a member of
    the `ChatCall`.

    Raised hand is lowered automatically whenever the authenticated
    `MyUser` lefts the `ChatCall` from all his devices.

    ## Authentication

    Mandatory.

    ## Result

    One of the following `ChatEvent`s may be produced on success:
    - `EventChatCallHandRaised` (if `raised` argument is `true`);
    - `EventChatCallHandLowered` (if `raised` argument is `false`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
    `MyUser` has raised/lowered his hand already.
  """
  toggleChatCallHand("ID of the `Chat` where the `ChatCall` is going on." chatId: ChatId!, """
    ID of the concrete `MyUser`'s device in the ongoing `ChatCall`.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
  """ deviceId: ChatCallDeviceId!, "Indicator whether to raise a hand (`true`), or to lower it (`false`)." raised: Boolean!): ToggleChatCallHandResult
  """
    Blocks the specified `User` for the authenticated `MyUser`.

    Blocked `User`s are not able to communicate with the authenticated
    `MyUser` directly (in `Chat`-dialogs) and add him to `Chat`-groups.

    `MyUser`'s blocklist can be obtained via `Query.blocklist`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `BlocklistEvent` may be produced on success:
    - `EventBlocklistRecordAdded`.

    ## Idempotent

    Succeeds as no-op (and returns no `BlocklistEvent`) if the specified
    `User` is blocked by the authenticated `MyUser` already with the same
    `BlocklistReason`.
  """
  blockUser("ID of the `User` to block." id: UserId!, "Reason to block the `User`." reason: BlocklistReason): BlockUserResult
  """
    Removes the specified `User` from the blocklist of the authenticated
    `MyUser`.

    Reverses the action of `Mutation.blockUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `BlocklistEvent` may be produced on success:
    - `EventBlocklistRecordRemoved`.

    ## Idempotent

    Succeeds as no-op (and returns no `BlocklistEvent`) if the specified
    `User` is not blocked by the authenticated `MyUser` already.
  """
  unblockUser("ID of the `User` to remove from the blocklist." id: UserId!): UnblockUserResult
  """
    Creates a new `ChatDirectLink` with the specified `ChatDirectLinkSlug`
    and deletes the current active `ChatDirectLink` of the given
    `Chat`-group or the authenticated `MyUser` (if any).

    Deleted `ChatDirectLink`s can be re-created again by the original owner
    only (`MyUser` or `Chat`-group) and cannot leak to somebody else.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`/`MyUserEvent` may be produced on success:
    - `EventChatDirectLinkCreated` (if `group_id` argument is not `null`);
    - `EventUserDirectLinkCreated` (if `group_id` argument is `null`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`/`MyUserEvent`) if the
    given `Chat`-group or the authenticated `MyUser` has an active
    `ChatDirectLink` with such `ChatDirectLinkSlug` already.
  """
  createChatDirectLink("Slug to create the `ChatDirectLink` with." slug: ChatDirectLinkSlug!, """
    ID of the `Chat`-group to create the `ChatDirectLink` for.

    If `null` then `ChatDirectLink` will be created for the authenticated `MyUser`.
  """ groupId: ChatId): CreateChatDirectLinkResult
  """
    Deletes the current `ChatDirectLink` of the given `Chat`-group or the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatEvent`/`MyUserEvent` may be produced on success:
    - `EventChatDirectLinkDeleted` (if `group_id` argument is not `null`);
    - `EventUserDirectLinkDeleted` (if `group_id` argument is `null`);.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`/`MyUserEvent`) if the
    given `Chat`-group or the authenticated `MyUser` has no active
    `ChatDirectLink`s already.
  """
  deleteChatDirectLink("""
    ID of the `Chat`-group to delete the `ChatDirectLink` for.

    If `null` then `ChatDirectLink` will be deleted for the authenticated `MyUser`.
  """ groupId: ChatId): DeleteChatDirectLinkResult
  """
    Uses the specified `ChatDirectLink` by the authenticated `MyUser`,
    creating a new `Chat`-dialog (or `Chat`-monolog), or joining an existing
    `Chat`-group.

    ## Authentication

    Mandatory.

    ## Result

    Always returns the created or modified `Chat`.

    Only the following `ChatEvent` may be produced on success for the
    `Chat`-group:
    - `EventChatItemPosted` (`ChatInfo` with either `ChatInfoActionCreated`
      or `ChatInfoActionMemberAdded`).

    ## Idempotent

    Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
    `MyUser` is already a member of the `Chat`-group or has already created
    the `Chat`-dialog by the specified `DirectLink`.
  """
  useChatDirectLink("Slug of the `ChatDirectLink` to use." slug: ChatDirectLinkSlug!): UseChatDirectLinkResult!
  """
    Creates a new `ChatContact` in the authenticated `MyUser`'s address
    book.

    Initially, a new `ChatContact` can be created with no more than 20
    `ChatContactRecord`s. Use `Mutation.createChatContactRecords` to add
    more, if you need so.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatContactEvent`s may be produced on success:
    - `EventChatContactCreated`;
    - `EventChatContactEmailAdded`;
    - `EventChatContactGroupAdded`;
    - `EventChatContactPhoneAdded`;
    - `EventChatContactUserAdded`.

    ## Non-idempotent

    Each time creates a new unique `ChatContact`.
  """
  createChatContact("Name to create the `ChatContact` with." name: UserName!, "Optional `ChatContactRecord`s to create and attach to the created `ChatContact`." records: [ChatContactRecord!] = []): CreateChatContactResult! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Marks the specified `ChatContact` as favorited for the authenticated
    `MyUser` and sets its position in the favorites list.

    To move the `ChatContact` to a concrete position in a favorites list,
    provide the average value of two other `ChatContact`s positions
    surrounding it.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatContactEvent` may be produced on success:
    - `EventChatContactFavorited`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
    `ChatContact` is already favorited at the same position.
  """
  favoriteChatContact("ID of the `ChatContact` to mark as favorited." id: ChatContactId!, "Position of the `ChatContact` in a favorites list." pos: ChatContactFavoritePosition!): FavoriteChatContactResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Removes the specified `ChatContact` from the favorites list of the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatContactEvent` may be produced on success:
    - `EventChatContactUnfavorited`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
    `ChatContact` is not in the favorites list already.
  """
  unfavoriteChatContact("ID of the `ChatContact` to remove from the favorites list." id: ChatContactId!): UnfavoriteChatContactResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Deletes the specified `ChatContact` from the authenticated `MyUser`'s
    address book.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatContactEvent` may be produced on success:
    - `EventChatContactDeleted`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
    `ChatContact` doesn't exist already.
  """
  deleteChatContact("ID of the `ChatContact` to delete." id: ChatContactId!): ChatContactEventsVersioned @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Updates the `name` of the specified `ChatContact` in the authenticated
    `MyUser`'s address book.

    ## Authentication

    Mandatory.

    ## Result

    Only the following `ChatContactEvent` may be produced on success:
    - `EventChatContactNameUpdated`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
    `ChatContact` has such name already.
  """
  updateChatContactName("ID of the `ChatContact` to update `name` of." id: ChatContactId!, "Name to update the `ChatContact` with." name: UserName!): UpdateChatContactNameResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Creates a new `ChatContactRecord` in the specified `ChatContact` of the
    authenticated `MyUser`'s address book.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatContactEvent`s may be produced on success:
    - `EventChatContactEmailAdded`;
    - `EventChatContactGroupAdded`;
    - `EventChatContactPhoneAdded`;
    - `EventChatContactUserAdded`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`s) if the specified
    `ChatContact` has such `ChatContactRecord` already.
  """
  createChatContactRecord("ID of the `ChatContact` to create a new `ChatContactRecord` in." id: ChatContactId!, "`ChatContactRecord` to create." record: ChatContactRecord!): CreateChatContactRecordResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Creates new multiple `ChatContactRecord`s in the specified `ChatContact`
    of the authenticated `MyUser`'s address book.

    No more than 20 `ChatContactRecord`s can be added at once.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatContactEvent`s may be produced on success:
    - `EventChatContactEmailAdded`;
    - `EventChatContactGroupAdded`;
    - `EventChatContactPhoneAdded`;
    - `EventChatContactUserAdded`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`s) if the specified
    `ChatContact` has such `ChatContactRecord`s already.
  """
  createChatContactRecords("ID of the `ChatContact` to create new `ChatContactRecord`s in." id: ChatContactId!, "`ChatContactRecord`s to create." records: [ChatContactRecord!]!): CreateChatContactRecordsResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Removes the specified `ChatContactRecord` from the specified
    `ChatContact` in the authenticated `MyUser`'s address book.

    ## Authentication

    Mandatory.

    ## Result

    The following `ChatContactEvent` may be produced on success:
    - `EventChatContactEmailRemoved`;
    - `EventChatContactGroupRemoved`;
    - `EventChatContactPhoneRemoved`;
    - `EventChatContactUserRemoved`.

    ## Idempotent

    Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
    `ChatContact` has no such `ChatContactRecord` already.
  """
  deleteChatContactRecord("ID of the `ChatContact` to remove the `ChatContactRecord` from." id: ChatContactId!, "`ChatContactRecord` to remove." record: ChatContactRecord!): DeleteChatContactRecordResult @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Registers a device (Android, iOS, or Web) for receiving push
    notifications.

    ## Localization

    You may provide the device's preferred locale via the
    [`Accept-Language` HTTP header][3], which will localize notifications to
    that device using the [best match][4] of the supported locales.

    In order to change the locale or `PushDeviceSettings` of the device, it
    should be re-registered (use `Mutation.unregisterPushDevice`, and then
    `Mutation.registerPushDevice` once again).

    ## Authentication

    Mandatory.

    Registered device will be associated with the currently authenticated
    `Session`, meaning it will be automatically unregistered once the
    `Session` is deleted or expired.

    In order to change the associated `Session` of the device, it should be
    re-registered under the new `Session` (use
    `Mutation.unregisterPushDevice`, and then `Mutation.registerPushDevice`
    once again).

    ## Result

    Always returns `null` on success.

    ## Idempotent

    Succeeds if the specified `token` is registered already.

    [3]: https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Language
    [4]: https://www.ietf.org/rfc/rfc4647.html#section-3.3
  """
  registerPushDevice("Token of the device to register." token: PushDeviceToken!, "Settings of the push device to register with." settings: PushDeviceSettings! = {cancellation: false}): RegisterPushDeviceErrorCode
  """
    Unregisters a device (Android, iOS, or Web) from receiving push
    notifications.

    ## Authentication

    Mandatory.

    ## Idempotent

    Succeeds if the specified `token` is not registered already.
  """
  unregisterPushDevice("Token of the device to unregister." token: PushDeviceToken!): UnregisterPushDeviceErrorCode
  """
    Creates a new `OperationDeposit`.

    Exactly one of `kind` argument's fields must be specified (be
    non-`null`).

    ## Authentication

    Mandatory.

    ## Non-idempotent

    Each time creates a new unique `OperationDeposit`.
  """
  createOperationDeposit("ID of the `OperationDepositMethod` to create the `OperationDeposit` with." methodId: OperationDepositMethodId!, "Kind of the created `OperationDeposit`." kind: OperationDepositInput!, "Billing `CountryCode` of the created `OperationDeposit`." billingCountry: CountryCode!): CreateOperationDepositResult!
  """
    Completes an `OperationDeposit`.

    ## Authentication

    Mandatory if the `secret` argument is not specified (or is `null`).

    ## Result

    One of the following `OperationEvent`s may be produced on success:
    - `EventOperationDepositCompleted`;
    - `EventOperationDepositFailed`.

    ## Idempotent

    Succeeds as no-op (and returns no `OperationEvent`) if the
    `OperationDeposit` with the specified `id` is completed or failed
    already.
  """
  completeOperationDeposit("ID of the `OperationDeposit` to complete." id: OperationId!, """
    Secret to authenticate the `OperationDeposit` completion.

    If absent or `null` then authentication is mandatory.
  """ secret: OperationDepositSecret): CompleteOperationDepositResult
  """
    Declines an `OperationDeposit`.

    ## Authentication

    Mandatory if the `secret` argument is not specified (or is `null`).

    ## Result

    Only the following `OperationEvent` may be produced on success:
    - `EventOperationDepositDeclined`.

    ## Idempotent

    Succeeds if the `OperationDeposit` with the specified `id` is declined
    already.
  """
  declineOperationDeposit("ID of the `OperationDeposit` to decline." id: OperationId!, """
    Secret to authenticate the `OperationDeposit` decline.

    If absent or `null` then authentication is mandatory.
  """ secret: OperationDepositSecret): DeclineOperationDepositResult
  """
    Creates a new `OperationWithdraw`.

    Exactly one of `kind` argument's fields must be specified (be
    non-`null`).

    ## Authentication

    Mandatory.

    ## Non-idempotent

    Each time creates a new unique `OperationWithdraw`.
  """
  createOperationWithdraw("ID of the `OperationWithdrawMethod` to create the `OperationWithdraw` with." methodId: OperationWithdrawMethodId!, "Nominal to be withdrawn in XXX." nominal: Sum!, "Kind of the created `OperationWithdraw`." kind: OperationWithdrawInput!, "Billing `CountryCode` of the created `OperationWithdraw`." billingCountry: CountryCode!): CreateOperationWithdrawResult!
}

"Forever mute duration."
type MuteForeverDuration {
  """
    Indicator that a `Chat` (or the authenticated `MyUser`) is muted
    forever.

    Always is `true`.
  """
  forever: Boolean!
}

"""
  Mute duration until an exact `DateTime`.

  Once this `DateTime` pasts (or is in the past already), it should be
  considered by a client side as automatically unmuted. Server won't notify a
  client side about that.
"""
type MuteUntilDuration {
  "`DateTime` until a `Chat` (or the authenticated `MyUser`) is muted."
  until: DateTime!
}

"`User` of a system being currently signed-in."
type MyUser {
  """
    Unique ID of this `MyUser`.

    Once assigned it never changes.
  """
  id: UserId!
  """
    Unique number of this `MyUser`.

    `num` is intended for easier `MyUser` identification by other `User`s.
    It's just like a telephone number in a real life.

    `num` allows `MyUser` to perform a sign-in, when combined with a
    password.

    It may be reused by another `User` in the future, once this `MyUser`
    becomes unreachable (sign-in for this `MyUser` is impossible).
  """
  num: UserNum!
  """
    Unique login of this `MyUser`.

    `login` allows `MyUser` to perform a sign-in, when combined with a
    password.
  """
  login: UserLogin
  "List of `UserEmail` addresses of this `MyUser`."
  emails: UserEmails!
  "List of `UserPhone` numbers of this `MyUser`."
  phones: UserPhones! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Name of this `MyUser`.

    `name` of a `MyUser` is not unique and is intended for displaying a
    `MyUser` in a well-readable form. It can be either first name, or last
    name of a `MyUser`, both of them, or even some nickname.
  """
  name: UserName
  "Arbitrary descriptive information about this `MyUser`."
  bio: UserBio
  """
    Avatar of this `MyUser`.

    `avatar` is an image helping to identify a `MyUser` visually.
  """
  avatar: UserAvatar
  """
    Call cover of this `MyUser`.

    `callCover` is an image helping to identify a `MyUser` visually in
    `ChatCall`s.
  """
  callCover: UserCallCover
  """
    Indicator whether this `MyUser` has a password.

    Password allows `MyUser` to perform a sign-in, when combined with a
    `login`, `num`, `email` or `phone`.
  """
  hasPassword: Boolean!
  "`ChatDirectLink` to the `Chat` with this `MyUser`."
  chatDirectLink: ChatDirectLink
  "Count of the unread `Chat`s of this `MyUser`."
  unreadChatsCount: Int!
  """
    Online state of this `MyUser`.

    `MyUser` is considered to be online, while he is subscribed to
    `Subscription.keepOnline`.
  """
  online: UserOnlineState!
  "`UserPresence` of this `MyUser`."
  presence: UserPresence!
  "Custom text status of this `MyUser`."
  status: UserTextStatus
  """
    Mute state of this `MyUser`.

    Muted `MyUser` implies that all its `Chat`s events don't produce sounds
    and notifications on a client side. This, however, has nothing to do
    with a server and is the responsibility to be satisfied by a client
    side. Server side may try to optimize this in some cases (like omit
    sending notifications), but a client side should not rely on any such
    behaviour and should implement best-effort muting by itself.

    Note, that `MyUser.muted` doesn't correlate with `Chat.muted`. Muted
    `Chat` of unmuted `MyUser` (and unmuted `Chat` of muted `MyUser`) should
    not produce any sounds.
  """
  muted: MuteDuration
  """
    Returns `User`s blocked by this `MyUser` as `BlocklistRecord`s.

    Alias of `Query.blocklist`.

    ## Sorting

    Returned `User`s are sorted primarily by their blocking `DateTime`, and
    secondary by their IDs (if the blocking `DateTime` is the same), in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `BlocklistRecord` pointed by the cursor
    and the requested count of `BlocklistRecord`s preceding and following
    it.

    If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    ## Versioning

    Returned `BlocklistConnection` is versioned by its own
    `BlocklistVersion` and not by the `MyUserVersion` of this `MyUser`.

    Use `Subscription.blocklistEvents` instead of
    `Subscription.myUserEvents` to be up-to-date with the returned
    `BlocklistConnection` changes.
  """
  blocklist("Number of next `BlocklistRecord`s to return." first: Int, "Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after." after: BlocklistCursor, "Number of prior `BlocklistRecord`s to return." last: Int, "Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before." before: BlocklistCursor): BlocklistConnection!
  "`WelcomeMessage` of this `MyUser`."
  welcomeMessage: WelcomeMessage
  """
    Promotion program parameters of this `MyUser`.

    ## Result

    Returns `null` when:
    - No promotion program is available on this site.

    ## Versioning

    Returned `UserPromo.share` field is versioned by its own
    `PromoShareVersion` and not by the `MyUserVersion` of this `MyUser`.
  """
  promo: UserPromo
  """
    Returns the current `Balance` of this `MyUser` in the provided
    `BalanceOrigin`.

    Alias of the `Query.balance`.

    ## Versioning

    Returned `Balance` is not versioned by the `MyUserVersion` of this
    `MyUser`.

    Use `Subscription.balanceUpdates` instead of `Subscription.myUserEvents`
    to be up-to-date with the returned `Balance` changes.
  """
  balance("Origin to return the `Balance` of." origin: BalanceOrigin!): Balance!
  """
    Common monetization settings of the authenticated `MyUser` (applied to
    all `User`s).

    Alias of the `Query.myMonetizationSettings` with the `by.userId`
    argument specified as `MyUser.id`.

    ## Authentication

    Mandatory.

    ## Versioning

    Returned `MyUser.monetizationSettings` field is versioned by its own
    `MonetizationSettingsVersion` and not by the `MyUserVersion` of this
    `MyUser`.
  """
  monetizationSettings: MonetizationSettingsEdge!
  """
    Version of this `MyUser`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: MyUserVersion!
}

"`MyUserEvent`s along with the corresponding `MyUserVersion`."
type MyUserEventsVersioned {
  "`MyUserEvent`s themselves."
  events: [MyUserEvent!]!
  """
    Actual state of the `MyUser` after the `MyUserEvent` has been emitted
    (so the returned `MyUser.ver` may differ from the `ver` of these
    `MyUserEventsVersioned`).
  """
  myUser: MyUser!
  """
    Version of the `MyUser`'s state updated by these `MyUserEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: MyUserVersion!
}

"Information about `Operation`'s cancellation."
type OperationCancellation {
  "Code explaining why the `Operation` was canceled."
  code: OperationCancellationCode!
  "Additional reason of why the `Operation` was canceled."
  reason: OperationCancellationReason
  "`DateTime` when the `Operation` was canceled."
  at: DateTime!
}

"`Operation` of charging money from `MyUser`."
type OperationCharge implements Operation {
  "ID of this `OperationCharge`."
  id: OperationId!
  "Sequential number of this `OperationCharge`."
  num: OperationNum!
  "Status of this `OperationCharge`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationCharge`.

    Could be either `OperationOrigin.PURSE` or `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationCharge`.

    Always an `OperationDirection.OUTGOING`.
  """
  direction: OperationDirection!
  """
    Money `Sum` and `Currency` of this `OperationCharge`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Reason of this `OperationCharge`."
  reason: OperationReason!
  """
    `OperationsEdge`s of the `Operation`s this `OperationCharge` is linked
    to.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationCharge` is on hold.

    Always `null` as an `OperationCharge` could never be on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationCharge` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationCharge` was canceled.

    Always `null` as an `OperationCharge` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationCharge`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`Operation` of depositing money to `MyUser`'s purse."
type OperationDeposit implements Operation {
  "ID of this `OperationDeposit`."
  id: OperationId!
  "Sequential number of this `OperationDeposit`."
  num: OperationNum!
  "Kind of this `OperationDeposit`."
  kind: OperationDepositKind!
  "Status of this `OperationDeposit`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationDeposit`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationDeposit`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  "Country of the billing address of this `OperationDeposit`."
  billingCountry: CountryCode!
  "Nominal `Price` of this `OperationDeposit`."
  amount: Price!
  """
    Pricing of this `OperationDeposit`.

    `null` if the `DepositPricing` is not determined yet.
  """
  price: OperationDepositPricing
  """
    URL to process this `OperationDeposit` on.

    `null` if this `OperationDeposit` doesn't require processing on external
    URL.
  """
  processingUrl: URL
  """
    `InvoiceFile` of this `OperationDeposit`.

    `null` if this `OperationDeposit` is not `OperationStatus.COMPLETED`.
  """
  invoice: InvoiceFile
  """
    `OperationsEdge`s of the `Operation`s this `OperationDeposit` is linked
    to.

    Always empty as an `OperationDeposit` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationDeposit` is on hold.

    Always `null` as an `OperationDeposit` could never be on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationDeposit` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationDeposit` was canceled.

    Always `null` as an `OperationDeposit` could never be canceled.
  """
  canceled: OperationCancellation
  "Information about why this `OperationDeposit` failed, if it did."
  failed: OperationDepositFailure
  """
    Version of this `OperationDeposit`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"""
  `Operation` of granting a bonus to `MyUser`'s purse after an
  `OperationDeposit` completion.
"""
type OperationDepositBonus implements Operation {
  "ID of this `OperationDepositBonus`."
  id: OperationId!
  "Sequential number of this `OperationDepositBonus`."
  num: OperationNum!
  "Status of this `OperationDepositBonus`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationDepositBonus`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationDepositBonus`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  """
    `OperationsEdge` of the `OperationDeposit` this `OperationDepositBonus`
    is linked to.

    Guaranteed to contain the `OperationDeposit` inside.
  """
  deposit: OperationsEdge!
  """
    Money `Sum` and `Currency` of this `OperationDepositBonus`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationsEdge` of the `OperationDeposit` this `OperationDepositBonus`
    is linked to.

    Guaranteed to return exactly a single `OperationsEdge` with the
    `OperationDeposit` inside.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationDepositBonus` is on hold.

    Always `null` as an `OperationDepositBonus` cound never be on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationDepositBonus` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationDepositBonus` was canceled.

    Always `null` as an `OperationDepositBonus` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationDepositBonus`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"Information about `OperationDeposit`'s failure."
type OperationDepositFailure {
  "Code explaining why the `OperationDeposit` failed."
  code: OperationDepositFailureCode!
  "`DateTime` when the `OperationDeposit` failed."
  at: DateTime!
}

"Description of some method for performing an `OperationDeposit`."
type OperationDepositMethod {
  "Unique ID of this `OperationDepositMethod`."
  id: OperationDepositMethodId!
  "`OperationDepositKind` of this `OperationDepositMethod`."
  kind: OperationDepositKind!
  """
    Criteria filtering this `OperationDepositMethod` availability for
    specific `CountryCode`s.

    `null` means that this `OperationDepositMethod` is available for all
    `CountryCode`s.
  """
  countries: CriteriaCountry
  """
    List of available nominal `Price`s this `OperationDepositMethod`
    accepts.

    `null` means that this `OperationDepositMethod` accepts arbitrary
    `Price`s.
  """
  nominals: [Price!]
  """
    `OperationDepositMethodPricing` of this `OperationDepositMethod`.

    `null` in case this `OperationDepositMethod` is unavailable for the
    provided `CountryCode`.
  """
  pricing("""
    Nominal to calculate the returned `OperationDepositMethodPricing` for.

    If absent or `null` then the nominal `1` is assumed.

    Integer-only, meaning that its fractional part should be zero.
  """ nominal: Sum, "`CountryCode` to return the `OperationDepositMethodPricing` for." country: CountryCode!): OperationDepositMethodPricing
}

"Pricing of an `OperationDepositMethod`."
type OperationDepositMethodPricing {
  "Nominal `Price` of the `OperationDepositMethod`."
  nominal: Price!
  """
    Bonus of the `nominal` `Price` to be granted as a separate
    `OperationDepositBonus` once the original `OperationDeposit` is
    completed successfully.

    `null` if no bonus is granted.
  """
  bonus: PriceModifier
  """
    Calculated `Price` of the `OperationDepositMethod` to be paid, before
    the `tax` being applied, in the provided `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationDepositMethod`.

    Doesn't include `bonus`.
  """
  withoutTax("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationDepositMethod`.
  """ currency: Currency): Price
  """
    Tax applied to the `withoutTax` `Price`, according to the billing
    `CountryCode` of the `OperationDepositMethod`, in the provided
    `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationDepositMethod`.
  """
  tax("""
    `Currency` to return the `tax` in.

    If absent or `null` then the `tax` is returned in the actual paying `Currency` of the
                              `OperationDepositMethod`.
  """ currency: Currency): PriceModifier
  """
    Calculated total `Price` of the `OperationDepositMethod` to be paid,
    after the `tax` being applied, in the provided `Currency`.

    It's calculated as: `total = withoutTax + tax`.

    `null` if the provided `Currency` is not supported by the
    `OperationDepositMethod`.

    Doesn't include `bonus`.
  """
  total("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationDepositMethod`.
  """ currency: Currency): Price
}

"Pricing of an `OperationDeposit`."
type OperationDepositPricing {
  "Nominal `Price` of the `OperationDeposit`."
  nominal: Price!
  """
    Bonus of the `nominal` `Price` to be granted as a separate
    `OperationDepositBonus` once the original `OperationDeposit` is
    completed successfully.

    `null` if no bonus is granted.
  """
  bonus: PriceModifier
  """
    Calculated `Price` of the `OperationDeposit` to be paid, before the
    `tax` being applied, in the provided `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationDeposit`.

    Doesn't include `bonus`.
  """
  withoutTax("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationDeposit`.
  """ currency: Currency): Price
  """
    Tax applied to the `withoutTax` `Price`, according to the billing
    `CountryCode` of the `OperationDeposit`, in the provided `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationDeposit`.
  """
  tax("""
    `Currency` to return the `tax` in.

    If absent or `null` then the `tax` is returned in the actual paying `Currency` of the
                              `OperationDeposit`.
  """ currency: Currency): PriceModifier
  """
    Calculated total `Price` of the `OperationDeposit` to be paid, after the
    `tax` being applied, in the provided `Currency`.

    It's calculated as: `total = withoutTax + tax`.

    `null` if the provided `Currency` is not supported by the
    `OperationDeposit`.

    Doesn't include `bonus`.
  """
  total("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationDeposit`.
  """ currency: Currency): Price
}

"`Operation` of receiving dividend money."
type OperationDividend implements Operation {
  "ID of this `OperationDividend`."
  id: OperationId!
  "Sequential number of this `OperationDividend`."
  num: OperationNum!
  "Status of this `OperationDividend`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationDividend`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationDividend`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  "ID of the source `Operation` this `OperationDividend` is created for."
  sourceId: OperationId!
  """
    Money `Sum` and `Currency` of this `OperationDividend`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationsEdge`s of the `Operation`s this `OperationDividend` is linked
    to.

    Always empty as an `OperationDividend` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationDividend` is on hold.

    If it's less than now, it means that the hold is in process of being
    lifted yet.

    `null` if this `OperationDividend` is not on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationDividend` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationDividend` was canceled.

    Always `null` as an `OperationDividend` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationDividend`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`Operation` of earning money as a `Vendor` from a made `Donation`."
type OperationEarnDonation implements Operation {
  "ID of this `OperationEarnDonation`."
  id: OperationId!
  "Sequential number of this `OperationEarnDonation`."
  num: OperationNum!
  "Status of this `OperationEarnDonation`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationEarnDonation`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    Money `Sum` and `Currency` of this `OperationEarnDonation`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationDirection` of this `OperationEarnDonation`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  """
    `ChatItem` the earned `Donation` is part of.

    `null` if the `ChatItem` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  chatItem: ChatItemsEdge
  """
    `Chat` the related `ChatItem` of the earned `Donation` belongs to.

    Always non-`null` at this moment.
  """
  chat: Chat
  "ID of the `Donation` earned by this `OperationEarnDonation`."
  donationId: DonationId!
  "`User` who made the `Donation` triggering this `OperationEarnDonation`."
  customer: User!
  """
    `OperationsEdge`s of the `Operation`s this `OperationEarnDonation` is
    linked to.

    Always empty as an `OperationEarnDonation` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationEarnDonation` is on hold.

    If it's less than now, it means that the hold is in process of being
    lifted yet.

    `null` if this `OperationEarnDonation` is not on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationEarnDonation` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationEarnDonation` was canceled.

    Always `null` as an `OperationEarnDonation` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationEarnDonation`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`OperationEvent`s along with the corresponding `OperationVersion`."
type OperationEventsVersioned {
  "`OperationEvent`s themselves."
  events: [OperationEvent!]!
  """
    Version of the `Operation`'s state updated by these `OperationEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
  """
    Version of the `OperationsList`'s state updated by these
    `OperationEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  listVer: OperationVersion!
}

"`Operation` of granting money to `MyUser`."
type OperationGrant implements Operation {
  "ID of this `OperationGrant`."
  id: OperationId!
  "Sequential number of this `OperationGrant`."
  num: OperationNum!
  "Status of this `OperationGrant`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationGrant`.

    Could be either `OperationOrigin.PURSE` or `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationGrant`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  """
    Money `Sum` and `Currency` of this `OperationGrant`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Reason of this `OperationGrant`."
  reason: OperationReason!
  """
    `OperationsEdge`s of the `Operation`s this `OperationGrant` is linked
    to.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationGrant` is on hold.

    If it's less than now, it means that the hold is in process of being
    lifted yet.

    `null` if this `OperationGrant` is not on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationGrant` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationGrant` was canceled.

    Always `null` as an `OperationGrant` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationGrant`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`Operation` of making a `Donation` by a `User` to some `Vendor`."
type OperationPurchaseDonation implements Operation {
  "ID of this `OperationPurchaseDonation`."
  id: OperationId!
  "Sequential number of this `OperationPurchaseDonation`."
  num: OperationNum!
  "Status of this `OperationPurchaseDonation`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationPurchaseDonation`.

    Always an `OperationOrigin.PURSE`.
  """
  origin: OperationOrigin!
  """
    Money `Sum` and `Currency` of this `OperationPurchaseDonation`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  """
    `OperationDirection` of this `OperationPurchaseDonation`.

    Always an `OperationDirection.OUTGOING`.
  """
  direction: OperationDirection!
  """
    `ChatItem` the made `Donation` is part of.

    `null` if the `ChatItem` was deleted or is unavailable for the
    authenticated `MyUser`.
  """
  chatItem: ChatItemsEdge
  """
    `Chat` the related `ChatItem` of the made `Donation` belongs to.

    Always non-`null` at this moment.
  """
  chat: Chat
  "ID of the `Donation` made by this `OperationPurchaseDonation`."
  donationId: DonationId!
  """
    `Vendor` receiving the `Donation` made by this
    `OperationPurchaseDonation`.

    Always a `User`.
  """
  vendor: Vendor!
  """
    `OperationsEdge`s of the `Operation`s this `OperationPurchaseDonation`
    is linked to.

    Always empty as an `OperationPurchaseDonation` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationPurchaseDonation` is on hold.

    Always `null` as an `OperationPurchaseDonation` could never be on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationPurchaseDonation` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationPurchaseDonation` was canceled, if
    it was.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationPurchaseDonation`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`Operation` of rewarding `MyUser` due to affiliation program."
type OperationReward implements Operation {
  "ID of this `OperationReward`."
  id: OperationId!
  "Sequential number of this `OperationReward`."
  num: OperationNum!
  "Status of this `OperationReward`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationReward`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationReward`.

    Always an `OperationDirection.INCOMING`.
  """
  direction: OperationDirection!
  """
    Money `Sum` and `Currency` of this `OperationReward`.

    `Currency` is always `XXX`.
  """
  amount: Price!
  "Cause of this `OperationReward`."
  cause: OperationRewardCause!
  """
    Sequential number of the affiliated `User` causing this
    `OperationReward`.
  """
  affiliatedNum: UserAffiliatedNum!
  """
    `OperationsEdge`s of the `Operation`s this `OperationReward` is linked
    to.

    Always empty as an `OperationReward` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationReward` is on hold.

    If it's less than now, it means that the hold is in process of being
    lifted yet.

    `null` if this `OperationReward` is not on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationReward` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationReward` was canceled.

    Always `null` as an `OperationReward` could never be canceled.
  """
  canceled: OperationCancellation
  """
    Version of this `OperationReward`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"`Operation` of withdrawing money by `MyUser`."
type OperationWithdraw implements Operation {
  "ID of this `OperationWithdraw`."
  id: OperationId!
  "Sequential number of this `OperationWithdraw`."
  num: OperationNum!
  "Kind of this `OperationWithdraw`."
  kind: OperationWithdrawKind!
  "Status of this `OperationWithdraw`."
  status: OperationStatus!
  """
    `OperationOrigin` of this `OperationWithdraw`.

    Always an `OperationOrigin.INCOME`.
  """
  origin: OperationOrigin!
  """
    `OperationDirection` of this `OperationWithdraw`.

    Always an `OperationDirection.OUTGOING`.
  """
  direction: OperationDirection!
  "Country of the billing address of this `OperationWithdraw`."
  billingCountry: CountryCode!
  "Beneficiary `BankAccountRequisites` of this `OperationWithdraw`."
  beneficiary: BankAccountRequisites!
  "Intermediary `BankAccountRequisites` of this `OperationWithdraw`."
  intermediary: BankAccountRequisites
  "Nominal `Price` of this `OperationWithdraw`."
  amount: Price!
  "Pricing of this `OperationWithdraw`."
  price: OperationWithdrawPricing!
  """
    `OperationsEdge`s of the `Operation`s this `OperationWithdraw` is linked
    to.

    Always empty as an `OperationWithdraw` cannot be linked to other
    `Operation`s.
  """
  linked: [OperationsEdge!]!
  """
    `DateTime` until which this `OperationWithdraw` is on hold.

    Always `null` as an `OperationWithdraw` could never be on hold.
  """
  holdUntil: DateTime
  "`DateTime` when this `OperationWithdraw` was created."
  createdAt: DateTime!
  """
    Information about why this `OperationWithdraw` was canceled.

    Always `null` as an `OperationWithdraw` could never be canceled.
  """
  canceled: OperationCancellation
  "Information about why this `OperationWithdraw` failed, if it did."
  failed: OperationWithdrawFailure
  """
    Version of this `OperationWithdraw`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"Information about `OperationWithdraw`'s failure."
type OperationWithdrawFailure {
  "Code explaining why the `OperationWithdraw` failed."
  code: OperationWithdrawFailureCode!
  """
    Additional reason explaining why the `OperationWithdraw` failed, if
    provided.
  """
  reason: OperationFailureReason
  "`DateTime` when the `OperationWithdraw` failed."
  at: DateTime!
}

"Pricing of an `OperationWithdrawMethod`."
type OperationWithdrawMethodPricing {
  "Nominal `Price` of the `OperationWithdrawMethod`."
  nominal: Price!
  """
    Commission details of the `OperationWithdrawMethod`, in the provided
    `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationWithdrawMethod` or commission details are unavailable for the
    provided `Currency`.
  """
  commission("""
    `Currency` to return the calculated commission in.

    If absent or `null` then the commission is returned in the actual paying `Currency` of the
                              `OperationWithdraw`.
  """ currency: Currency): OperationWithdrawPricingCommission
  """
    Approximate `Price` of the `OperationWithdrawMethod`, in the provided
    `Currency`, before the commission deduction.

    `null` if the provided `Currency` is not supported by the
    `OperationWithdraw`.
  """
  withoutCommission("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationWithdraw`.
  """ currency: Currency): Price
  """
    Minimum nominal `Price` allowed to withdraw.

    `null` means no limit.
  """
  min: Price
  """
    Maximum nominal `Price` allowed to withdraw.

    `null` means no limit.
  """
  max: Price
}

"""
  Description of some method for performing an `OperationWithdraw` via
  [SWIFT].

  [SWIFT]: https://www.swift.com
"""
type OperationWithdrawMethodSwift implements OperationWithdrawMethod {
  "Unique ID of this `OperationWithdrawMethodSwift`."
  id: OperationWithdrawMethodId!
  """
    `OperationWithdrawKind` of this `OperationWithdrawMethodSwift`.

    Always `OperationWithdrawKind.SWIFT`.
  """
  kind: OperationWithdrawKind!
  """
    Criteria filtering this `OperationWithdrawMethodSwift` availability for
    specific `CountryCode`s.

    `null` means that this `OperationWithdrawMethodSwift` is available for
    all `CountryCode`s.
  """
  countries: CriteriaCountry
  "`Currency` of this `OperationWithdrawMethodSwift`."
  currency: Currency!
  """
    `OperationWithdrawMethodPricing` of this `OperationWithdrawMethodSwift`.

    `null` in case this `OperationWithdrawMethodSwift` is unavailable for
    the provided `CountryCode`.
  """
  pricing("""
    Nominal to calculate the returned `OperationWithdrawMethodPricing` for.

    If absent or `null` then the nominal `1` is assumed.
  """ nominal: Sum, "`CountryCode` to return the `OperationWithdrawMethodPricing` for." country: CountryCode!): OperationWithdrawMethodPricing
}

"Pricing of an `OperationWithdraw`."
type OperationWithdrawPricing {
  "Nominal `Price` of the `OperationWithdraw`."
  nominal: Price!
  """
    Commission details of the `OperationWithdraw`, in the provided
    `Currency`.

    `null` if the provided `Currency` is not supported by the
    `OperationWithdraw` or commission details are unavailable for the
    provided `Currency`.
  """
  commission("""
    `Currency` to return the calculated commission in.

    If absent or `null` then the commission is returned in the actual paying `Currency` of the
                              `OperationWithdraw`.
  """ currency: Currency): OperationWithdrawPricingCommission
  """
    Approximate `Price` of the `OperationWithdraw`, in the provided
    `Currency`, before the commission deduction.

    `null` if the provided `Currency` is not supported by the
    `OperationWithdraw`.
  """
  withoutCommission("""
    `Currency` to return the calculated `Price` in.

    If absent or `null` then the `Price` is returned in the actual paying `Currency` of the
                              `OperationWithdraw`.
  """ currency: Currency): Price
}

"Commission details of an `OperationWithdraw`."
type OperationWithdrawPricingCommission {
  """
    Minimum possible commission.

    `null` means no limit.
  """
  min: PriceModifier
  """
    Maximum possible commission.

    `null` means no limit.
  """
  max: PriceModifier
  "Fixed part of the commission."
  fixed: PriceModifier
  """
    Additional part of the commission.

    Guaranteed to be `null` if the `fixed` part is also `null`.
  """
  additional: PriceModifier
}

"""
  [Connection] with `Operation`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type OperationsConnection {
  """
    List of `Operation` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [OperationsEdge!]!
  """
    List of `Operation`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [Operation!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  "Total count of `Operation`s."
  totalCount: Int!
  """
    Version of this `Operation`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: OperationVersion!
}

"""
  [Edge] with an `Operation`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type OperationsEdge {
  """
    `Operation` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: Operation!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: OperationsCursor!
}

"List of `Operation`s."
type OperationsList {
  """
    Returns `Operation`s filtered by the provided criteria.

    Exactly one of `by` argument's fields must be specified (be non-`null`).

    Searching `by.id` or `by.num` is exact.

    If no `by` argument is provided, then all existing `Operation`s are
    returned.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `Operation`s are sorted depending on the provided arguments:
    - If the `by.id` argument is specified, then an exact `Operation` is
      returned.
    - If the `by.num` argument is specified, then an exact `Operation` is
      returned.
    - Otherwise, the returned `Operation`s are sorted by their
      `OperationNum` in descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `Operation` pointed by the cursor and the
    requested count of `Operation`s preceding and following it.

    If it's desired to receive the `Operation`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some filtered entries with a cursor pointing to a page
    of totally different filtered entries is nonsense and will produce an
    invalid result (usually returning nothing).
  """
  operations("Filter to search `Operation`s by." by: OperationsFilter, """
    Pagination arguments to return the `Operation`s by.

    Does nothing if the `by.id` or `by.num` argument is specified.
  """ pagination: OperationsPagination): OperationsConnection!
}

"""
  [`PageInfo`][1] returned by a [Connection] according to
  [GraphQL Cursor Connections Specification][0].

  [0]: https://tinyurl.com/gql-relay
  [1]: https://tinyurl.com/gql-relay#sec-Connection-Types.Fields.PageInfo
  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type PageInfo {
  """
    [Cursor] pointing to the last [Node] in [Connection]'s [Edges].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Node]: https://tinyurl.com/gql-relay#sec-Node
    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sec-Edges
  """
  endCursor: String
  """
    Indicator whether more [Edge]s exist following the set defined by the
    clients arguments.

    If the client is paginating with `first`/`after`, then `true` is
    returned if further [Edge]s exist, otherwise `false`.

    If the client is paginating with `last`/`before`, then `false` is
    returned.

    See [`PageInfo` fields spec][1] for more details.

    [1]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo.Fields
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  hasNextPage: Boolean!
  """
    [Cursor] pointing to the first [Node] in [Connection]'s [Edges].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Node]: https://tinyurl.com/gql-relay#sec-Node
    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sec-Edges
  """
  startCursor: String
  """
    Indicator whether more [Edge]s exist prior to the set defined by the
    clients arguments.

    If the client is paginating with `last`/`before`, then `true` is
    returned if prior [Edge]s exist, otherwise `false`.

    If the client is paginating with `first`/`after`, then `false` is
    returned.

    See [`PageInfo` fields spec][1] for more details.

    [1]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo.Fields
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  hasPreviousPage: Boolean!
}

"Plain-`File` on a file storage."
type PlainFile implements File {
  """
    [Relative reference][1] to this `PlainFile` on a file storage.

    Prepend it with a file storage URL to obtain the full link to this
    `PlainFile`.

    If `404` HTTP status code is returned while trying to download this
    `PlainFile` from a file storage, then the `PlainFile` is not ready yet.
    Back off, and retry again later.

    `403` HTTP status code, on the other hand, means that the link has been
    expired and this [relative reference][1] should be re-fetched to rebuild
    the link.

    [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!
  """
    [SHA-256] checksum of this `PlainFile`.

    May be `null` in case this `PlainFile` is not ready on a file storage
    yet. May be also computed on a client side, once this `PlainFile`
    is ready and successfully downloaded from a file storage.

    This checksum is especially useful if a client side requires to verify
    the integrity and authenticity of this `PlainFile`, downloaded from
    a file storage.

    Also, this checksum may be useful as a key in a client side cache,
    allowing to store `PlainFile`s in deduplicated manner.

    [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String
  """
    Size of this `PlainFile` (in bytes).

    May be `null` in case this `PlainFile` is not ready on a file storage
    yet. May be also computed on a client side, once this `PlainFile`
    is ready and successfully downloaded from a file storage.
  """
  size: Int
}

"2D point on an image."
type Point {
  "X coordinate of this `Point` in `px` (pixels)."
  x: Int!
  "Y coordinate of this `Point` in `px` (pixels)."
  y: Int!
}

"Error of performing `Mutation.postChatMessage`."
type PostChatMessageError {
  "Code indicating why this error has happened."
  code: PostChatMessageErrorCode!
}

"Price of something."
type Price {
  "`Sum` of this `Price`."
  sum: Sum!
  "`Currency` of this `Price`."
  currency: Currency!
}

"Modifier of a `Price`."
type PriceModifier {
  """
    `Percentage` to apply to the `Price`.

    `null` means this `PriceModifier` modifies the `Price` by a fixed `Sum`.
  """
  percentage: Percentage
  """
    Concrete `Sum` amount to apply to the `Price`.

    If the `percentage` is not `null`, then it represents the already
    calculated `Sum` of the `percentage`.
  """
  amount: Price!
}

"""
  Percentage for each transaction that an author `User` shares with its
  promoter `User`s.
"""
type PromoShare {
  "`Percentage` of this `PromoShare`."
  percentage: Percentage!
  "`DateTime` when this `PromoShare` was added."
  addedAt: DateTime!
  """
    `DateTime` when this `PromoShare` was removed, if any.

    `null` if this `PromoShare` is not removed and is currently active.
  """
  removedAt: DateTime
  """
    Version of this `PromoShare`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: PromoShareVersion!
}

"`PromoShareEvent`s along with the corresponding `PromoShareVersion`."
type PromoShareEventsVersioned {
  "`PromoShareEvent`s themselves."
  events: [PromoShareEvent!]!
  """
    Version of the `PromoShare`'s state updated by these `PromoShareEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: PromoShareVersion!
}

"""
  [Connection] with `PromoShare`s in a historical order.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type PromoShareHistoryConnection {
  """
    List of `PromoShare` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [PromoShareHistoryEdge!]!
  """
    List of `PromoShare`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [PromoShare!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  "Total count of `PromoShare`s."
  totalCount: Int!
  """
    Version of this `PromoShare`s list.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: PromoShareVersion!
}

"""
  [Edge] with a `PromoShare`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type PromoShareHistoryEdge {
  """
    `PromoShare` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: PromoShare!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: PromoShareHistoryCursor!
}

type Query {
  """
    Returns the current authenticated `MyUser`.

    ## Authentication

    Mandatory.
  """
  myUser: MyUser
  """
    Returns all active `Session`s of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `Session`s are sorted primarily by their last activity
    `DateTime`, and secondary by their IDs (if the last activity `DateTime`
    is the same), in descending order.
  """
  sessions: SessionsList!
  """
    Returns a `User` by its `id`.

    ## Authentication

    Optional.
  """
  user("ID of the `User` to be returned." id: UserId!): User
  """
    Returns `User`s by their `ids`.

    ## Authentication

    Optional.
  """
  users("IDs of the `User`s to be returned." ids: [UserId!]!): [User!]!
  """
    Searches `User`s by the provided criteria.

    Exactly one of `num`/`login`/`direct_link`/`name` arguments must be
    specified (be non-`null`).

    Searching by `num`/`login`/`direct_link` is exact.

    Searching by `name` is fuzzy.

    ## Authentication

    Optional.

    ## Sorting

    Returned `User`s are sorted depending on the provided arguments:
    - If one of the `num`/`login`/`direct_link` arguments is specified, then
      an exact `User` is returned.
    - If the `name` argument is specified, then returned `User`s are sorted
      primarily by the [Levenshtein distance][0] of their `name`s,
      secondary by their `name`s (if the [Levenshtein distance][0] is the
      same), and tertiary by their IDs (if the `name`s is the same), in
      descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `User` pointed by the cursor and the
    requested count of `User`s preceding and following it.

    If it's desired to receive the `User`, pointed by the cursor, without
    querying in both directions, one can specify `first` or `last` count as
    `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some parameterized search with a cursor pointing to a
    page of a totally different parameterized search is nonsense and will
    produce an invalid result (usually returning nothing).

    [0]: https://en.wikipedia.org/wiki/Levenshtein_distance
  """
  searchUsers("`UserNum` to search `User`s with." num: UserNum, """
    `UserLogin` to search `User`s with.

    Unimplemented. Do not use it.
  """ login: UserLogin, "`ChatDirectLinkSlug` to search owner of." directLink: ChatDirectLinkSlug, """
    Part of `UserName` to fuzzy search `User` with.

    Unimplemented. Do not use it.
  """ name: UserName, """
    Number of next `UsersEdge`s to return.

    Usable only with `name` argument.
  """ first: Int, """
    Cursor indicating the `UsersEdge` position to return next `UsersEdge`s after.

    Usable only with `name` argument.
  """ after: UsersCursor, """
    Number of prior `UsersEdge`s to return.

    Usable only with `name` argument.
  """ last: Int, """
    Cursor indicating the `UsersEdge` position to return prior `UsersEdge`s before.

    Usable only with `name` argument.
  """ before: UsersCursor): UsersConnection!
  """
    Returns `User`s blocked by the authenticated `MyUser` as
    `BlocklistRecord`s.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `User`s are sorted primarily by their blocking `DateTime`, and
    secondary by their IDs (if the blocking `DateTime` is the same), in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `BlocklistRecord` pointed by the cursor
    and the requested count of `BlocklistRecord`s preceding and following
    it.

    If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.
  """
  blocklist("Number of next `BlocklistRecord`s to return." first: Int, "Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after." after: BlocklistCursor, "Number of prior `BlocklistRecord`s to return." last: Int, "Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before." before: BlocklistCursor): BlocklistConnection!
  """
    Indicates whether the specified `UserLogin` is occupied by some `User`,
    or is free to be used.

    ## Authentication

    Mandatory.
  """
  checkUserLoginOccupied("`UserLogin` to be checked." login: UserLogin!): Boolean!
  """
    Returns a `Chat` by its ID.

    The authenticated `MyUser` should be a member of the `Chat` in order to
    view it.

    ## Authentication

    Mandatory.
  """
  chat("ID of the `Chat` to be returned." id: ChatId!): Chat
  """
    Returns a `ChatItem` by its ID.

    The authenticated `MyUser` should be a member of the `Chat` the provided
    `ChatItem` belongs to, in order to view it.

    ## Authentication

    Mandatory.
  """
  chatItem("ID of the `ChatItem` to be returned." id: ChatItemId!): ChatItemsEdge
  """
    Returns favorite `Chat`s of the authenticated `MyUser` ordered by the
    custom order of `MyUser`'s favorites list (using `Chat.favoritePosition`
    field).

    Use `Mutation.favoriteChat` to update the position of a `Chat` in
    `MyUser`'s favorites list.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `Chat`s are sorted in the order specified by the authenticated
    `MyUser` in `Mutation.favoriteChat` descending (starting from the
    highest `ChatFavoritePosition` and finishing at the lowest).

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `Chat` pointed by the cursor and the
    requested count of `Chat`s preceding and following it.

    If it's desired to receive the `Chat`, pointed by the cursor, without
    querying in both directions, one can specify `first` or `last` count as
    `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.
  """
  favoriteChats("Number of next `Chat`s to return." first: Int, "Cursor indicating the `FavoriteChatsEdge` position to return next `Chat`s after." after: FavoriteChatsCursor, "Number of prior `Chat`s to return." last: Int, "Cursor indicating the `FavoriteChatsEdge` position to return prior `Chat`s before." before: FavoriteChatsCursor): FavoriteChatsConnection!
  """
    Returns non-hidden `Chat`s of the authenticated `MyUser` ordered
    descending by their last updating `DateTime`.

    Use the `with.noFavorite` argument to exclude favorited `Chat`s from the
    returned result.

    Use the `with.ongoingCalls` argument to only include `Chat`s with
    ongoing `ChatCall`s into the returned result (`true`), or to exclude
    them (`false`).

    Use the `with.archived` argument to only include archived `Chat`s into
    the returned result (`true`), or to exclude them (`false`).

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `Chat`s are sorted primarily by their last updating `DateTime`,
    and secondary by their IDs (if the last updating `DateTime` is the
    same), in descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `Chat` pointed by the cursor and the
    requested count of `Chat`s preceding and following it.

    If it's desired to receive the `Chat`, pointed by the cursor, without
    querying in both directions, one can specify `first` or `last` count as
    `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some filtered entries with a cursor pointing to a page
    of totally different filtered entries is nonsense and will produce an
    invalid result (usually returning nothing).
  """
  recentChats("Filter applied to the returned `Chat`s." with: RecentChatsFilter, "Pagination arguments to return the `Chat`s by." pagination: RecentChatsPagination): RecentChatsConnection!
  """
    Returns a list of incoming `ChatCall`s of the authenticated `MyUser`.

    A `ChatCall` is considered incoming when:
    - it's not yet answered or declined (or the authenticated `MyUser` has
      been redialed after it was answered or declined);
    - its `Chat` is not muted by the authenticated `MyUser`;
    - its initiator is not the authenticated `MyUser`.

    This list contains `ChatCall`s which require an immediate action from
    the authenticated `MyUser` and doesn't represent any historical data.

    A new `ChatCall` appears in this list when someone other than the
    authenticated `MyUser` starts it in a `Chat`, and that `Chat` is not
    muted by the authenticated `MyUser`.

    A `ChatCall` is removed from this list when:
    - it has been finished;
    - `MyUser` executes `Mutation.joinChatCall` or
      `Mutation.declineChatCall` on it;
    - `MyUser` executes `Mutation.toggleChatMute` on its `Chat` (or
      `Mutation.toggleMyUserMute` on himself).

    Executing `Mutation.toggleMyUserMute` with `mute` argument (muting)
    makes this list always empty until the consecutive execution of
    `Mutation.toggleMyUserMute` without `mute` argument (unmuting) or
    reaching the mute's deadline.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `ChatCall`s are sorted primarily by their starting `DateTime`,
    and secondary by their IDs (if the starting `DateTime` is the same), in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatCall` pointed by the cursor and the
    requested count of `ChatCall`s preceding and following it.

    If it's desired to receive the `ChatCall`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.
  """
  incomingChatCalls("Number of next incoming `ChatCall`s to return." first: Int, "Cursor indicating the `IncomingChatCallsEdge` position to return next incoming `ChatCall`s after." after: IncomingChatCallsCursor, "Number of prior incoming `ChatCall`s to return." last: Int, "Cursor indicating the `IncomingChatCallsEdge` position to return prior incoming `ChatCall`s before." before: IncomingChatCallsCursor): IncomingChatCallsConnection!
  """
    Returns a `ChatContact` by its ID.

    ## Authentication

    Mandatory.
  """
  chatContact("ID of the `ChatContact` to be returned." id: ChatContactId!): ChatContact @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns address book of the authenticated `MyUser` ordered
    alphabetically by `ChatContact.name`s.

    Use the `noFavorite` argument to exclude favorited `ChatContact`s from
    the returned result.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `ChatContact`s are sorted primarily and alphabetically by their
    `name`s, and secondary by their IDs (if the `name` is the same), in
    ascending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatContact` pointed by the cursor and
    the requested count of `ChatContact`s preceding and following it.

    If it's desired to receive the `ChatContact`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some filtered entries with a cursor pointing to a page
    of totally different filtered entries is nonsense and will produce an
    invalid result (usually returning nothing).
  """
  chatContacts("Number of next `ChatContact`s to return." first: Int, "Cursor indicating the `ChatContactsEdge` position to return next `ChatContact`s after." after: ChatContactsCursor, "Number of prior `ChatContact`s to return." last: Int, "Cursor indicating the `ChatContactsEdge` position to return prior `ChatContact`s before." before: ChatContactsCursor, "Indicator whether favorite `ChatContact`s should be excluded from the result." noFavorite: Boolean = false): ChatContactsConnection! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Searches `ChatContact`s by the provided criteria.

    Exactly one of `name`/`email`/`phone` arguments must be specified (be
    non-`null`).

    Searching by `email`/`phone` is exact.

    Searching by `name` is fuzzy.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `ChatContact`s are sorted depending on the provided arguments:
    - If one of the `email`/`phone` arguments is specified, then returned
      `ChatContact`s are sorted by their `name`s (by IDs if the `name` is
      the same) in ascending order.
    - If the `name` argument is specified, then returned `ChatContact`s are
      sorted primarily by the [Levenshtein distance][0] of their `name`s,
      secondary by their `name`s (if the [Levenshtein distance][0] is the
      same), and tertiary by their IDs (if the `name`s is the same), in
      descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatContact` pointed by the cursor and
    the requested count of `ChatContact`s preceding and following it.

    If it's desired to receive the `ChatContact`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of some parameterized search with a cursor pointing to a
    page of a totally different parameterized search is nonsense and will
    produce an invalid result (usually returning nothing).

    [0]: https://en.wikipedia.org/wiki/Levenshtein_distance
  """
  searchChatContacts("Part of `UserName` to search `ChatContact`s with." name: UserName, "`UserEmail` to search `ChatContact`s with." email: UserEmail, "`UserPhone` to search `ChatContact`s with." phone: UserPhone, "Number of next `ChatContactsEdge`s to return." first: Int, "Cursor indicating the `ChatContactsEdge` position to return next `ChatContactsEdge`s after." after: ChatContactsCursor, "Number of prior `ChatContactsEdge`s to return." last: Int, "Cursor indicating the `ChatContactsEdge` position to return prior `ChatContactsEdge`s before." before: ChatContactsCursor): ChatContactsConnection! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns favorited `ChatContact`s of the authenticated `MyUser` ordered
    by the custom order of `MyUser`'s favorites list (using
    `ChatContact.favoritePosition` field).

    Use `Mutation.favoriteChatContact` to update the position of a
    `ChatContact` in `MyUser`'s favorites list.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `ChatContact`s are sorted in the order specified by the
    authenticated `MyUser` in `Mutation.favoriteChatContact` descending
    (starting from the highest `ChatContactFavoritePosition` and finishing
    at the lowest).

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `ChatContact` pointed by the cursor and
    the requested count of `ChatContact`s preceding and following it.

    If it's desired to receive the `ChatContact`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` parameter will be considered
    as `50`.
  """
  favoriteChatContacts("Number of next `ChatContact`s to return." first: Int, "Cursor indicating the `FavoriteChatContactsEdge` position to return next `ChatContact`s after." after: FavoriteChatContactsCursor, "Number of prior `ChatContact`s to return." last: Int, "Cursor indicating the `FavoriteChatContactsEdge` position to return prior `ChatContact`s before." before: FavoriteChatContactsCursor): FavoriteChatContactsConnection! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns list of `ChatContact`s of the authenticated `MyUser` the
    specified `User` is linked to (one of its `ChatContactRecord`s
    represents this `User`).

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when:
    - No `User` exists with the specified `userId`.

    Query returns empty list when:
    - The specified `User` is not linked to any `ChatContact`s of the
      authenticated `MyUser`.
  """
  linkedChatContacts("ID of the `User` returned `ChatContacts` should be linked to." userId: UserId!): [ChatContact!] @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns the monolog `Chat` of the authenticated `MyUser`.

    If there is no `Chat`-monolog, the one could be created via
    `Mutation.createMonologChat`.

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when no `Chat`-monolog exists for the authenticated
    `MyUser`.
  """
  monolog: Chat
  """
    Returns a dialog `Chat` between the specified `User` and the
    authenticated `MyUser`.

    If there is no such dialog `Chat`, the one could be created via
    `Mutation.createDialogChat`.

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when:
    - No `User` exists with the specified `userId`.
    - No dialog `Chat` exists between the specified `User` and the
      authenticated `MyUser`.
  """
  dialog("ID of the `User` to return a dialog `Chat` with." userId: UserId!): Chat
  """
    Counts a number of mutual `ChatContact`s between the specified `User`
    and the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when:
    - No `User` exists with the specified `userId`.
  """
  mutualChatContactsCount("ID of the `User` to return a number of mutual `ChatContact`s with." userId: UserId!): Int @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Returns the current `PromoShare` of the specified `User` for the
    authenticated `MyUser` (or the one of the authenticated `MyUser` itself,
    if the `ownerId` argument is absent or `null`).

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when:
    - No `User` exists with the specified `ownerId`.
    - The specified `User` has no current `PromoShare` being set.
    - No promotion program is available on this site.
  """
  promoShare("""
    ID of the `User` to return the `PromoShare` of.

    If absent or `null` then the `PromoShare` of the authenticated `MyUser` will be returned.
  """ ownerId: UserId): PromoShare
  """
    Returns history of all `PromoShare`s ever being set of the specified
    `User` (or the authenticated `MyUser`, if the `ownerId` argument is
    absent or `null`).

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `PromoShare`s are sorted by their creation `DateTime` in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `PromoShare` pointed by the cursor and
    the requested count of `PromoShare`s preceding and following it.

    If it's desired to receive the `PromoShare`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` argument will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of entries belonging to one `User` with a cursor pointing
    to a page of entries belonging to a totally different `User` is nonsense
    and will produce an invalid result (usually returning nothing).

    ## Result

    Query returns `null` when:
    - No `User` exists with the specified `ownerId`.
    - No promotion program is available on this site.
  """
  promoShareHistory("""
    ID of the `User` to return the `PromoShare`s history of.

    If absent or `null` then the `PromoShare`s of the authenticated `MyUser` will be returned.
  """ ownerId: UserId, "Pagination arguments to return the `PromoShare`s by." pagination: PromoShareHistoryPagination): PromoShareHistoryConnection
  """
    Returns `MonetizationSettings` of the authenticated `MyUser` filtered by
    the provided criteria.

    Searching `by.userId` is exact, returning:
    - Individual `MonetizationSettings` (if the `by.userId` is different
      from the `MyUser.id`).
    - Common `MonetizationSettings` (if `by.userId` is the `MyUser.id`).

    If no `by` (or `by.userId`) argument is provided, then individual
    `MonetizationSettings` for all `User`s will be returned, also including
    the common ones.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `MonetizationSettings` are sorted depending on the provided
    arguments:
    - If the `by.userId` argument is specified, then exact
      `MonetizationSettings` are returned.
    - Otherwise, the returned `MonetizationSettings` are sorted primarily by
      their `MonetizationSettings.createdAt` field, and secondary by IDs of
      the `User`s they are specified for, in descending order.
  """
  myMonetizationSettings("Filter to search `MonetizationSettings` by." by: MyMonetizationSettingsFilter, """
    Arguments for pagination over returned `MonetizationSettings`.

    Does nothing if the `by.userId` argument is specified.
  """ pagination: MonetizationSettingsPagination): MonetizationSettingsConnection!
  """
    Returns `MonetizationSettings` set by the specified `User` for the
    authenticated `MyUser`.

    If the specified `User` is the authenticated `MyUser`, then effectively
    returns common `MonetizationSettings` of the authenticated `MyUser`
    (applied to all `User`s).

    ## Authentication

    Mandatory.

    ## Result

    Query returns `null` when no `User` exists with the specified `userId`.
  """
  monetizationSettings("ID of the `User` to return `MonetizationSettings` of." userId: UserId!): MonetizationSettings
  """
    Returns an `OperationsEdge` of an `Operation` by its
    `OperationIdentifier`.

    ## Authentication

    Mandatory.
  """
  operation("Identifier of the `Operation` to return." by: OperationIdentifier!): OperationsEdge
  """
    Returns `Operation`s filtered by the provided criteria in the provided
    `OperationOrigin`.

    Searching `by.id` or `by.num` is exact.

    If no `by` argument is provided, then all existing `Operation`s of the
    provided `OperationOrigin` are returned.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `Operation`s are sorted depending on the provided arguments:
    - If the `by.id` argument is specified, then an exact `Operation` is
      returned.
    - If the `by.num` argument is specified, then an exact `Operation` is
      returned.
    - Otherwise, the returned `Operation`s are sorted by their
      `OperationNum` in descending order.
  """
  operations("Origin to return `Operation`s from." origin: OperationOrigin!, "Filter to search `Operation`s by." by: OperationsFilter, """
    Arguments for pagination over returned `Operation`s.

    Does nothing if the `by.id` or `by.num` argument is specified.
  """ pagination: OperationsPagination): OperationsConnection!
  """
    Returns information about available `OperationDepositMethod`s for the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.
  """
  operationDepositMethods: [OperationDepositMethod!]!
  """
    Returns `OperationDepositMethodPricing` of the `OperationDepositMethod`
    by its ID.

    `null` in case the provided `OperationDepositMethod` is unavailable for
    the provided `CountryCode` or for the authenticated `MyUser`.

    ## Authentication

    Mandatory.
  """
  operationDepositMethodPricing("ID of the `OperationDepositMethod` to return the `OperationDepositMethodPricing` for." methodId: OperationDepositMethodId!, """
    Nominal to calculate the returned `OperationDepositMethodPricing` for.

    If absent or `null` then the nominal `1` is assumed.

    Integer-only, meaning that its fractional part should be zero.
  """ nominal: Sum, "`CountryCode` to return the `OperationDepositMethodPricing` for." country: CountryCode!): OperationDepositMethodPricing
  """
    Returns information about available `OperationWithdrawMethod`s for the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.
  """
  operationWithdrawMethods: [OperationWithdrawMethod!]!
  """
    Returns `OperationWithdrawMethodPricing` of an
    `OperationWithdrawMethod`.

    `null` in case the provided `OperationWithdrawMethod` is unavailable for
    the provided `CountryCode` or for the authenticated `MyUser`.

    ## Authentication

    Mandatory.
  """
  operationWithdrawMethodPricing("ID of the `OperationWithdrawMethod` to return the `OperationWithdrawMethodPricing` for." methodId: OperationWithdrawMethodId!, """
    Nominal to calculate the returned `OperationWithdrawMethodPricing` for.

    If absent or `null` then the nominal `1` is assumed.
  """ nominal: Sum, "`CountryCode` to return the `OperationWithdrawMethodPricing` for." country: CountryCode!): OperationWithdrawMethodPricing
  """
    Returns the current `Balance` of the authenticated `MyUser` in the
    provided `BalanceOrigin`.

    ## Authentication

    Mandatory.
  """
  balance("Origin to return the `Balance` of." origin: BalanceOrigin!): Balance!
}

"Error of performing `Mutation.readChat`."
type ReadChatError {
  "Code indicating why this error has happened."
  code: ReadChatErrorCode!
}

"""
  [Connection] with recent `Chat`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type RecentChatsConnection {
  """
    List of `Chat` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [RecentChatsEdge!]!
  """
    List of `Chat`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [Chat!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""
  [Edge] with a recent `Chat`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type RecentChatsEdge {
  """
    `Chat` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: Chat!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: RecentChatsCursor!
}

"""
  Initial top of `Query.recentChats` list emitted by
  `Subscription.recentChatsTopEvents`.
"""
type RecentChatsTop {
  """
    List of top `Chat`s.

    ## Sorting

    Returned `Chat`s are sorted primarily by their last updating `DateTime`,
    and secondary by their IDs (if the last updating `DateTime` is the
    same), in descending order.
  """
  list: [RecentChatsEdge!]!
}

"Error of performing `Mutation.redialChatCallMember`."
type RedialChatCallMemberError {
  "Code indicating why this error has happened."
  code: RedialChatCallMemberErrorCode!
}

"Error of performing `Mutation.refreshSession`."
type RefreshSessionError {
  "Code indicating why this error has happened."
  code: RefreshSessionErrorCode!
}

"Token used for refreshing a `Session`."
type RefreshToken {
  """
    Secret part of this `RefreshToken`.

    This one should be used for refreshing the `Session` via
    `Mutation.refreshSession` and is **NOT** usable as a
    [Bearer authentication token][1].

    [1]: https://tools.ietf.org/html/rfc6750#section-2.1
  """
  secret: RefreshTokenSecret!
  """
    `DateTime` of this `RefreshToken` expiration.

    Once expired, it's not usable anymore and a new `Session` should be
    created via `Mutation.createSession` to get a new `RefreshToken`.

    Client applications are supposed to use this field for tracking
    `RefreshToken`'s expiration and sign out `MyUser`s properly.

    Expiration of a `RefreshToken` is not prolonged on refreshing, and
    remains the same for all the `RefreshToken`s obtained via
    `Mutation.refreshSession`. Use the `Mutation.createSession` to obtain a
    `RefreshToken` with new expiration.
  """
  expiresAt: DateTime!
}

"Error of performing `Mutation.removeChatCallMember`."
type RemoveChatCallMemberError {
  "Code indicating why this error has happened."
  code: RemoveChatCallMemberErrorCode!
}

"Error of performing `Mutation.removeChatMember`."
type RemoveChatMemberError {
  "Code indicating why this error has happened."
  code: RemoveChatMemberErrorCode!
}

"Error of performing `Mutation.removeUserEmail`."
type RemoveUserEmailError {
  "Code indicating why this error has happened."
  code: RemoveUserEmailErrorCode!
}

"Error of performing `Mutation.removeUserPhone`."
type RemoveUserPhoneError {
  "Code indicating why this error has happened."
  code: RemoveUserPhoneErrorCode!
}

"Error of performing `Mutation.renameChat`."
type RenameChatError {
  "Code indicating why this error has happened."
  code: RenameChatErrorCode!
}

"Session of a `MyUser` being signed-in."
type Session {
  "Unique ID of this `Session`."
  id: SessionId!
  "`SiteDomain` of the `Site` this `Session` was created on."
  siteDomain: SiteDomain!
  "`UserAgent` of the device, that used this `Session` last time."
  userAgent: UserAgent!
  "`IP` of the device, that used this `Session` last time."
  ip: IP!
  """
    `DateTime` when this `Session` was activated last time (either created
    or refreshed).
  """
  lastActivatedAt: DateTime!
  """
    Version of this `Session`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: SessionVersion!
}

"""
  `SessionEvent`s along with the corresponding `SessionVersion` and
  `SessionsListVersion`.
"""
type SessionEventsVersioned {
  "`SessionEvent`s themselves."
  events: [SessionEvent!]!
  """
    Version of the `Session` state updated by these `SessionEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking concrete `Session` state's actuality.

    If the `events` contain `SessionEvent`s related to different `Session`s,
    then this version is applicable for all of them.
  """
  ver: SessionVersion!
  """
    Version of the `SessionsList` state updated by these `SessionEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking list state's actuality.

    Also, intended to be used in `Subscription.sessionsEvents`.
  """
  listVer: SessionsListVersion!
}

"Represents `Session`s list of a `User`."
type SessionsList {
  """
    List of `Session`s.

    ## Sorting

    Returned `Session`s are sorted primarily by their last activity
    `DateTime`, and secondary by their IDs (if the last activity `DateTime`
    is the same), in descending order.
  """
  list: [Session!]!
  "Version of this `Session`s list."
  listVer: SessionsListVersion!
}

"Error of performing `Mutation.startChatCall`."
type StartChatCallError {
  "Code indicating why this error has happened."
  code: StartChatCallErrorCode!
}

"Result of a successful performing `Mutation.startChatCall`."
type StartChatCallOk {
  """
    ID of the device the authenticated `MyUser` started the `ChatCall` from.

    Use this ID in `Subscription.chatCallEvents` and
    `Mutation.leaveChatCall` to distinguish between different devices of the
    authenticated `MyUser`.
  """
  deviceId: ChatCallDeviceId!
  """
    The only `ChatEvent`s which may be produced by performing
    `Mutation.startChatCall`:
    - `EventChatItemPosted` (if no `ChatCall` exists);
    - `EventChatCallStarted` (if no `ChatCall` exists);
    - `EventChatCallMemberJoined` (if `ChatCall` exists already).

    `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

type Subscription {
  """
    Subscribes to `SessionEvent`s of all `Session`s of the authenticated
    `MyUser`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `Session`s list will be emitted after `SubscriptionInitialized`
    and before any other `SessionEvent`s (and won't be emitted ever
    again until this subscription completes). This allows to skip doing
    `Query.sessions` before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.sessions`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `Session`s list).

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some
    `Session`, so a client side is expected to handle all the events
    idempotently considering the `Session.ver`.
  """
  sessionsEvents("""
    Version of a `Session`s list to start returning `SessionEvent`s from.

    Get it from `Query.sessions.ver`.


    If omitted (or is `null`) then an initial state of the `Session`s list will be emitted after `SubscriptionInitialized` and before any other `SessionEvent`s.
  """ ver: SessionsListVersion): SessionsEvents!
  """
    Subscribes to `UserEvent`s of the specified `User`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`, or immediately completes (without emitting
    anything) if such `User` doesn't exist.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `User` will be emitted after `SubscriptionInitialized` and before
    any other `UserEvent`s (and won't be emitted ever again until this
    subscription completes). This allows to skip doing `Query.user` before
    establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.user`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `User`).

    ## Completion

    Finite.

    Completes without re-subscription necessity when:
    - The specified `User` is deleted (emits `EventUserDeleted` and
      completes).
    - The specified `User` doesn't exist (emits nothing, completes
      immediately after being established).

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    This subscription could emit the same `EventUserDeleted` multiple times,
    so a client side is expected to handle it idempotently considering the
    `User.ver`.
  """
  userEvents("ID of the `User` to subscribe onto." id: UserId!, """
    `User.ver` to start returning `UserEvent`s from.

    If omitted (or is `null`) then an initial state of the `User` will be emitted after `SubscriptionInitialized` and before any other `UserEvent`s.
  """ ver: UserVersion): UserEvents!
  """
    Subscribes to `MyUserEvent`s of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the authenticated `MyUser` will be emitted after
    `SubscriptionInitialized` and before any other `MyUserEvent`s (and won't
    be emitted ever again until this subscription completes). This allows to
    skip calling `Query.myUser` before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.myUser`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `MyUser`).

    ## Completion

    Finite.

    Completes without re-subscription necessity when:
    - The authenticated `MyUser` is deleted (emits `EventUserDeleted` and
      completes).

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    This subscription could emit the same `EventUserDeleted` multiple times,
    so a client side is expected to handle it idempotently considering the
    `MyUser.ver`.
  """
  myUserEvents("""
    `MyUser.ver` to start returning `MyUserEvent`s from.

    If omitted (or is `null`) then an initial state of the `MyUser` will be emitted after `SubscriptionInitialized` and before any other `MyUserEvent`s.
  """ ver: MyUserVersion): MyUserEvents!
  """
    Subscribes to `BlocklistEvent`s of the authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `Blocklist` will be emitted after `SubscriptionInitialized` and
    before any other `BlocklistEvent`s (and won't be emitted ever again
    until this subscription completes). This allows to skip calling
    `Query.blocklist` before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.blocklist`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `Blocklist`).

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some
    `BlocklistRecord`, so a client side is expected to handle all the events
    idempotently considering the `BlocklistRecord.ver`.
  """
  blocklistEvents("""
    `BlocklistConnection.ver` to start returning `BlocklistEvent`s from.

    If omitted (or is `null`) then an initial state of the `Blocklist` will be emitted after `SubscriptionInitialized` and before any other `BlocklistEvent`s.
  """ ver: BlocklistVersion): BlocklistEvents!
  """
    Keeps the authenticated `MyUser` online while subscribed.

    Keep this subscription up while the authenticated `MyUser` should be
    considered as online. Once this subscription begins `User.online` of
    `MyUser` becomes `UserOnline`, and once ends sets it to `UserOffline`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  keepOnline: SubscriptionInitialized!
  """
    Subscribes to updates of top `count` items of `Query.recentChats` list.

    Note, that `EventRecentChatsTopChatUpdated` informs about a `Chat`
    becoming the topmost in `Query.recentChats` list, but never about a
    `Chat` being updated itself.

    Note, that `EventRecentChatsTopChatRemoved` informs about a `Chat` being
    removed from the top `count` items of the `Query.recentChats` list, but
    never about a `Chat` being removed itself.

    Instead, use `Subscription.chatEvents` for being informed correctly
    about `Chat` changes.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized` followed by the initial state of the
    `RecentChatsTop` list (and they won't be emitted ever again until this
    subscription completes). Note, that emitting an empty list is possible
    valid.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  recentChatsTopEvents("Filter to subscribe for `Chat`s updates with." with: RecentChatsFilter, """
    Count of top recent `Chat`s to receive updates for. Value must be in range from 1 to 100.

    Usually, you need just pass the count of `ChatConnection.nodes` returned by `Query.recentChats`.
  """ count: Int!): RecentChatsTopEvents!
  """
    Subscribes to `FavoriteChatsEvent`s of all `Chat`s of the authenticated
    `MyUser`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `FavoriteChatsList` will be emitted after `SubscriptionInitialized`
    and before any other `FavoriteChatsEvent`s (and won't be emitted ever
    again until this subscription completes). This allows to skip doing
    `Query.favoriteChats` before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.favoriteChats`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `FavoriteChatsList`).

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some `Chat`, so a
    client side is expected to handle all the events idempotently
    considering the `Chat.ver`.
  """
  favoriteChatsEvents("""
    Version of a `FavoriteChatsList` to start returning `FavoriteChatsEvent`s from.

    Get it from `Query.favoriteChats.ver`.

    If omitted (or is `null`) then an initial state of the `FavoriteChatsList` will be emitted after `SubscriptionInitialized` and before any other `FavoriteChatsEvent`.
  """ ver: FavoriteChatsListVersion): FavoriteChatsEvents!
  """
    Subscribes to updates of top `count` items of `Query.incomingChatCalls`
    list.

    Note, that `EventIncomingChatCallsTopChatCallAdded` informs about a
    `ChatCall` becoming the topmost in `Query.incomingChatCalls` list, but
    never about a `ChatCall` being updated itself.

    Note, that `EventIncomingChatCallsTopChatCallRemoved` informs about a
    `ChatCall` being removed from top `count` items of
    `Query.incomingChatCalls` list, but never about a `ChatCall` being
    finished or removed itself.

    Instead, use `Subscription.chatCallEvents` for being informed correctly
    about `ChatCall` changes, and `Subscription.chatEvents` for being
    informed correctly about new `ChatCall`s happening in a `Chat`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized` followed by the initial state of the
    `IncomingChatCallsTop` list (and they won't be emitted ever again until
    this subscription completes). Note, that emitting an empty list is
    possible valid.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  incomingChatCallsTopEvents("""
    Count of top incoming `ChatCall`s to receive updates for. Value must be in range from 1 to 100.

    Usually, you need just pass the count of `IncomingChatCallConnection.nodes` returned by `Query.incomingChatCalls`.
  """ count: Int!): IncomingChatCallsTopEvents!
  """
    Subscribes to `ChatEvent`s of the specified `Chat`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`, or immediately completes (without emitting
    anything) if such `Chat` doesn't exist or `MyUser` doesn't participate
    in it.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `Chat` will be emitted after `SubscriptionInitialized` and before
    any other `ChatEvent`s (and won't be emitted ever again until this
    subscription completes). This allows to skip doing `Query.chat` (or
    `Query.recentChats`) before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.chat` (or
      `Query.recentChats`);
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `Chat`).

    ## Completion

    Finite.

    Completes without re-subscription necessity when:
    - The `Chat` does not exist (emits nothing, completes immediately after
      being established).
    - The authenticated `MyUser` is not a member of the `Chat` at the moment
      of subscribing (emits nothing, completes immediately after being
      established).
    - The authenticated `MyUser` is no longer a member of the `Chat` (emits
      an `EventChatItemPosted` of a `ChatInfo` with
      `ChatInfoActionMemberRemoved` and completes).

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  chatEvents("ID of the `Chat` to subscribe onto." id: ChatId!, """
    `Chat.ver` to start returning `ChatEvent`s from.

    If omitted (or is `null`) then an initial state of the `Chat` will be emitted after `SubscriptionInitialized` and before any other `ChatEvent`s.
  """ ver: ChatVersion): ChatEvents!
  """
    Subscribes to `ChatCallEvent`s of a `ChatCall`.

    This subscription is mandatory to be created after (and only after)
    executing `Mutation.startChatCall` or `Mutation.joinChatCall` as
    represents a heartbeat indication of the authenticated `MyUser`'s
    participation in a `ChatCall`. Stopping or breaking this subscription
    without leaving a `ChatCall` will end up by kicking the authenticated
    `MyUser` from the `ChatCall` by timeout (if not re-established earlier).

    Once this subscription kicks the authenticated `MyUser` from the
    `ChatCall` by timeout, it automatically lowers his hand raised by
    `Mutation.toggleChatCallHand`, if no other `MyUser`'s devices are
    participating in this `ChatCall` at the moment.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized` followed by the initial state of the
    `ChatCall` (and they won't be emitted ever again until this subscription
    completes), or immediately completes without emitting anything, if such
    `ChatCall` hasn't been found or the authenticated `MyUser` doesn't
    participate in it.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Completion

    Finite.

    Completes without re-subscription necessity when:
    - The `ChatCall` is finished (`EventChatCallFinished` is emitted).
    - The authenticated `MyUser` is no longer a member of the `ChatCall`
      (`EventChatCallMemberLeft` is emitted for the the authenticated
      `MyUser`).
    - The `ChatCall` is not found or the authenticated `MyUser` doesn't
      participate in it from the specified `MyUser`'s device (emits nothing,
      completes immediately after being established).

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  chatCallEvents("ID of the ongoing `ChatCall` to subscribe onto." id: ChatItemId!, """
    ID of the `MyUser`'s device to subscribe to the ongoing `ChatCall` events from.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
  """ deviceId: ChatCallDeviceId!): ChatCallEvents!
  """
    Subscribes to `ChatContactEvent`s of all `ChatContact`s of the
    authenticated `MyUser`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `ChatContact`s list will be emitted after `SubscriptionInitialized`
    and before any other `ChatContactEvent`s (and won't be emitted ever
    again until this subscription completes). This allows to skip doing
    `Query.chatContacts` (or `Query.favoriteChatContacts`) before
    establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.chatContacts` (or
      `Query.favoriteChatContacts`);
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `ChatContact`s list).

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some
    `ChatContact`, so a client side is expected to handle all the events
    idempotently considering the `ChatContact.ver`.
  """
  chatContactsEvents("""
    Version of a `ChatContact`s list to start returning `ChatContactEvent`s from.

    Get it either from `Query.chatContacts.ver` or `Query.favoriteChatContacts.ver`.

    If omitted (or is `null`) then an initial state of the `ChatContact`s list will be emitted after `SubscriptionInitialized` and before any other `ChatContactEvent`s.
  """ ver: ChatContactsListVersion): ChatContactsEvents! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Notifies `ChatMember`s subscribed to `Subscription.chatTypings` about
    the authenticated `MyUser` being typing in the `Chat` at the moment.

    Keep this subscription up while the authenticated `MyUser` is typing.
    Once this subscription begins `Subscription.chatTypings` emits
    `EventChatTypingStarted`, and `EventChatTypingStopped` once it ends.

    Makes no sense for the `Chat`-monolog of the authenticated `MyUser`, so
    emits `MONOLOG` error on initialization in such case.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).
  """
  keepTyping("ID of the `Chat` to type in." chatId: ChatId!): SubscriptionInitialized!
  """
    Subscribes to `PromoShareEvent`s of the specified `User` for the
    authenticated `MyUser` (or the ones of the authenticated `MyUser`
    itself, if the `ownerId` argument is absent or `null`).

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) the current
    `UserPromoShare` of the `User` will be emitted after
    `SubscriptionInitialized` and before any other `PromoShareEvents`s (and
    won't be emitted ever again until this subscription completes). This
    allows to skip doing `Query.promoShare` (or `Query.promoShareHistory`)
    before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.promoShare` (or
      `Query.promoShareHistory`);
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted current
      `UserPromoShare` of the `User`).

    ## Completion

    Finite.

    Completes without re-subscription necessity when:
    - The `User` does not exist or is deleted (emits nothing, completes
      immediately after being established, or once the `User` is deleted).
    - No promotion program is available on this site (emits nothing,
      completes immediately after being established).

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied, so a client side is expected to
    handle all the events idempotently considering the `PromoShareVersion`.
  """
  promoShareEvents("""
    ID of the `User` to emit the `PromoShareEvent`s of.

    If absent or `null` then the `PromoShareEvent`s of the authenticated `MyUser` will be emitted.
  """ ownerId: UserId, """
    Version of a `PromoShare` to start returning `PromoShareEvent`s from.

    Get it either from `Query.promoShare.ver` or `Query.promoShareHistory.ver`.

    If omitted (or is `null`) then the current `UserPromoShare` of the `User` will be emitted after `SubscriptionInitialized` and before any other `PromoShareEvent`s.
  """ ver: PromoShareVersion): PromoShareEvents!
  """
    Subscribes to `OperationEvent`s happening in the provided
    `OperationOrigin`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    If `ver` argument is not specified (or is `null`) an initial state of
    the `OperationsList` will be emitted after `SubscriptionInitialized` and
    before any other `OperationEvent`s (and won't be emitted ever again
    until this subscription completes). This allows to skip calling
    `Query.operations` before establishing this subscription.

    If the specified `ver` is not fresh (was queried quite a time ago), it
    may become stale, so this subscription will return `STALE_VERSION` error
    on initialization. In such case:
    - either a fresh version should be obtained via `Query.operations`;
    - or a re-subscription should be done without specifying a `ver`
      argument (so the fresh `ver` may be obtained in the emitted initial
      state of the `OperationsList`).

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some `Operation`,
    so a client side is expected to handle all the events idempotently
    considering the `Operation.ver`.
  """
  operationsEvents("Origin of the `Operation`s to subscribe for." origin: OperationOrigin!, """
    `OperationsConnection.ver` to start returning `OperationEvent`s from.

    If omitted (or is `null`) then an initial state of the `Operations` will be emitted after `SubscriptionInitialized` and before any other `OperationEvent`s.
  """ ver: OperationVersion): OperationsEvents!
  """
    Subscribes to `MonetizationSettingEvent`s set by/for the authenticated
    `MyUser`.

    If the `userId` argument is absent or `null`, or equals to the
    `MyUser.id`, then events for `MonetizationSettings` set **by** the
    authenticated `MyUser` are emitted (both common and individual).

    If the `userId` argument  specified, and differs from the `MyUser.id`,
    then only events for `MonetizationSettings` set **for** the
    authenticated `MyUser` by that `User` are emitted.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    An initial state of the `MonetizationSettingsList` will be emitted after
    `SubscriptionInitialized` and before any other
    `MonetizationSettingsEvent`s (and won't be emitted ever again until this
    subscription completes). This allows to skip calling
    `Query.monetizationSettings` (or `Query.myMonetizationSettings`) before
    establishing this subscription.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some
    `MonetizationSettings`, so a client side is expected to handle all the
    events idempotently considering the `MonetizationSettings.ver`.
  """
  monetizationSettingsEvents("""
    ID of the `User` to subscribe `MonetizationSettingsEvent`s of.

    If absent or `null` then `MyUser.id` is assumed.
  """ userId: UserId, "Filter for subscribing to `MonetizationSettingsEvent`s." by: MonetizationSettingsFilter): MonetizationSettingsEvents!
  """
    Subscribes to `MonetizationSettingEvent`s of the `MonetizationSettings`
    set by the authenticated `MyUser` (both common and individual ones).

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    An initial state of the `MonetizationSettingsList` will be emitted after
    `SubscriptionInitialized` and before any other
    `MonetizationSettingsEvent`s (and won't be emitted ever again until this
    subscription completes). This allows to skip calling
    `Query.myMonetizationSettings` before establishing this subscription.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    It's possible that in rare scenarios this subscription could emit an
    event which have already been applied to the state of some
    `MonetizationSettings`, so a client side is expected to handle all the
    events idempotently considering the `MonetizationSettings.ver`.
  """
  myMonetizationSettingsEvents("Filter for subscribing to `MonetizationSettingsEvent`s." by: MonetizationSettingsFilter): MonetizationSettingsEvents!
  """
    Subscribes to `Balance` updates of the authenticated `MyUser` in the
    provided `BalanceOrigin`.

    ## Authentication

    Mandatory.

    ## Initialization

    Once this subscription is initialized completely, it immediately emits
    `SubscriptionInitialized`.

    If nothing has been emitted for a long period of time after establishing
    this subscription (while not being completed), it should be considered
    as an unexpected server error. This fact can be used on a client side to
    decide whether this subscription has been initialized successfully.

    ## Result

    Initial `Balance` will be emitted after `SubscriptionInitialized`. This
    allows to skip calling `Query.balance` before establishing this
    subscription.

    ## Completion

    Infinite.

    Completes requiring a re-subscription when:
    - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
    - An error occurs on the server (error is emitted).
    - The server is shutting down or becoming unreachable (unexpectedly
      completes after initialization).

    ## Idempotency

    Emits only changed `Balance` against the previously emitted one, so a
    client side is expected to handle all the updates idempotently using the
    same logic.
  """
  balanceUpdates("Origin of the `Balance` to subscribe to." origin: BalanceOrigin!): BalanceUpdate!
}

"""
  Indicator notifying about a GraphQL subscription being successfully
  initialized.
"""
type SubscriptionInitialized {
  "Always `true`."
  ok: Boolean!
}

"Error of performing `Mutation.toggleChatArchivation`."
type ToggleChatArchivationError {
  "Code indicating why this error has happened."
  code: ToggleChatArchivationErrorCode!
}

"Error of performing `Mutation.toggleChatCallHand`."
type ToggleChatCallHandError {
  "Code indicating why this error has happened."
  code: ToggleChatCallHandErrorCode!
}

"Error of performing `Mutation.toggleChatMute`."
type ToggleChatMuteError {
  "Code indicating why this error has happened."
  code: ToggleChatMuteErrorCode!
}

"Error of performing `Mutation.toggleMyUserMute`."
type ToggleMyUserMuteError {
  "Code indicating why this error has happened."
  code: ToggleMyUserMuteErrorCode!
}

"Error of performing `Mutation.transformDialogCallIntoGroupCall`."
type TransformDialogCallIntoGroupCallError {
  "Code indicating why this error has happened."
  code: TransformDialogCallIntoGroupCallErrorCode!
}

"Error of performing `Mutation.unblockUser`."
type UnblockUserError {
  "Code indicating why this error has happened."
  code: UnblockUserErrorCode!
}

"Error of performing `Mutation.unfavoriteChatContact`."
type UnfavoriteChatContactError {
  "Code indicating why this error has happened."
  code: UnfavoriteChatContactErrorCode!
}

"Error of performing `Mutation.unfavoriteChat`."
type UnfavoriteChatError {
  "Code indicating why this error has happened."
  code: UnfavoriteChatErrorCode!
}

"Error of performing `Mutation.updateChatAvatar`."
type UpdateChatAvatarError {
  "Code indicating why this error has happened."
  code: UpdateChatAvatarErrorCode!
}

"Error of performing `Mutation.updateChatContactName`."
type UpdateChatContactNameError {
  "Code indicating why this error has happened."
  code: UpdateChatContactNameErrorCode!
}

"Error of performing `Mutation.updateMonetizationSettings`."
type UpdateMonetizationSettingsError {
  "Code indicating why this error has happened."
  code: UpdateMonetizationSettingsErrorCode!
}

"Error of performing `Mutation.updateUserAvatar`."
type UpdateUserAvatarError {
  "Code indicating why this error has happened."
  code: UpdateUserAvatarErrorCode!
}

"Error of performing `Mutation.updateUserCallCover`."
type UpdateUserCallCoverError {
  "Code indicating why this error has happened."
  code: UpdateUserCallCoverErrorCode!
}

"Error of performing `Mutation.updateUserLogin`."
type UpdateUserLoginError {
  "Code indicating why this error has happened."
  code: UpdateUserLoginErrorCode!
}

"Error of performing `Mutation.updateUserPassword`."
type UpdateUserPasswordError {
  "Code indicating why this error has happened."
  code: UpdateUserPasswordErrorCode!
}

"Error of performing `Mutation.updateWelcomeMessage`."
type UpdateWelcomeMessageError {
  "Code indicating why this error has happened."
  code: UpdateWelcomeMessageErrorCode!
}

"Error of performing `Mutation.uploadAttachment`."
type UploadAttachmentError {
  "Code indicating why this error has happened."
  code: UploadAttachmentErrorCode!
}

"Result of a successful performing `Mutation.uploadAttachment`."
type UploadAttachmentOk {
  "Uploaded `Attachment`."
  attachment: Attachment!
}

"Error of performing `Mutation.useChatDirectLink`."
type UseChatDirectLinkError {
  "Code indicating why this error has happened."
  code: UseChatDirectLinkErrorCode!
}

"Result of a successful performing `Mutation.useChatDirectLink`."
type UseChatDirectLinkOk {
  "Created or modified `Chat`."
  chat: Chat!
  """
    The only `ChatEvent` which may be produced by performing
    `Mutation.useChatDirectLink`:
    - `EventChatItemPosted` (`ChatInfo` with either `ChatInfoActionCreated`
      or `ChatInfoActionMemberAdded`).

    `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

"User of a system impersonating a real person."
type User {
  """
    Unique ID of this `User`.

    Once assigned it never changes.
  """
  id: UserId!
  """
    Unique number of this `User`.

    `num` is intended for easier `User` identification by other `User`s.
    It's just like a telephone number in a real life.

    It may be reused by another `User` in the future, once this `User`
    becomes unreachable (sign-in for this `User` is impossible).
  """
  num: UserNum!
  """
    Name of this `User`.

    `name` of a `User` is not unique and is intended for displaying an
    `User` in a well-readable form for an easier `User` identification by
    other `User`s.

    `User` is free to choose how exactly he should be displayed for other
    `User`s.
  """
  name: UserName
  "Arbitrary descriptive information about this `User`."
  bio: UserBio
  """
    Avatar of this `User`.

    `avatar` is an image helping to identify a `User` visually.
  """
  avatar: UserAvatar
  """
    Call cover of this `User`.

    `callCover` is an image helping to identify a `User` visually in
    `ChatCall`s.
  """
  callCover: UserCallCover
  """
    Number of mutual `ChatContact`s between this `User` and the
    authenticated `MyUser`.

    Shortcut for `Query.mutualChatContactsCount` with `userId` of this
    `User`, so is not considered in the `User.ver` field.
  """
  mutualContactsCount: Int! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    List of `ChatContact`s of the authenticated `MyUser` this `User` is
    linked to (one of its `ChatContactRecord`s represents this `User`).

    Shortcut for `Query.linkedChatContacts` with `userId` of this `User`, so
    is not considered in the `User.ver` field.
  """
  contacts: [ChatContact!]! @deprecated(reason: "Unimplemented. Do not use it.")
  """
    Online state of this `User`.

    Returns `null` if this `User` hid his `online` state.

    `User` is considered to be online, while he is subscribed to
    `Subscription.keepOnline`.
  """
  online: UserOnlineState
  """
    `UserPresence` of this `User`.

    Returns `null` if this `User` hid his `UserPresence`.
  """
  presence: UserPresence
  "Custom text status of this `User`."
  status: UserTextStatus
  "Indicator whether this `User` is deleted."
  isDeleted: Boolean!
  """
    Dialog `Chat` between this `User` and the authenticated `MyUser`.

    Shortcut for `Query.dialog` with `userId` of this `User`, so is not
    considered in the `User.ver` field.
  """
  dialog: Chat
  "Indicator whether this `User` is blocked by the authenticated `MyUser`."
  isBlocked: IsBlocked!
  "`WelcomeMessage` of this `User`."
  welcomeMessage: WelcomeMessage
  """
    Promotion program parameters of this `User`.

    ## Authentication

    Mandatory.

    ## Result

    Returns `null` when:
    - This `User` is deleted.
    - No promotion program is available on this site.

    ## Versioning

    Returned `UserPromo.share` field is versioned by its own
    `PromoShareVersion` and not by the `UserVersion` of this `User`.
  """
  promo: UserPromo
  """
    `MonetizationSettingsEdge` of `MonetizationSettings` the authenticated
    `MyUser` set for this `User` individually.

    Alias of the `Query.myMonetizationSettings` with the `by.userId`
    argument specified.

    ## Authentication

    Mandatory.

    ## Result

    Returns `null` when no `MonetizationSettings` are set individually for
    this `User`.

    ## Versioning

    Returned `User.myMonetizationSettings` field is versioned by its own
    `MonetizationSettingsVersion` and not by the `UserVersion` of this
    `User`.
  """
  myMonetizationSettings: MonetizationSettingsEdge
  """
    Monetization settings set by this `User` for the authenticated `MyUser`.

    If this `User` is the authenticated `MyUser`, then effectively returns
    common `MonetizationSettings` of the authenticated `MyUser` (applied to
    all `User`s).

    Alias of the `Query.monetizationSettings`.

    ## Authentication

    Mandatory.

    ## Versioning

    Returned `User.monetizationSettings` field is versioned by its own
    `MonetizationSettingsVersion` and not by the `UserVersion` of this
    `User`.
  """
  monetizationSettings: MonetizationSettings!
  """
    Version of this `User`'s state.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: UserVersion!
}

"Avatar of a `User`."
type UserAvatar {
  """
    `CropArea` applied to the `original` `ImageFile` for creating this
    `UserAvatar`.
  """
  crop: CropArea
  "Original `ImageFile` representing this `UserAvatar`."
  original: ImageFile!
  """
    Full-sized `ImageFile` representing this `UserAvatar`, keeping the
    `original` dimensions.
  """
  full: ImageFile!
  """
    `big` view `ImageFile` of this `UserAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to
    `250px`x`250px`.
  """
  big: ImageFile!
  """
    `medium` view `ImageFile` of this `UserAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to
    `100px`x`100px`.
  """
  medium: ImageFile!
  """
    `small` view `ImageFile` of this `UserAvatar`, square-cropped to its
    minimum dimension (either width or height), and scaled to `46px`x`46px`.
  """
  small: ImageFile!
}

"Call cover of a `User`."
type UserCallCover {
  """
    `CropArea` applied to the `original` `ImageFile` for creating this
    `UserCallCover`.
  """
  crop: CropArea
  "Original `ImageFile` representing this `UserCallCover`."
  original: ImageFile!
  """
    Full-sized `ImageFile` representing this `UserCallCover`, keeping the
    `original` dimensions.
  """
  full: ImageFile!
  """
    `vertical` view `ImageFile` of this `UserCallCover`, rectangular-cropped
    to its minimum dimension (either width or height), and proportionally
    scaled to `675px`x`900px`.
  """
  vertical: ImageFile!
  """
    `square` view `ImageFile` of this `UserCallCover`, square-cropped to its
    minimum dimension (either width or height), and scaled to
    `300px`x`300px`.
  """
  square: ImageFile!
}

"List of `UserEmail` addresses associated with a `User`."
type UserEmails {
  """
    List of already confirmed `UserEmail` addresses.

    Any `confirmed` `UserEmail` address can be used in combination with
    `password` to sign in a `MyUser`.

    All `confirmed` `UserEmail` addresses can be used for a `password`
    recovery.
  """
  confirmed: [UserEmail!]!
  """
    `UserEmail` address that still requires a confirmation.

    `unconfirmed` `UserEmail` address doesn't provide any functionality like
    `confirmed` ones do.

    `unconfirmed` `UserEmail` address is moved to `confirmed` ones only
    after completion of the confirmation process via `Mutation.addUserEmail`
    (with the `confirmation` argument provided).
  """
  unconfirmed: UserEmail
}

"`UserEvent` along with the corresponding `UserVersion`."
type UserEventsVersioned {
  "`UserEvent`s themselves."
  events: [UserEvent!]!
  """
    Actual state of the `User` after the `UserEvent`s have been emitted (so
    the returned `User.ver` may differ from these
    `UserEventsVersioned.ver`).
  """
  user: User!
  """
    Version of the `User`'s state updated by these `UserEvent`s.

    It increases monotonically, so may be used (and is intended to) for
    tracking state's actuality.
  """
  ver: UserVersion!
}

"State of a `User` to be offline at the moment."
type UserOffline {
  """
    `DateTime` when the `User` was seen online last time.

    `null` if the `User` was never seen online before.
  """
  lastSeenAt: DateTime
}

"State of a `User` to be online at the moment."
type UserOnline {
  """
    Indicates that the `User` is online at the moment.

    Always `true`.
  """
  online: Boolean!
}

"List of `UserPhone` numbers associated with a `MyUser`."
type UserPhones {
  """
    List of already confirmed `UserPhone` numbers.

    Any `confirmed` `UserPhone` number can be used in combination with
    `password` to sign-in a `MyUser`.

    All `confirmed` `UserPhone` numbers can be used for a `password`
    recovery.
  """
  confirmed: [UserPhone!]!
  """
    `UserPhone` number that still requires a confirmation.

    `unconfirmed` `UserPhone` number doesn't provide any functionality like
    `confirmed` ones do.

    `unconfirmed` `UserPhone` number is moved to `confirmed` ones only after
    completion of the confirmation process via `Mutation.addUserPhone` (with
    the `confirmation` argument provided).
  """
  unconfirmed: UserPhone
}

"Promotion program parameters of a `User` (or `MyUser)`."
type UserPromo {
  "Current `PromoShare` of a `User`, along with its history."
  share: UserPromoShare!
}

"Current `PromoShare` of a `User` (or `MyUser`), along with its history."
type UserPromoShare {
  """
    Current `PromoShare` of the `User`, if set.

    Alias of `Query.promoShare`.

    ## Authentication

    Mandatory.

    ## Result

    Returns `null` when no `PromoShare` is set at the moment.

    ## Versioning

    Returned `PromoShare` is versioned by its own `PromoShareVersion` and
    not by the `UserVersion` (or `MyUserVersion`) of the `User` (or
    `MyUser`).
  """
  current: PromoShare
  """
    History of all `PromoShare`s ever being set of the `User`.

    Alias of `Query.promoShareHistory`.

    ## Authentication

    Mandatory.

    ## Sorting

    Returned `PromoShare`s are sorted by their creation `DateTime` in
    descending order.

    ## Pagination

    It's allowed to specify both `first` and `last` counts at the same time,
    provided that `after` and `before` cursors are equal. In such case the
    returned page will include the `PromoShare` pointed by the cursor and
    the requested count of `PromoShare`s preceding and following it.

    If it's desired to receive the `PromoShare`, pointed by the cursor,
    without querying in both directions, one can specify `first` or `last`
    count as `0`.

    If no arguments are provided, then `first` argument will be considered
    as `50`.

    `after` and `before` cursors are only meaningful once other
    non-`pagination` arguments remain the same between queries. Trying to
    query a page of entries belonging to one `User` with a cursor pointing
    to a page of entries belonging to a totally different `User` is nonsense
    and will produce an invalid result (usually returning nothing).

    ## Result

    Returns `null` when:
    - No promotion program is available on this site.

    ## Versioning

    Returned `PromoShare`s are versioned by its own `PromoShareVersion` and
    not by the `UserVersion` (or `MyUserVersion`) of the `User` (or
    `MyUser`).
  """
  history("Pagination arguments to return the `PromoShare`s by." pagination: PromoShareHistoryPagination): PromoShareHistoryConnection
}

"""
  [Connection] with `User`s.

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type UsersConnection {
  """
    List of `User` [Edges] in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [UsersEdge!]!
  """
    List of `User`s in this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [User!]!
  """
    [PageInfo] of this [Connection].

    [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
    [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""
  [Edge] with a `User`.

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type UsersEdge {
  """
    `User` [Node] at the end of this [Edge].

    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
    [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: User!
  """
    [Cursor] of this [Edge].

    [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
    [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: UsersCursor!
}

"Welcome message of a `User` to be posted in new `Chat`-dialogs with him."
type WelcomeMessage {
  "Text of this `WelcomeMessage`."
  text: ChatMessageText
  """
    `Attachment`s of this `WelcomeMessage`.

    ## Sorting

    Returned `Attachment`s are sorted in the same order as was provided to
    the `Mutation.updateWelcomeMessage` by this `WelcomeMessage`'s owner.
  """
  attachments: [Attachment!]!
  """
    `DateTime` when this `WelcomeMessage` was posted or edited.

    Only available for the owner of this `WelcomeMessage`.
  """
  at: DateTime
}

"Result of performing `Mutation.addChatMember`."
union AddChatMemberResult = ChatEventsVersioned | AddChatMemberError

"Result of performing `Mutation.addUserEmail`."
union AddUserEmailResult = MyUserEventsVersioned | AddUserEmailError

"Result of performing `Mutation.addUserPhone`."
union AddUserPhoneResult = MyUserEventsVersioned | AddUserPhoneError

"Updates emitted by `Subscription.balanceUpdates`."
union BalanceUpdate = SubscriptionInitialized | Balance

"Result of performing `Mutation.blockUser`."
union BlockUserResult = BlocklistEventsVersioned | BlockUserError

"Events emitted by `Subscription.blocklistEvents`."
union BlocklistEvents = SubscriptionInitialized | Blocklist | BlocklistEventsVersioned

"Events emitted by `Subscription.chatCallEvents`."
union ChatCallEvents = SubscriptionInitialized | ChatCall | ChatCallEventsVersioned

"""
  Events indicating changes in a `Query.chatContacts` and
  `Query.favoriteChatContacts`.
"""
union ChatContactsEvents = SubscriptionInitialized | ChatContactsList | ChatContactEventsVersioned

"Events emitted by `Subscription.chatEvents`."
union ChatEvents = SubscriptionInitialized | Chat | ChatEventsVersioned

"Action taken upon a `Chat`."
union ChatInfoAction = ChatInfoActionAvatarUpdated | ChatInfoActionCreated | ChatInfoActionMemberAdded | ChatInfoActionMemberRemoved | ChatInfoActionNameUpdated

"`ChatMember`s being dialed by a `ChatCall`."
union ChatMembersDialed = ChatMembersDialedAll | ChatMembersDialedConcrete

"Result of performing `Mutation.clearChat`."
union ClearChatResult = ChatEventsVersioned | ClearChatError

"Result of performing `Mutation.completeOperationDeposit`."
union CompleteOperationDepositResult = OperationEventsVersioned | CompleteOperationDepositError

"Result of performing `Mutation.createChatContactRecord`."
union CreateChatContactRecordResult = ChatContactEventsVersioned | CreateChatContactRecordError

"Result of performing `Mutation.createChatContactRecords`."
union CreateChatContactRecordsResult = ChatContactEventsVersioned | CreateChatContactRecordsError

"Result of performing `Mutation.createChatContact`."
union CreateChatContactResult = ChatContactEventsVersioned | CreateChatContactError

"Result of performing `Mutation.createChatDirectLink`."
union CreateChatDirectLinkResult = ChatEventsVersioned | MyUserEventsVersioned | CreateChatDirectLinkError

"Result of performing `Mutation.createDialogChat`."
union CreateDialogChatResult = Chat | CreateDialogChatError

"Result of performing `Mutation.createGroupChat`."
union CreateGroupChatResult = Chat | CreateGroupChatError

"Result of performing `Mutation.createOperationDeposit`."
union CreateOperationDepositResult = OperationEventsVersioned | CreateOperationDepositError

"Result of performing `Mutation.createOperationWithdraw`."
union CreateOperationWithdrawResult = OperationEventsVersioned | CreateOperationWithdrawError

"Result of performing `Mutation.createSession`."
union CreateSessionResult = CreateSessionOk | CreateSessionError

"Result of performing `Mutation.createUser`."
union CreateUserResult = CreateSessionOk | CreateUserError

"Entities' criteria matching `CountryCode`s."
union CriteriaCountry = CriteriaCountryExcept | CriteriaCountryOnly

"Result of performing `Mutation.declineChatCall`."
union DeclineChatCallResult = ChatEventsVersioned | DeclineChatCallError

"Result of performing `Mutation.declineOperationDeposit`."
union DeclineOperationDepositResult = OperationEventsVersioned | DeclineOperationDepositError

"Result of performing `Mutation.deleteChatContactRecord`."
union DeleteChatContactRecordResult = ChatContactEventsVersioned | DeleteChatContactRecordError

"Result of performing `Mutation.deleteChatDirectLink`."
union DeleteChatDirectLinkResult = ChatEventsVersioned | MyUserEventsVersioned | DeleteChatDirectLinkError

"Result of performing `Mutation.deleteChatForward`."
union DeleteChatForwardResult = ChatEventsVersioned | DeleteChatForwardError

"Result of performing `Mutation.deleteChatMessage`."
union DeleteChatMessageResult = ChatEventsVersioned | DeleteChatMessageError

"Result of performing `Mutation.deleteMyUser`."
union DeleteMyUserResult = MyUserEventsVersioned | DeleteMyUserError

"Result of performing `Mutation.deleteSession`."
union DeleteSessionResult = SessionEventsVersioned | DeleteSessionError

"Result of performing `Mutation.editChatMessage`."
union EditChatMessageResult = ChatEventsVersioned | EditChatMessageError

"Result of performing `Mutation.favoriteChatContact`."
union FavoriteChatContactResult = ChatContactEventsVersioned | FavoriteChatContactError

"Result of performing `Mutation.favoriteChat`."
union FavoriteChatResult = ChatEventsVersioned | FavoriteChatError

"Events indicating changes in a `Query.favoriteChats`."
union FavoriteChatsEvents = SubscriptionInitialized | FavoriteChatsList | FavoriteChatsEventsVersioned

"Result of performing `Mutation.forwardChatItems`."
union ForwardChatItemsResult = ChatEventsVersioned | ForwardChatItemsError

"Result of performing `Mutation.hideChatItem`."
union HideChatItemResult = ChatEventsVersioned | HideChatItemError

"Result of performing `Mutation.hideChat`."
union HideChatResult = ChatEventsVersioned | HideChatError

"Events emitted by `Subscription.incomingChatCallsTopEvents`."
union IncomingChatCallsTopEvents = SubscriptionInitialized | IncomingChatCallsTop | EventIncomingChatCallsTopChatCallAdded | EventIncomingChatCallsTopChatCallRemoved

"Result of performing `Mutation.joinChatCall`."
union JoinChatCallResult = JoinChatCallOk | JoinChatCallError

"Result of performing `Mutation.leaveChatCall`."
union LeaveChatCallResult = ChatEventsVersioned | LeaveChatCallError

"Events emitted by the `Subscription.monetizationSettings`."
union MonetizationSettingsEvents = SubscriptionInitialized | MonetizationSettingsList | MonetizationSettingsEventsVersioned

"Mute duration of a `Chat` or the authenticated `MyUser`."
union MuteDuration = MuteUntilDuration | MuteForeverDuration

"Events happening with `MyUser`."
union MyUserEvent = EventUserAvatarRemoved | EventUserAvatarUpdated | EventUserBioRemoved | EventUserBioUpdated | EventUserCallCoverRemoved | EventUserCallCoverUpdated | EventUserDeleted | EventUserDirectLinkDeleted | EventUserDirectLinkUpdated | EventUserDirectLinkUsageCountUpdated | EventUserEmailAdded | EventUserEmailRemoved | EventUserLoginRemoved | EventUserLoginUpdated | EventUserMuted | EventUserNameRemoved | EventUserNameUpdated | EventUserCameOnline | EventUserCameOffline | EventUserPasswordRemoved | EventUserPasswordUpdated | EventUserPhoneAdded | EventUserPhoneRemoved | EventUserPresenceUpdated | EventUserStatusRemoved | EventUserStatusUpdated | EventUserUnmuted | EventUserUnreadChatsCountUpdated | EventUserWelcomeMessageDeleted | EventUserWelcomeMessageUpdated

"Events emitted by `Subscription.myUserEvents`."
union MyUserEvents = SubscriptionInitialized | MyUser | MyUserEventsVersioned

"Events emitted by `Subscription.operationsEvents`."
union OperationsEvents = SubscriptionInitialized | OperationsList | OperationEventsVersioned

"Result of performing `Mutation.postChatMessage`."
union PostChatMessageResult = ChatEventsVersioned | PostChatMessageError

"Events happening with a `PromoShare`."
union PromoShareEvent = EventPromoShareRemoved | EventPromoShareUpdated

"""
  Events indicating changes in a `Query.promoShare` and
  `Query.promoShareHistory`.
"""
union PromoShareEvents = SubscriptionInitialized | UserPromoShare | PromoShareEventsVersioned

"Result of performing `Mutation.readChat`."
union ReadChatResult = ChatEventsVersioned | ReadChatError

"Events emitted by `Subscription.recentChatsTopEvents`."
union RecentChatsTopEvents = SubscriptionInitialized | RecentChatsTop | EventRecentChatsTopChatUpdated | EventRecentChatsTopChatRemoved

"Result of performing `Mutation.redialChatCallMember`."
union RedialChatCallMemberResult = ChatCallEventsVersioned | RedialChatCallMemberError

"Result of performing `Mutation.refreshSession`."
union RefreshSessionResult = CreateSessionOk | RefreshSessionError

"Result of performing `Mutation.removeChatCallMember`."
union RemoveChatCallMemberResult = ChatEventsVersioned | RemoveChatCallMemberError

"Result of performing `Mutation.removeChatMember`."
union RemoveChatMemberResult = ChatEventsVersioned | RemoveChatMemberError

"Result of performing `Mutation.removeUserEmail`."
union RemoveUserEmailResult = MyUserEventsVersioned | RemoveUserEmailError

"Result of performing `Mutation.removeUserPhone`."
union RemoveUserPhoneResult = MyUserEventsVersioned | RemoveUserPhoneError

"Result of performing `Mutation.renameChat`."
union RenameChatResult = ChatEventsVersioned | RenameChatError

"Events indicating changes in a `Query.sessions`."
union SessionsEvents = SubscriptionInitialized | SessionsList | SessionEventsVersioned

"Result of performing `Mutation.startChatCall`."
union StartChatCallResult = StartChatCallOk | StartChatCallError

"Result of performing `Mutation.toggleChatArchivation`."
union ToggleChatArchivationResult = ChatEventsVersioned | ToggleChatArchivationError

"Result of performing `Mutation.toggleChatCallHand`."
union ToggleChatCallHandResult = ChatCallEventsVersioned | ToggleChatCallHandError

"Result of performing `Mutation.toggleChatMute`."
union ToggleChatMuteResult = ChatEventsVersioned | ToggleChatMuteError

"Result of performing `Mutation.toggleMyUserMute`."
union ToggleMyUserMuteResult = MyUserEventsVersioned | ToggleMyUserMuteError

"Result of performing `Mutation.transformDialogCallIntoGroupCall`."
union TransformDialogCallIntoGroupCallResult = ChatEventsVersioned | TransformDialogCallIntoGroupCallError

"Result of performing `Mutation.unblockUser`."
union UnblockUserResult = BlocklistEventsVersioned | UnblockUserError

"Result of performing `Mutation.unfavoriteChatContact`."
union UnfavoriteChatContactResult = ChatContactEventsVersioned | UnfavoriteChatContactError

"Result of performing `Mutation.unfavoriteChat`."
union UnfavoriteChatResult = ChatEventsVersioned | UnfavoriteChatError

"Result of performing `Mutation.updateChatAvatar`."
union UpdateChatAvatarResult = ChatEventsVersioned | UpdateChatAvatarError

"Result of performing `Mutation.updateChatContactName`."
union UpdateChatContactNameResult = ChatContactEventsVersioned | UpdateChatContactNameError

"Result of performing `Mutation.updateMonetizationSettings`."
union UpdateMonetizationSettingsResult = MonetizationSettingsEventsVersioned | UpdateMonetizationSettingsError

"Result of performing `Mutation.updateUserAvatar`."
union UpdateUserAvatarResult = MyUserEventsVersioned | UpdateUserAvatarError

"Result of performing `Mutation.updateUserCallCover`."
union UpdateUserCallCoverResult = MyUserEventsVersioned | UpdateUserCallCoverError

"Result of performing `Mutation.updateUserLogin`."
union UpdateUserLoginResult = MyUserEventsVersioned | UpdateUserLoginError

"Result of performing `Mutation.updateUserPassword`."
union UpdateUserPasswordResult = MyUserEventsVersioned | UpdateUserPasswordError

"Result of performing `Mutation.updateWelcomeMessage`."
union UpdateWelcomeMessageResult = MyUserEventsVersioned | UpdateWelcomeMessageError

"Result of performing `Mutation.uploadAttachment`."
union UploadAttachmentResult = UploadAttachmentOk | UploadAttachmentError

"Result of performing `Mutation.useChatDirectLink`."
union UseChatDirectLinkResult = UseChatDirectLinkOk | UseChatDirectLinkError

"Events emitted by `Subscription.userEvents`."
union UserEvents = SubscriptionInitialized | User | UserEventsVersioned | IsBlocked | BlocklistEventsVersioned

"Online state of a `User`."
union UserOnlineState = UserOnline | UserOffline

"Vendor providing services or goods."
union Vendor = User
