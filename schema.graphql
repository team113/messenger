# Copyright Â© 2022-2024 IT ENGINEERING MANAGEMENT INC,
#                       <https://github.com/team113>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License v3.0 as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License v3.0 for
# more details.
#
# You should have received a copy of the GNU Affero General Public License v3.0
# along with this program. If not, see
# <https://www.gnu.org/licenses/agpl-3.0.html>.

directive @specifiedBy(url: String!) on SCALAR

"""
Type of a `Session`'s access token.

Its values are always considered to be non-empty and represent a
[valid Base64 string][1].

[1]: https://base64.guru/learn/base64-characters
"""
scalar AccessToken

"""Error of performing `Mutation.addChatMember`."""
type AddChatMemberError {
  """Code indicating why this error has happened."""
  code: AddChatMemberErrorCode!
}

"""Possible error codes of performing `Mutation.addChatMember`."""
enum AddChatMemberErrorCode {
  """
  Authenticated `MyUser` is blocked by the `User` he tries to add to the `Chat`.

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `Chat` is not a group, so cannot accept new members.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER
}

"""Result of performing `Mutation.addChatMember`."""
union AddChatMemberResult = ChatEventsVersioned | AddChatMemberError

"""Error of performing `Mutation.addUserEmail`."""
type AddUserEmailError {
  """Code indicating why this error has happened."""
  code: AddUserEmailErrorCode!
}

"""Possible error codes of performing `Mutation.addUserEmail`."""
enum AddUserEmailErrorCode {
  """
  Authenticated `MyUser` has its unconfirmed email address already set.

  Status code: 409 Conflict.
  """
  BUSY

  """
  Authenticated `MyUser` has reached maximum allowed number of email addresses.

  Status code: 403 Forbidden.
  """
  TOO_MANY
}

"""Result of performing `Mutation.addUserEmail`."""
union AddUserEmailResult = MyUserEventsVersioned | AddUserEmailError

"""Error of performing `Mutation.addUserPhone`."""
type AddUserPhoneError {
  """Code indicating why this error has happened."""
  code: AddUserPhoneErrorCode!
}

"""Possible error codes of performing `Mutation.addUserPhone`."""
enum AddUserPhoneErrorCode {
  """
  Authenticated `MyUser` has its unconfirmed phone number already set.

  Status code: 409 Conflict.
  """
  BUSY

  """
  Authenticated `MyUser` has reached maximum allowed number of phone numbers.

  Status code: 403 Forbidden.
  """
  TOO_MANY
}

"""Result of performing `Mutation.addUserPhone`."""
union AddUserPhoneResult = MyUserEventsVersioned | AddUserPhoneError

"""Angle of rotating an image."""
enum Angle {
  """0 degrees."""
  DEG0

  """90 degrees."""
  DEG90

  """180 degrees"""
  DEG180

  """270 degrees."""
  DEG270
}

"""
Attachment of a `ChatItem`.

`Mutation.uploadAttachment` expects to find a `filename` in a
[Content-Disposition][1] header.

Field `original` will return path to the file named `orig`. To download this
file with the original name, set the [`download`][2] attribute on `<a>` HTML
element to the value of the `filename` field.

[1]: https://mdn.io/Web/HTTP/Headers/Content-Disposition#directives
[2]: https://mdn.io/Web/HTML/Element/A#attributes
"""
interface Attachment {
  """Unique ID of this `Attachment`."""
  id: AttachmentId!

  """Original `File` representing this `Attachment`."""
  original: File!

  """Uploaded `File`'s name."""
  filename: String!
}

"""Type of an `Attachment`'s ID."""
scalar AttachmentId

"""
[Connection] with `BlocklistRecord`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type BlocklistConnection {
  """
  List of `BlocklistRecord` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [BlocklistEdge!]!

  """
  List of `BlocklistRecord`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [BlocklistRecord!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!

  """Total count of `BlocklistRecord`s."""
  totalCount: Int!
}

"""Cursor of `BlocklistRecord`s."""
scalar BlocklistCursor

"""
[Edge] with a `BlocklistRecord`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type BlocklistEdge {
  """
  `BlocklistRecord` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: BlocklistRecord!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: BlocklistCursor!
}

"""Event of a `User` being added or removed to/from `Query.blocklist`."""
interface BlocklistEvent {
  """`User` this `BlocklistEvent` is about."""
  user: User!

  """`DateTime` when this `BlocklistEvent` happened."""
  at: DateTime!
}

"""`BlocklistEvent`s along with the corresponding `MyUserVersion`."""
type BlocklistEventsVersioned {
  """
  Actual state of the `MyUser.blocklist` after this `BlocklistEvent`
  has been emitted. Alias of `MyUser.blocklist`.

  ## Sorting

  Returned `User`s are sorted primarily by their blocking `DateTime`, and
  secondary by their IDs (if the blocking `DateTime` is the same), in
  descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `BlocklistRecord` pointed by the cursor
  and the requested count of `BlocklistRecord`s preceding and following
  it.

  If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  blocklist(
    """Number of next `BlocklistRecord`s to return."""
    first: Int

    """
    Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after.
    """
    after: BlocklistCursor

    """Number of prior `BlocklistRecord`s to return."""
    last: Int

    """
    Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before.
    """
    before: BlocklistCursor
  ): BlocklistConnection!

  """`BlocklistEvent`s themselves."""
  events: [BlocklistEvent!]!

  """
  Version of the `MyUser`'s state updated by these `BlocklistEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: MyUserVersion!
}

"""Reason of blocking a `User` by the authenticated `MyUser`."""
scalar BlocklistReason

"""`User`'s record in a `Query.blocklist` of the authenticated `MyUser`."""
type BlocklistRecord {
  """Blocked `User`."""
  user: User!

  """Reason of why the `User` was blocked."""
  reason: BlocklistReason

  """`DateTime` when the `User` was blocked."""
  at: DateTime!
}

"""Error of performing `Mutation.blockUser`."""
type BlockUserError {
  """Code indicating why this error has happened."""
  code: BlockUserErrorCode!
}

"""Possible error codes of performing `Mutation.blockUser`."""
enum BlockUserErrorCode {
  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER
}

"""Result of performing `Mutation.blockUser`."""
union BlockUserResult = BlocklistEventsVersioned | BlockUserError

"""Changed `Attachment`s of a `ChatMessage`."""
type ChangedChatMessageAttachments {
  """
  New `Attachment`s of the `ChatMessage`.

  Empty list means that the previous `Attachment`s were deleted.

  ## Sorting

  Returned `Attachment`s are sorted in the same order as were provided to
  the `Mutation.editChatMessage` by the `ChatMessage`'s author.
  """
  changed: [Attachment!]!
}

"""Changed replied `ChatItem`s of a `ChatMessage`."""
type ChangedChatMessageReplies {
  """
  New `ChatItemQuote`s of the `ChatMessage`.

  Empty list means that the previous `ChatItemQuote`s were deleted.

  ## Sorting

  Returned `ChatItemQuote`s are sorted in the same order as were provided
  to the `Mutation.editChatMessage` by the `ChatMessage`'s author.
  """
  changed: [ChatItemQuote!]!
}

"""Changed `ChatMessageText` of a `ChatMessage`."""
type ChangedChatMessageText {
  """
  Changed `ChatMessageText`.

  `null` means that the previous `ChatMessageText` was deleted.
  """
  changed: ChatMessageText
}

"""`Chat` is a conversation between `User`s."""
type Chat {
  """Unique ID of this `Chat`."""
  id: ChatId!

  """Avatar of this `Chat`."""
  avatar: ChatAvatar

  """
  Name of this `Chat`.

  Only `Chat`-group can have a `name`.
  """
  name: ChatName

  """
  `ChatMember`s of this `Chat`.

  ## Sorting

  Returned `ChatMember`s are sorted primarily by their joining `DateTime`,
  and secondary by their IDs (if the joining `DateTime` is the same), in
  ascending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatMember` pointed by the cursor and
  the requested count of `ChatMember`s preceding and following it.

  If it's desired to receive the `ChatMember`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  members(
    """Number of next `ChatMember`s to return."""
    first: Int

    """
    Cursor indicating the `ChatMembersEdge` position to return next `ChatMember`s after.
    """
    after: ChatMembersCursor

    """Number of prior `ChatMember`s to return."""
    last: Int

    """
    Cursor indicating the `ChatMembersEdge` position to return prior `ChatMember`s before.
    """
    before: ChatMembersCursor

    """
    ID of the `ChatItem` that should be read by returned `ChatMember`s.
    `null` means omitting filtering by this criteria.
    """
    readItem: ChatItemId
  ): ChatMembersConnection!

  """Kind of this `Chat`."""
  kind: ChatKind!

  """Indicator whether this `Chat` is hidden by the authenticated `MyUser`."""
  isHidden: Boolean!

  """
  Mute condition of this `Chat` for the authenticated `MyUser`.

  Muted `Chat` implies that its events don't produce sounds and
  notifications on a client side. This, however, has nothing to do with a
  server and is the responsibility to be satisfied by a client side.
  Server side may try to optimize this in some cases (like omit sending
  notifications), but a client side should not rely on any such behaviour
  and should implement best-effort muting by itself.

  Note, that `Chat.muted` doesn't correlate with `MyUser.muted`. Muted
  `Chat` of unmuted `MyUser` (and unmuted `Chat` of muted `MyUser`) should
  not produce any sounds.
  """
  muted: MuteDuration

  """
  Position of this `Chat` in the favorites list of the authenticated
  `MyUser`.
  """
  favoritePosition: ChatFavoritePosition

  """`ChatDirectLink` to this `Chat`."""
  directLink: ChatDirectLink

  """`DateTime` when this `Chat` was created."""
  createdAt: DateTime!

  """
  `DateTime` when the last `ChatItem` was posted.

  The main difference from `Chat.lastItem.at` query is that this field is
  guaranteed to be monotonic. It's used for ordering `Chat`s by their
  recent updates in `Subscription.recentChatsTopEvents`.

  Only the following `ChatEvent` updates this field:
  - `EventChatItemPosted`.
  """
  updatedAt: DateTime!

  """
  List of this `Chat`'s members which have read it, along with the reading
  `DateTime`s.

  Limited with up to 10 `LastChatRead`s.
  """
  lastReads: [LastChatRead!]!

  """
  `DateTime` until which the posted `ChatItem`s were delivered to
  `ChatMember`s, excluding the authenticated `MyUser`.

  Can be used to determine whether the last `ChatItem` posted by the
  authenticated `MyUser` was delivered to other `ChatMember`s by checking
  it was posted not later than this `DateTime`.

  Points to [UNIX epoch][0] if `ChatItem`s have been never delivered
  before.

  [0]: https://en.wikipedia.org/wiki/Unix_time
  """
  lastDelivery: DateTime!

  """
  Last `ChatItem` posted in this `Chat`.

  `null` if there are no visible `ChatItem`s for the authenticated
  `MyUser` in this `Chat`.
  """
  lastItem: ChatItemsEdge

  """
  Last `ChatItem` read by the authenticated `MyUser` in this `Chat`.

  `null` if there are no visible `ChatItem`s for the authenticated
  `MyUser` in this `Chat`, or it hasn't been read yet.
  """
  lastReadItem: ChatItemsEdge

  """
  `ChatItem`s of this `Chat` ordered by their posting time.

  ## Sorting

  Returned `ChatItem`s are sorted primarily by their posting `DateTime`,
  and secondary by their IDs (if the posting `DateTime` is the same), in
  descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatItem` pointed by the cursor and the
  requested count of `ChatItem`s preceding and following it.

  If it's desired to receive the `ChatItem`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  items(
    """
    Indicator whether to filter out all the `ChatItem`s without attachments.
    """
    onlyAttachments: Boolean = false

    """Number of next `ChatItem`s to return."""
    first: Int

    """
    Cursor indicating the `ChatItemsEdge` position to return next `ChatItem`s after.
    """
    after: ChatItemsCursor

    """Number of prior `ChatItem`s to return."""
    last: Int

    """
    Cursor indicating the `ChatItemsEdge` position to return prior `ChatItem`s before.
    """
    before: ChatItemsCursor
  ): ChatItemsConnection!

  """`ChatItem` of this `Chat` by its ID."""
  item(id: ChatItemId!): ChatItemsEdge

  """
  Count of `ChatItem`s unread by the authenticated `MyUser` in this
  `Chat`.
  """
  unreadCount: Int!

  """
  Count of `ChatItem`s visible to the authenticated `MyUser` in this
  `Chat` (it doesn't include deleted or hidden `ChatItem`s).
  """
  totalCount: Int!

  """Current ongoing `ChatCall` of this `Chat`, if any."""
  ongoingCall: ChatCall

  """
  Version of this `Chat`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatVersion!
}

"""Avatar of a `Chat`."""
type ChatAvatar {
  """
  `CropArea` applied to the `original` `ImageFile` for creating this
  `ChatAvatar`.
  """
  crop: CropArea

  """Original `ImageFile` representing this `ChatAvatar`."""
  original: ImageFile!

  """
  Full-sized `ImageFile` representing this `ChatAvatar`, keeping the
  `original` dimensions.
  """
  full: ImageFile!

  """
  `big` view `ImageFile` of this `ChatAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to
  `250px`x`250px`.
  """
  big: ImageFile!

  """
  `medium` view `ImageFile` of this `ChatAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to
  `100px`x`100px`.
  """
  medium: ImageFile!

  """
  `small` view `ImageFile` of this `ChatAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to `46px`x`46px`.
  """
  small: ImageFile!
}

"""Call in a `Chat`."""
type ChatCall implements ChatItem {
  """Unique ID of this `ChatCall`."""
  id: ChatItemId!

  """ID of the `Chat` where this `ChatCall` is organized."""
  chatId: ChatId!

  """
  `ChatMember`s being dialed by this `ChatCall` at the moment.

  Unanswered `ChatCall`s (neither accepted, nor declined) are considered
  incoming (unless the dialing timeout passes) and should be present in
  results of `Query.incomingChatCalls` and
  `Subscription.incomingChatCallsTopEvents`. Although all 3 methods are
  suitable for notifying about incoming calls, this field contains the
  most recent and accurate information, as other methods may introduce a
  delay.

  To understand whether the authenticated `MyUser` is dialed by this
  `ChatCall` at the moment, check whether the `ChatCall.dialed.members`
  contain him or the `ChatCall.dialed.answeredMembers` do not while the
  `ChatCall.dialed` is not `null`.
  """
  dialed: ChatMembersDialed

  """
  `User` who started this `ChatCall`.

  Note, that this `User` may not be a member of this `ChatCall` at the
  moment.
  """
  author: User!

  """Indicator whether this `ChatCall` is intended to start with video."""
  withVideo: Boolean!

  """
  `ChatCallMember`s of this `ChatCall`.

  New `ChatCallMember`s always join a `ChatCall` with a lowered hand.

  ## Sorting

  Returned `ChatCallMember`s are sorted primarily by their joining
  `DateTime`, and secondary by their IDs (if the joining `DateTime` is the
  same), in ascending order.
  """
  members: [ChatCallMember!]!

  """
  Link for joining this `ChatCall`'s room on [Medea] media server.

  Should be used in conjunction with `ChatCallCredentials` (generated for
  `Mutation.startChatCall` or `Mutation.joinChatCall`) to properly
  authenticate on [Medea] media server.

  If `null` then `ChatCall`'s room on [Medea] media server isn't ready yet
  to be joined, and `EventChatCallRoomReady` should be awaited via
  `Subscription.chatCallEvents` before doing so.

  Bound to a concrete device of the authenticated `MyUser`, and so, is
  `null` in any operations where a concrete `ChatCallDeviceId` is unknown.
  This means that every device of the authenticated `MyUser` must obtain
  its own `ChatCallRoomJoinLink` via separate
  `Subscription.chatCallEvents`.

  [Medea]: https://github.com/instrumetisto/medea
  """
  joinLink: ChatCallRoomJoinLink

  """`DateTime` when this `ChatCall` was started."""
  at: DateTime!

  """
  `DateTime` when the actual conversation in this `ChatCall` was started
  (after ringing had been finished).
  """
  conversationStartedAt: DateTime

  """`DateTime` when this `ChatCall` was finished (if it was)."""
  finishedAt: DateTime

  """Reason of why this `ChatCall` was finished (if it was)."""
  finishReason: ChatCallFinishReason

  """
  Version of this `ChatCall`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""
Type of `MyUser`'s `ChatCall` credentials.

Intended to be generated on a client side. Generate a new value for each new
`ChatCall`.

Its values are always considered to be non-empty, and meet the following
requirements:
- not start or end with space-like characters;
- be at least 1 and maximum 250 characters long.
"""
scalar ChatCallCredentials

"""Type of a `ChatCallMember`'s device ID."""
scalar ChatCallDeviceId

"""Events happening in a `ChatCall`."""
interface ChatCallEvent {
  """ID of the `ChatCall` this `ChatCallEvent` is related to."""
  callId: ChatItemId!

  """ID of the `Chat` this `ChatCallEvent` is happened in."""
  chatId: ChatId!

  """`DateTime` when this `ChatCallEvent` happened."""
  at: DateTime!
}

"""Events emitted by `Subscription.chatCallEvents`."""
union ChatCallEvents = SubscriptionInitialized | ChatCall | ChatCallEventsVersioned

"""`ChatCallEvent`s along with the corresponding `ChatItemVersion`."""
type ChatCallEventsVersioned {
  """`ChatCallEvent`s themselves."""
  events: [ChatCallEvent!]!

  """
  Version of the `ChatCall`'s state updated by these `ChatCallEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""Reason of why a `ChatCall` was finished."""
enum ChatCallFinishReason {
  """
  `Chat`-dialog `ChatCall` was dropped (canceled by the caller before
  being responded).
  """
  DROPPED

  """`Chat`-dialog `ChatCall` was declined by the responder."""
  DECLINED

  """
  `Chat`-dialog responder didn't manage to answer a `ChatCall` in the
  given ringing time.
  """
  UNANSWERED

  """The last member of a `ChatCall` left."""
  MEMBER_LEFT

  """
  `ChatCall` was moved from its `Chat`-dialog to a newly created
  `Chat`-group.
  """
  MOVED

  """The last member of a `ChatCall` lost connection."""
  MEMBER_LOST_CONNECTION

  """Server decided to finish a `ChatCall` due its inner processes."""
  SERVER_DECISION
}

"""Member of a `ChatCall`."""
type ChatCallMember {
  """`User` representing this `ChatCallMember`."""
  user: User!

  """Indicator whether this `ChatCallMember` raised a hand."""
  handRaised: Boolean!

  """`DateTime` when this `ChatCallMember` joined the `ChatCall`."""
  joinedAt: DateTime!
}

"""`ChatItemQuote` of a `ChatCall`."""
type ChatCallQuote implements ChatItemQuote {
  """
  Quoted `ChatCall`.

  `null` if the quoted `ChatCall` was deleted or is unavailable for the
  authenticated `MyUser`.
  """
  original: ChatItemsEdge

  """`User` who started the quoted `ChatCall`."""
  author: User!

  """`DateTime` when the quoted `ChatCall` was started."""
  at: DateTime!
}

"""
Link for joining the room of a `ChatCall` on a media server.

Always bound to a concrete device of the authenticated `MyUser`.
This means that every device of the authenticated `MyUser` must obtain its
own `ChatCallRoomJoinLink` via separate `Subscription.chatCallEvents`.

This link requires addition authentication via `token` query parameter with
the value of `ChatCallCredentials` that has been provided to
`Mutation.startChatCall` or `Mutation.joinChatCall`.
"""
scalar ChatCallRoomJoinLink

"""
Record in an address book of the authenticated `MyUser`.

It may be linked with some real `User`s, but also may not.
"""
type ChatContact {
  """Unique ID of this `ChatContact`."""
  id: ChatContactId!

  """
  Custom `UserName` of this `ChatContact` given by the authenticated
  `MyUser`.
  """
  name: UserName!

  """
  `User`s linked to this `ChatContact`.

  Guaranteed to have no duplicates.
  """
  users: [User!]!

  """
  `Chat`-groups linked to this `ChatContact`.

  Guaranteed to have no duplicates.
  """
  groups: [Chat!]!

  """
  List of `UserEmail`s provided by this `ChatContact`.

  Guaranteed to have no duplicates.
  """
  emails: [ChatContactEmail!]!

  """
  List of `UserPhone`s provided by this `ChatContact`.

  Guaranteed to have no duplicates.
  """
  phones: [ChatContactPhone!]!

  """
  Position of this `ChatContact` in the favorites list of the
  authenticated `MyUser`.
  """
  favoritePosition: ChatContactFavoritePosition

  """
  Version of this `ChatContact`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatContactVersion!
}

"""Email address provided by a `ChatContact`."""
type ChatContactEmail {
  """`UserEmail` of this `ChatContactEmail`."""
  email: UserEmail!

  """`User` behind this `ChatContactEmail`, if any."""
  user: User
}

"""Events happening in a `ChatContact`."""
interface ChatContactEvent {
  """ID of the `ChatContact` this `ChatContactEvent` is related to."""
  contactId: ChatContactId!

  """`DateTime` when this `ChatContactEvent` happened."""
  at: DateTime!
}

"""
`ChatContactEvent`s along with the corresponding `ChatContactVersion`.
and `ChatContactsListVersion`.
"""
type ChatContactEventsVersioned {
  """`ChatContactEvent`s themselves."""
  events: [ChatContactEvent!]!

  """
  Version of the `ChatContact` state updated by these `ChatContactEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking concrete `ChatContact` state's actuality.

  If the `events` contain `ChatContactEvent`s related to different
  `ChatContact`s, then this version is applicable for all of them.
  """
  ver: ChatContactVersion!

  """
  Version of the `ChatContact`s list updated by these `ChatContactEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking list state's actuality.

  Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  listVer: ChatContactsListVersion!
}

"""
Position of a `ChatContact` in a `MyUser`'s favorites list.

Its values are always considered to be finite positive [`Float` values][1].

[1]: https://spec.graphql.org/June2018#sec-Float-Value
"""
scalar ChatContactFavoritePosition

"""Type of a `ChatContact`'s ID."""
scalar ChatContactId

"""Phone number provided by a `ChatContact`."""
type ChatContactPhone {
  """`UserPhone` of this `ChatContactPhone`."""
  phone: UserPhone!

  """`User` behind this `ChatContactPhone`, if any."""
  user: User
}

"""
Input type representing a record of a `ChatContact`.

Exactly one field should be set.
"""
input ChatContactRecord {
  """`User` record."""
  userId: UserId

  """`Chat`-group record."""
  groupId: ChatId

  """`UserEmail` record."""
  email: UserEmail

  """`UserPhone` record."""
  phone: UserPhone
}

"""
[Connection] with `ChatContact`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatContactsConnection {
  """
  List of `ChatContact` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatContactsEdge!]!

  """
  List of `ChatContact`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatContact!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!

  """
  Version of this `ChatContact`s list.

  It increases monotonically, so may be used (and is intended to) for
  tracking list state's actuality.

  Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  ver: ChatContactsListVersion!
}

"""Cursor of `ChatContact`s."""
scalar ChatContactsCursor

"""
[Edge] with a `ChatContact`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatContactsEdge {
  """
  `ChatContact` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatContact!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatContactsCursor!
}

"""
Events indicating changes in a `Query.chatContacts` and
`Query.favoriteChatContacts`.
"""
union ChatContactsEvents = SubscriptionInitialized | ChatContactsList | ChatContactEventsVersioned

"""List of `ChatContact`s."""
type ChatContactsList {
  """
  Returns address book of the authenticated `MyUser` ordered
  alphabetically by `ChatContact` names.

  Alias of `Query.chatContacts`.
  """
  chatContacts(
    """Number of next `ChatContact`s to return."""
    first: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return next `ChatContact`s after.
    """
    after: ChatContactsCursor

    """Number of prior `ChatContact`s to return."""
    last: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return prior `ChatContact`s before.
    """
    before: ChatContactsCursor

    """
    Indicator whether favorite `ChatContact`s should be excluded from the result.
    """
    noFavorite: Boolean = false
  ): ChatContactsConnection!

  """
  Returns favorited `ChatContact`s of the authenticated `MyUser` ordered
  by the custom order of `MyUser`'s favorites list (using
  `ChatContact.favoritePosition` field).

  Aliases `Query.favoriteChatContacts`.
  """
  favoriteChatContacts(
    """Number of next `ChatContact`s to return."""
    first: Int

    """
    Cursor indicating the `FavoriteChatContactsEdge` position to return next `ChatContact`s after.
    """
    after: FavoriteChatContactsCursor

    """Number of prior `ChatContact`s to return."""
    last: Int

    """
    Cursor indicating the `FavoriteChatContactsEdge` position to return prior `ChatContact`s before.
    """
    before: FavoriteChatContactsCursor
  ): FavoriteChatContactsConnection!
}

"""
Version of a `ChatContact`s list.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar ChatContactsListVersion

"""
Version of `ChatContact`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar ChatContactVersion

"""Direct link to a `Chat`."""
type ChatDirectLink {
  """Unique slug associated with this `ChatDirectLink`."""
  slug: ChatDirectLinkSlug!

  """Counter of this `ChatDirectLink` being used."""
  usageCount: Int!
}

"""
Type of a `ChatDirectLink`'s [slug] value.

Its values are always considered to be non-empty, and meet the following
requirements:
- have only latin letters (`A-Z`, `a-z`), digits (`0-9`) or `_-`symbols;
- be at least 1 and maximum 100 characters long.

[slug]: https://en.wikipedia.org/wiki/Clean_URL#Slug
"""
scalar ChatDirectLinkSlug

"""Events happening in a `Chat`."""
interface ChatEvent {
  """ID of the `Chat` this `ChatEvent` is related to."""
  chatId: ChatId!
}

"""Events emitted by `Subscription.chatEvents`."""
union ChatEvents = SubscriptionInitialized | Chat | ChatEventsVersioned

"""`ChatEvent`s along with the corresponding `ChatVersion`."""
type ChatEventsVersioned {
  """`ChatEvent`s themselves."""
  events: [ChatEvent!]!

  """
  Version of the `Chat`'s state updated by these `ChatEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatVersion!
}

"""
Position of a `Chat` in `MyUser`'s favorites list.

Its values are always considered to be finite positive [`Float` values][1].

[1]: https://spec.graphql.org/June2018#sec-Float-Value
"""
scalar ChatFavoritePosition

"""Quote of a `ChatItem` forwarded to some `Chat`."""
type ChatForward implements ChatItem {
  """Unique ID of this `ChatForward`."""
  id: ChatItemId!

  """ID of the `Chat` this `ChatForward` is posted in."""
  chatId: ChatId!

  """`User` who posted this `ChatForward`."""
  author: User!

  """
  `ChatItemQuote` of the forwarded `ChatItem`.

  Re-forwarding a `ChatForward` is indistinguishable from just forwarding
  its inner `ChatMessage` (`ChatItemQuote` depth will still be just 1).
  """
  quote: ChatItemQuote!

  """`DateTime` when this `ChatForward` was posted."""
  at: DateTime!

  """
  Version of this `ChatForward`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""Type of a `Chat`'s ID."""
scalar ChatId

"""Information about an action taken upon a `Chat`."""
type ChatInfo implements ChatItem {
  """Unique ID of this `ChatInfo`."""
  id: ChatItemId!

  """ID of the `Chat` this `ChatInfo` was posted in."""
  chatId: ChatId!

  """`User` who triggered this `ChatInfo`."""
  author: User!

  """`ChatInfoAction` taken upon the `Chat`."""
  action: ChatInfoAction!

  """`DateTime` when this `ChatInfo` was posted."""
  at: DateTime!

  """
  Version of this `ChatInfo`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""Action taken upon a `Chat`."""
union ChatInfoAction = ChatInfoActionAvatarUpdated | ChatInfoActionCreated | ChatInfoActionMemberAdded | ChatInfoActionMemberRemoved | ChatInfoActionNameUpdated

"""`ChatInfoAction` about a `ChatAvatar` being updated."""
type ChatInfoActionAvatarUpdated {
  """
  New `ChatAvatar` of the `Chat`.

  `null` means that the old `ChatAvatar` was removed.
  """
  avatar: ChatAvatar
}

"""`ChatInfoAction` about a `Chat` being created."""
type ChatInfoActionCreated {
  """`ChatDirectLinkSlug` used to create the `Chat`, if any."""
  directLinkSlug: ChatDirectLinkSlug
}

"""`ChatInfoAction` about a `ChatMember` being added to a `Chat`."""
type ChatInfoActionMemberAdded {
  """
  `User` who became a `ChatMember`.

  If the same as `ChatItem.authorId`, then the `User` joined the `Chat` by
  himself.
  """
  user: User!

  """
  `ChatDirectLinkSlug` used by the `ChatMember` to join the `Chat`, if
  any.
  """
  directLinkSlug: ChatDirectLinkSlug
}

"""`ChatInfoAction` about a `ChatMember` being removed from a `Chat`."""
type ChatInfoActionMemberRemoved {
  """
  `User` who was removed from the `Chat`.

  If the same as `ChatItem.authorId`, then the `User` left the `Chat` by
  himself.
  """
  user: User!
}

"""`ChatInfoAction` about a `ChatName` being updated."""
type ChatInfoActionNameUpdated {
  """
  New `ChatName` of the `Chat`.

  `null` means that the old `ChatName` was removed.
  """
  name: ChatName
}

"""`ChatItemQuote` of a `ChatInfo`."""
type ChatInfoQuote implements ChatItemQuote {
  """
  Quoted `ChatInfo`.

  `null` if the quoted `ChatInfo` was deleted or is unavailable for the
  authenticated `MyUser`.
  """
  original: ChatItemsEdge

  """`User` who triggered the quoted `ChatInfo`."""
  author: User!

  """`ChatInfoAction` of the quoted `ChatInfo`."""
  action: ChatInfoAction!

  """`DateTime` when the quoted `ChatInfo` was created."""
  at: DateTime!
}

"""Item posted in a `Chat` (its content)."""
interface ChatItem {
  """Unique ID of this `ChatItem`."""
  id: ChatItemId!

  """ID of the `Chat` this `ChatItem` is posted in."""
  chatId: ChatId!

  """`User` who posted this `ChatItem`."""
  author: User!

  """`DateTime` when this `ChatItem` was posted."""
  at: DateTime!

  """
  Version of this `ChatItem`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""Type of a `ChatItem`'s ID."""
scalar ChatItemId

"""Quote of a `ChatItem`."""
interface ChatItemQuote {
  """
  Quoted `ChatItem`.

  `null` if the original `ChatMessage` was deleted or is unavailable for
  the authenticated `MyUser`.
  """
  original: ChatItemsEdge

  """`User` who created the quoted `ChatItem`."""
  author: User!

  """`DateTime` when the quoted `ChatItem` was created."""
  at: DateTime!
}

"""`ChatItem`'s quote used as input of `Mutation.forwardChatItems`."""
input ChatItemQuoteInput {
  """ID of the `ChatItem` to be forwarded."""
  id: ChatItemId!

  """
  Indicator whether a forward should contain the full `ChatMessageText` of
  the original `ChatItem` (if it contains any).
  """
  withText: Boolean!

  """
  IDs of the `ChatItem`'s `Attachment`s to be forwarded.

  - `null` means all the `ChatItem`'s `Attachment`s will be forwarded, if
    any.
  - `[]` (empty list) means no `Attachment`s, only the text will be
    forwarded.
  """
  attachments: [AttachmentId!]
}

"""
[Connection] with `ChatItem`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatItemsConnection {
  """
  List of `ChatItem` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatItemsEdge!]!

  """
  List of `ChatItem`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatItem!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""Cursor of `ChatItem`s within a `Chat`."""
scalar ChatItemsCursor

"""
[Edge] with a `ChatItem`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatItemsEdge {
  """
  `ChatItem` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatItem!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatItemsCursor!
}

"""
Version of `ChatItem`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar ChatItemVersion

"""Kind of a `Chat`."""
enum ChatKind {
  """`Chat` with a single member."""
  MONOLOG

  """`Chat` between two members."""
  DIALOG

  """`Chat` between an arbitrary number of members."""
  GROUP
}

"""Member of a `Chat`."""
type ChatMember {
  """`User` represented by this `ChatMember`."""
  user: User!

  """`DateTime` when the `User` became a `ChatMember`."""
  joinedAt: DateTime!
}

"""
[Connection] with `ChatMember`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type ChatMembersConnection {
  """
  List of `ChatMember` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [ChatMembersEdge!]!

  """
  List of `ChatMember`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatMember!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""Cursor of `ChatMember`s in a `Chat`."""
scalar ChatMembersCursor

"""`ChatMember`s being dialed by a `ChatCall`."""
union ChatMembersDialed = ChatMembersDialedAll | ChatMembersDialedConcrete

"""
Information about all `ChatMember`s of a `Chat` being dialed (or redialed)
by a `ChatCall`.
"""
type ChatMembersDialedAll {
  """
  `ChatMember`s who answered (joined or declined) the `ChatCall` already,
  so are not dialed anymore.
  """
  answeredMembers: [ChatMember!]!
}

"""
Information about concrete `ChatMember`s of a `Chat` being dialed (or
redialed) by a `ChatCall`.
"""
type ChatMembersDialedConcrete {
  """
  Concrete `ChatMember`s who are dialed (or redialed) by the `ChatCall`.

  Guaranteed to be non-empty.
  """
  members: [ChatMember!]!
}

"""
[Edge] with a `ChatMember`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type ChatMembersEdge {
  """
  `ChatMember` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatMember!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: ChatMembersCursor!
}

"""Message in a `Chat`."""
type ChatMessage implements ChatItem {
  """Unique ID of this `ChatMessage`."""
  id: ChatItemId!

  """ID of the `Chat` this `ChatMessage` is posted in."""
  chatId: ChatId!

  """`User` who posted this `ChatMessage`."""
  author: User!

  """`ChatItemQuote`s of the `ChatItem`s this `ChatMessage` replies to."""
  repliesTo: [ChatItemQuote!]!

  """Text of this `ChatMessage`."""
  text: ChatMessageText

  """`DateTime` when this `ChatMessage` was edited."""
  editedAt: DateTime

  """
  `Attachment`s of this `ChatMessage`.

  ## Sorting

  Returned `Attachment`s are sorted in the same order as was provided to
  the `Mutation.postChatMessage` by this `ChatMessage`'s author.
  """
  attachments: [Attachment!]!

  """`DateTime` when this `ChatMessage` was posted."""
  at: DateTime!

  """
  Version of this `ChatMessage`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: ChatItemVersion!
}

"""`Attachment`s used as input of `Mutation.editChatMessage`."""
input ChatMessageAttachmentsInput {
  """
  IDs of new `Attachment`s.

  Empty list means that the previous `Attachment`s should be deleted.
  """
  new: [AttachmentId!]!
}

"""`ChatItemQuote` of a `ChatMessage`."""
type ChatMessageQuote implements ChatItemQuote {
  """
  Quoted `ChatMessage` or `ChatForward` (only if it's replied).

  `null` if the quoted `ChatMessage` was deleted or is unavailable for the
  authenticated `MyUser`.
  """
  original: ChatItemsEdge

  """`User` who posted the quoted `ChatMessage`."""
  author: User!

  """
  `ChatMessageText` the quoted `ChatMessage` had when this `ChatItemQuote`
  was made.
  """
  text: ChatMessageText

  """
  `Attachment`s the quoted `ChatMessage` had when this `ChatItemQuote` was
  made.
  """
  attachments: [Attachment!]!

  """`DateTime` when the quoted `ChatMessage` was posted."""
  at: DateTime!
}

"""Replied `ChatItem`s used as input of `Mutation.editChatMessage`."""
input ChatMessageRepliesInput {
  """
  IDs of new replied `ChatItem`s.

  Empty list means that the previous `ChatItemQuote`s should be deleted.
  """
  new: [ChatItemId!]!
}

"""
Type of `ChatMessage`'s text.

Its values are always considered to be non-empty and meet the following
requirements:
- be maximum 8192 UTF-8 characters long.
"""
scalar ChatMessageText

"""`ChatMessageText` used as input of `Mutation.editChatMessage`."""
input ChatMessageTextInput {
  """
  New `ChatMessageText`.

  `null` means that the previous `ChatMessageText` should be deleted.
  """
  new: ChatMessageText
}

"""
Type of a `Chat`'s name.

Its values are always considered to be non-empty, and meet the following
requirements:
- not start and end with space-like characters;
- not contain line breaks;
- be at least 1 and maximum 100 characters long.
"""
scalar ChatName

"""
Version of `Chat`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar ChatVersion

"""Error of performing `Mutation.clearChat`."""
type ClearChatError {
  """Code indicating why this error has happened."""
  code: ClearChatErrorCode!
}

"""Possible error codes of performing `Mutation.clearChat`."""
enum ClearChatErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `ChatItem` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM
}

"""Result of performing `Mutation.clearChat`."""
union ClearChatResult = ChatEventsVersioned | ClearChatError

"""
Type of a code used for email addresses confirmation, password recovery,
etc.

Its values are always considered to be 4-digit strings.
"""
scalar ConfirmationCode

"""Error of performing `Mutation.confirmUserEmail`."""
type ConfirmUserEmailError {
  """Code indicating why this error has happened."""
  code: ConfirmUserEmailErrorCode!
}

"""Possible error codes of performing `Mutation.confirmUserEmail`."""
enum ConfirmUserEmailErrorCode {
  """
  Email address being confirmed is occupied by another `User` already.

  Authenticated `MyUser` should delete his current unconfirmed email address via
  `Mutation.deleteUserEmail`, choose another email address and set it via
  `Mutation.addUserEmail`.

  Status code: 409 Conflict.
  """
  OCCUPIED

  """
  Provided `ConfirmationCode` is wrong.

  Status code: 403 Forbidden.
  """
  WRONG_CODE
}

"""Result of performing `Mutation.confirmUserEmail`."""
union ConfirmUserEmailResult = MyUserEventsVersioned | ConfirmUserEmailError

"""Error of performing `Mutation.confirmUserPhone`."""
type ConfirmUserPhoneError {
  """Code indicating why this error has happened."""
  code: ConfirmUserPhoneErrorCode!
}

"""Possible error codes of performing `Mutation.confirmUserPhone`."""
enum ConfirmUserPhoneErrorCode {
  """
  Phone number being confirmed is occupied by another `User` already.

  Authenticated `MyUser` should delete his current unconfirmed phone number via
  `Mutation.deleteUserPhone`, choose another phone number and set it via
  `Mutation.addUserPhone`.

  Status code: 409 Conflict.
  """
  OCCUPIED

  """
  Provided `ConfirmationCode` is wrong.

  Status code: 403 Forbidden.
  """
  WRONG_CODE
}

"""Result of performing `Mutation.confirmUserPhone`."""
union ConfirmUserPhoneResult = MyUserEventsVersioned | ConfirmUserPhoneError

"""Error of performing `Mutation.createChatContact`."""
type CreateChatContactError {
  """Code indicating why this error has happened."""
  code: CreateChatContactErrorCode!
}

"""Possible error codes of performing `Mutation.createChatContact`."""
enum CreateChatContactErrorCode {
  """
  `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER

  """
  `ChatContact` can be created with no more than 20 initial `ChatContactRecord`s.

  Use `Mutation.createChatContactRecords` to add more, if you need so.

  Status code: 400 Bad Request.
  """
  WRONG_RECORDS_COUNT
}

"""Error of performing `Mutation.createChatContactRecord`."""
type CreateChatContactRecordError {
  """Code indicating why this error has happened."""
  code: CreateChatContactRecordErrorCode!
}

"""Possible error codes of performing `Mutation.createChatContactRecord`."""
enum CreateChatContactRecordErrorCode {
  """
  `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  Exceeded `ChatContact`'s maximum capacity of 100 `ChatContactRecord`s.

  Status code: 400 Bad Request.
  """
  TOO_MANY

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER
}

"""Result of performing `Mutation.createChatContactRecord`."""
union CreateChatContactRecordResult = ChatContactEventsVersioned | CreateChatContactRecordError

"""Error of performing `Mutation.createChatContactRecords`."""
type CreateChatContactRecordsError {
  """Code indicating why this error has happened."""
  code: CreateChatContactRecordsErrorCode!
}

"""
Possible error codes of performing `Mutation.createChatContactRecords`.
"""
enum CreateChatContactRecordsErrorCode {
  """
  `Chat` with the provided ID is not a group, so cannot be recorded into a `ChatContact`.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  Exceeded `ChatContact`'s maximum capacity of 100 `ChatContactRecord`s.

  Status code: 400 Bad Request.
  """
  TOO_MANY

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER

  """
  No more than 20 initial `ChatContactRecord`s can be created at once.

  Status code: 400 Bad Request.
  """
  WRONG_RECORDS_COUNT
}

"""Result of performing `Mutation.createChatContactRecords`."""
union CreateChatContactRecordsResult = ChatContactEventsVersioned | CreateChatContactRecordsError

"""Result of performing `Mutation.createChatContact`."""
union CreateChatContactResult = ChatContactEventsVersioned | CreateChatContactError

"""Error of performing `Mutation.createChatDirectLink`."""
type CreateChatDirectLinkError {
  """Code indicating why this error has happened."""
  code: CreateChatDirectLinkErrorCode!
}

"""Possible error codes of performing `Mutation.createChatDirectLink`."""
enum CreateChatDirectLinkErrorCode {
  """
  `Chat` is not a group, so cannot have direct links.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `ChatDirectLink` with the specified `slug` is occupied by another `User` or `Chat`-group already.

  Status code: 403 Forbidden.
  """
  OCCUPIED

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.createChatDirectLink`."""
union CreateChatDirectLinkResult = ChatEventsVersioned | MyUserEventsVersioned | CreateChatDirectLinkError

"""Error of performing `Mutation.createDialogChat`."""
type CreateDialogChatError {
  """Code indicating why this error has happened."""
  code: CreateDialogChatErrorCode!
}

"""Possible error codes of performing `Mutation.createDialogChat`."""
enum CreateDialogChatErrorCode {
  """
  Authenticated `MyUser` is blocked by the responder.

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER

  """
  Creating a `Chat`-dialog with the authenticated `MyUser` is not possible, consider creating a `Chat`-monolog instead.

  Status code: 403 Forbidden.
  """
  USE_MONOLOG
}

"""Result of performing `Mutation.createDialogChat`."""
union CreateDialogChatResult = Chat | CreateDialogChatError

"""Error of performing `Mutation.createGroupChat`."""
type CreateGroupChatError {
  """Code indicating why this error has happened."""
  code: CreateGroupChatErrorCode!
}

"""Possible error codes of performing `Mutation.createGroupChat`."""
enum CreateGroupChatErrorCode {
  """
  Authenticated `MyUser` is blocked by one of the members.

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER

  """
  `Chat` cannot be created with more than 100 initial members.

  Status code: 400 Bad Request.
  """
  WRONG_MEMBERS_COUNT
}

"""Result of performing `Mutation.createGroupChat`."""
union CreateGroupChatResult = Chat | CreateGroupChatError

"""Error of performing `Mutation.createSession`."""
type CreateSessionError {
  """Code indicating why this error has happened."""
  code: CreateSessionErrorCode!
}

"""Possible error codes of performing `Mutation.createSession`."""
enum CreateSessionErrorCode {
  """
  Provided password is wrong or `MyUser` with the provided identifier doesn't exist.

  Status code: 403 Forbidden.
  """
  WRONG_PASSWORD
}

"""Result of a successful performing `Mutation.createSession`."""
type CreateSessionOk {
  """
  Created `Session`.

  It will expire in 30 minutes after creation.
  """
  session: Session!

  """
  Created `RememberedSession` for a `Session` renewal.

  It will expire in 365 days (~1 year) after creation.
  """
  remembered: RememberedSession!

  """`MyUser` that the `Session` was created for."""
  user: MyUser!
}

"""Result of performing `Mutation.createSession`."""
union CreateSessionResult = CreateSessionOk | CreateSessionError

"""Result of a successful performing `Mutation.createUser`."""
type CreateUserResult {
  """Created `MyUser`."""
  user: MyUser!

  """
  `Session` of the created `MyUser`.

  It will expire in 30 minutes after `MyUser` creation.
  """
  session: Session!

  """
  `RememberedSession` of the created `MyUser`.

  It will expire in 365 days (~1 year) after `MyUser` creation.
  """
  remembered: RememberedSession!
}

"""
Area for an image cropping.

Top left corner of the rotated by `angle` image is considered as `(0, 0)`
coordinates start point. So, obviously, `CropArea.bottomRight` point's
coordinates should be bigger than the ones of `CropArea.topLeft` point.

For raster images use pixels as the coordinate system. For [SVG] images use
[viewport coordinate system][1].

[SVG]: https://en.wikipedia.org/wiki/Portable_Network_Graphics
[1]: https://w3.org/TR/SVG/coords.html
"""
type CropArea {
  """`Point` of a top left corner of this cropping area."""
  topLeft: Point!

  """`Point` of a bottom right corner of this cropping area."""
  bottomRight: Point!

  """Angle to rotate image before cropping."""
  angle: Angle
}

"""
Input area for an image cropping.

Same as `CropArea`, but for using in arguments.

Top left corner of the rotated by `angle` image is considered as `(0, 0)`
coordinates start point. So, obviously, `CropAreaInput.bottomRight` point's
coordinates should be bigger than the ones of `CropAreaInput.topLeft` point.
"""
input CropAreaInput {
  """`PointInput` of a top left corner of this cropping area."""
  topLeft: PointInput!

  """`PointInput` of a bottom right corner of this cropping area."""
  bottomRight: PointInput!

  """Angle to rotate image before cropping."""
  angle: Angle
}

"""
Combined date and time (with time zone) in [RFC 3339] format with
microseconds precision.

Represents a description of an exact instant on the time-line (such as the
instant that a user account was created).

[`DateTime` scalar][1] compliant.

[1]: https://graphql-scalars.dev/docs/scalars/date-time
[RFC 3339]: https://datatracker.ietf.org/doc/html/rfc3339#section-5.6
"""
scalar DateTime

"""Error of performing `Mutation.declineChatCall`."""
type DeclineChatCallError {
  """Code indicating why this error has happened."""
  code: DeclineChatCallErrorCode!
}

"""Possible error codes of performing `Mutation.declineChatCall`."""
enum DeclineChatCallErrorCode {
  """
  Authenticated `MyUser` joined the `ChatCall` already.

  Status code: 403 Forbidden.
  """
  ALREADY_JOINED

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.declineChatCall`."""
union DeclineChatCallResult = ChatEventsVersioned | DeclineChatCallError

"""Error of performing `Mutation.deleteChatContactRecord`."""
type DeleteChatContactRecordError {
  """Code indicating why this error has happened."""
  code: DeleteChatContactRecordErrorCode!
}

"""Possible error codes of performing `Mutation.deleteChatContactRecord`."""
enum DeleteChatContactRecordErrorCode {
  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT
}

"""Result of performing `Mutation.deleteChatContactRecord`."""
union DeleteChatContactRecordResult = ChatContactEventsVersioned | DeleteChatContactRecordError

"""Error of performing `Mutation.deleteChatDirectLink`."""
type DeleteChatDirectLinkError {
  """Code indicating why this error has happened."""
  code: DeleteChatDirectLinkErrorCode!
}

"""Possible error codes of performing `Mutation.deleteChatDirectLink`."""
enum DeleteChatDirectLinkErrorCode {
  """
  `Chat` is not a group, so cannot have direct links.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.deleteChatDirectLink`."""
union DeleteChatDirectLinkResult = ChatEventsVersioned | MyUserEventsVersioned | DeleteChatDirectLinkError

"""Error of performing `Mutation.deleteChatForward`."""
type DeleteChatForwardError {
  """Code indicating why this error has happened."""
  code: DeleteChatForwardErrorCode!
}

"""Possible error codes of performing `Mutation.deleteChatForward`."""
enum DeleteChatForwardErrorCode {
  """
  Authenticated `MyUser` is not an author of the `ChatForward`.

  Status code: 403 Forbidden.
  """
  NOT_AUTHOR

  """
  `ChatForward` has been replied or forwarded to another `Chat`.

  Status code: 403 Forbidden.
  """
  QUOTED

  """
  `ChatForward` has been read by `Chat` members already.

  Only unread `ChatForward`s can be deleted.

  Status code: 403 Forbidden.
  """
  READ

  """
  `ChatForward` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM
}

"""Result of performing `Mutation.deleteChatForward`."""
union DeleteChatForwardResult = ChatEventsVersioned | DeleteChatForwardError

"""Error of performing `Mutation.deleteChatMessage`."""
type DeleteChatMessageError {
  """Code indicating why this error has happened."""
  code: DeleteChatMessageErrorCode!
}

"""Possible error codes of performing `Mutation.deleteChatMessage`."""
enum DeleteChatMessageErrorCode {
  """
  Authenticated `MyUser` is not an author of the `ChatMessage`.

  Status code: 403 Forbidden.
  """
  NOT_AUTHOR

  """
  `ChatMessage` has been replied or forwarded.

  Status code: 403 Forbidden.
  """
  QUOTED

  """
  `ChatMessage` has been read by `Chat` members already.

  Only unread `ChatMessage`s can be deleted.

  Status code: 403 Forbidden.
  """
  READ

  """
  `ChatMessage` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM
}

"""Result of performing `Mutation.deleteChatMessage`."""
union DeleteChatMessageResult = ChatEventsVersioned | DeleteChatMessageError

"""Error of performing `Mutation.editChatMessage`."""
type EditChatMessageError {
  """Code indicating why this error has happened."""
  code: EditChatMessageErrorCode!
}

"""Possible error codes of performing `Mutation.editChatMessage`."""
enum EditChatMessageErrorCode {
  """
  Authenticated `MyUser` is blocked by the `User` who receives the `ChatMessage`.

  This error can happen only if `Chat` represents a dialog (consists only of two `User`s).

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `ChatMessage`'s text can be set as `null` only if there is at least 1 `Attachment` in it.

  Status code: 400 Bad Request.
  """
  NO_TEXT_AND_NO_ATTACHMENT

  """
  Authenticated `MyUser` is not an author of the `ChatMessage`.

  Status code: 403 Forbidden.
  """
  NOT_AUTHOR

  """
  5 minutes passed since `ChatMessage` creation and it was read by other `Chat` members.

  Status code: 403 Forbidden.
  """
  UNEDITABLE

  """
  One of the specified `Attachment`s doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_ATTACHMENT

  """
  `ChatMessage` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM

  """
  Replied `ChatItem` doesn't exist in the `Chat`.

  Status code: 404 Not Found.
  """
  UNKNOWN_REPLYING_CHAT_ITEM

  """
  List of `Attachment`s should contain at most 100 elements.

  Status code: 400 Bad Request.
  """
  WRONG_ATTACHMENTS_COUNT

  """
  List of replied `ChatItem`s should contain at most 100 elements.

  Status code: 400 Bad Request.
  """
  WRONG_REPLYING_CHAT_ITEMS_COUNT
}

"""Result of performing `Mutation.editChatMessage`."""
union EditChatMessageResult = ChatEventsVersioned | EditChatMessageError

"""
Event of a `BlocklistRecord` being added to `Query.blocklist` of the
authenticated `MyUser`.
"""
type EventBlocklistRecordAdded implements BlocklistEvent {
  """Blocked `User`."""
  user: User!

  """Reason of why the `User` was blocked."""
  reason: BlocklistReason

  """`DateTime` when the `User` was blocked."""
  at: DateTime!
}

"""
Event of a `BlocklistRecord` being removed from `Query.blocklist` of the
authenticated `MyUser`.
"""
type EventBlocklistRecordRemoved implements BlocklistEvent {
  """Unblocked `User`."""
  user: User!

  """`DateTime` when the `User` was unblocked."""
  at: DateTime!
}

"""
Event of an answer timeout being reached in a `ChatCall`.

Not emitted for `ChatCall`s in `Chat`-monologs.
"""
type EventChatCallAnswerTimeoutPassed implements ChatCallEvent & ChatEvent {
  """ID of the `ChatCall` where the answer timeout was reached."""
  callId: ChatItemId!

  """`ChatCall` where the answer timeout was reached."""
  call: ChatCall!

  """ID of the `Chat` the `ChatCall` belongs to."""
  chatId: ChatId!

  """`Chat` the `ChatCall` belongs to."""
  chat: Chat!

  """
  ID of the `User` whose answer timeout was reached.

  If `null`, then the answer timeout was reached for all the `User`s being
  `ChatMember`s.
  """
  userId: UserId

  """
  `User` whose answer timeout was reached.

  If `null`, then the answer timeout was reached for all `User`s being
  `ChatMember`s.
  """
  user: User

  """`DateTime` when the answer timeout in the `ChatCall` was reached."""
  at: DateTime!
}

"""
Event of an audio/video conversation being started in a `ChatCall`, meaning
that enough `ChatCallMember`s joined the [Medea] room after ringing had been
finished.

[Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallConversationStarted implements ChatCallEvent & ChatEvent {
  """ID of the `ChatCall` the conversation started in."""
  callId: ChatItemId!

  """`ChatCall` the conversation started in."""
  call: ChatCall!

  """ID of the `Chat` the conversation's `ChatCall` belongs to."""
  chatId: ChatId!

  """`DateTime` when the conversation started."""
  at: DateTime!
}

"""Event of a `ChatCall` being declined by a `ChatMember`."""
type EventChatCallDeclined implements ChatCallEvent & ChatEvent {
  """ID of the `ChatCall` being declined."""
  callId: ChatItemId!

  """Declined `ChatCall`."""
  call: ChatCall!

  """ID of the `Chat` the declined `ChatCall` belongs to."""
  chatId: ChatId!

  """`User` who declined the `ChatCall`."""
  user: User!

  """`DateTime` when the `ChatCall` was declined."""
  at: DateTime!
}

"""
Event of a `ChatCall` being finished.

Client side may preliminarily disconnect from [Medea] media server when this
event is received.

[Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallFinished implements ChatCallEvent & ChatEvent {
  """ID of the finished `ChatCall`."""
  callId: ChatItemId!

  """Finished `ChatCall`."""
  call: ChatCall!

  """ID of the `Chat` the finished `ChatCall` belongs to."""
  chatId: ChatId!

  """Reason of why the `ChatCall` was finished."""
  reason: ChatCallFinishReason!

  """`DateTime` when the `ChatCall` was finished."""
  at: DateTime!
}

"""Event of a `ChatMember`'s hand being lowered in a `ChatCall`."""
type EventChatCallHandLowered implements ChatCallEvent {
  """ID of the `ChatCall` the `ChatMember`'s hand being lowered in."""
  callId: ChatItemId!

  """`ChatCall` the `ChatMember`'s hand being lowered in."""
  call: ChatCall!

  """ID of the `Chat` the `ChatCall` belongs to."""
  chatId: ChatId!

  """
  `User` representing the `ChatMember` who lowered a hand in the
  `ChatCall`.
  """
  user: User!

  """`DateTime` when the `ChatMember` lowered his hand in the `ChatCall`."""
  at: DateTime!
}

"""Event of a `ChatMember`'s hand being raised in a `ChatCall`."""
type EventChatCallHandRaised implements ChatCallEvent {
  """ID of the `ChatCall` the `ChatMember`'s hand being raised in."""
  callId: ChatItemId!

  """`ChatCall` the `ChatMember`'s hand being raised in."""
  call: ChatCall!

  """ID of the `Chat` the `ChatCall` belongs to."""
  chatId: ChatId!

  """
  `User` representing the `ChatMember` who raised a hand in the
  `ChatCall`.
  """
  user: User!

  """`DateTime` when the `ChatMember` raised his hand in the `ChatCall`."""
  at: DateTime!
}

"""Event of a `User` joined a `ChatCall`."""
type EventChatCallMemberJoined implements ChatCallEvent & ChatEvent {
  """ID of the joined `ChatCall`."""
  callId: ChatItemId!

  """Joined `ChatCall`."""
  call: ChatCall!

  """ID of the `Chat` the joined `ChatCall` belongs to."""
  chatId: ChatId!

  """`User` who joined the `ChatCall`."""
  user: User!

  """`ChatCallDeviceId` of the joined `User`."""
  deviceId: ChatCallDeviceId!

  """`DateTime` when the `User` joined the `ChatCall`."""
  at: DateTime!
}

"""Event of a `User` leaving a `ChatCall`."""
type EventChatCallMemberLeft implements ChatCallEvent & ChatEvent {
  """ID of the left `ChatCall`."""
  callId: ChatItemId!

  """Left `ChatCall`."""
  call: ChatCall!

  """ID of the `Chat` the left `ChatCall` belongs to."""
  chatId: ChatId!

  """`User` who left the `ChatCall`."""
  user: User!

  """
  Initiator of the `User` removing from the `ChatCall`.

  If this is another `User`, then the left `User` was kicked.
  """
  by: User!

  """`ChatCallDeviceId` of the `User` who left the `ChatCall`."""
  deviceId: ChatCallDeviceId!

  """`DateTime` when the `User` left the `ChatCall`."""
  at: DateTime!
}

"""Event of a `User` being redialed in a `ChatCall`."""
type EventChatCallMemberRedialed implements ChatCallEvent & ChatEvent {
  """ID of the `ChatCall` the `User` is redialed in."""
  callId: ChatItemId!

  """`ChatCall` the `User` is redialed in."""
  call: ChatCall!

  """ID of the `Chat` the `ChatCall` belongs to."""
  chatId: ChatId!

  """
  `User` representing the `ChatMember` who was redialed in the `ChatCall`.
  """
  user: User!

  """
  `User` representing the `ChatMember` who redialed the `User` in the
  `ChatCall`.
  """
  byUser: User!

  """`DateTime` when the `ChatMember` was redialed in the `ChatCall`."""
  at: DateTime!
}

"""Event of a dialed `User` being undialed in a `ChatCall`."""
type EventChatCallMemberUndialed implements ChatCallEvent & ChatEvent {
  """ID of the `ChatCall` the dialed `User` was undialed in."""
  callId: ChatItemId!

  """`ChatCall` the dialed `User` was undialed in."""
  call: ChatCall!

  """ID of the `Chat` the `ChatCall` belongs to."""
  chatId: ChatId!

  """
  `User` representing the dialed `ChatMember` being undialed in the
  `ChatCall`.
  """
  user: User!

  """
  `User` representing the `ChatMember` who undialed the dialed `User` in
  the `ChatCall`.
  """
  by: User!

  """
  `DateTime` when the dialed `ChatMember` was undialed in the `ChatCall`.
  """
  at: DateTime!
}

"""
Event of a `ChatCall` being moved from its `Chat`-dialog to a newly created
`Chat`-group.

Once this event is fired, it's required to establish a new
`Subscription.chatCallEvents` using the emitted
`EventChatCallMoved.newCallId`. Note, that the connection to the [Medea]
room of the moved `ChatCall` should not be dropped, as it's simply moved to
the returned `EventChatCallMoved.newCall`, ensuring smooth experience for
the `ChatCall` members.

[Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallMoved implements ChatCallEvent & ChatEvent {
  """ID of the moved `ChatCall` in the `Chat`-dialog."""
  callId: ChatItemId!

  """Moved `ChatCall` in the `Chat`-dialog."""
  call: ChatCall!

  """ID of the `Chat`-dialog the `ChatCall` was moved from."""
  chatId: ChatId!

  """ID of the newly created `Chat`-group the `ChatCall` was moved to."""
  newChatId: ChatId!

  """Newly created `Chat`-group the `ChatCall` was moved to."""
  newChat: Chat!

  """ID of the moved `ChatCall` in the newly created `Chat`-group."""
  newCallId: ChatItemId!

  """Moved `ChatCall` in the newly created `Chat`-group."""
  newCall: ChatCall!

  """`User` who moved the `ChatCall`."""
  user: User!

  """`DateTime` when the `ChatCall` was moved."""
  at: DateTime!
}

"""
Event of a [Medea] room being ready to accept the connection with the
authenticated `MyUser`.

Client side should connect to [Medea] media server when this event is
received. Use `EventChatCallRoomReady.joinLink` to reach the [Medea] media
server and the `ChatCallCredentials` (generated for
`Mutation.startChatCall` or `Mutation.joinChatCall`) to authenticate.
Otherwise, the authenticated `MyUser` will be kicked from the `ChatCall` by
timeout.

This event may be emitted multiple times during the same `Call`. Each time
client side should reconnect to the [Medea] media server using the returned
`EventChatCallRoomReady.joinLink`.

[Medea]: https://github.com/instrumetisto/medea
"""
type EventChatCallRoomReady implements ChatCallEvent {
  """
  ID of the `ChatCall` the [Medea] room is ready for.

  [Medea]: https://github.com/instrumetisto/medea
  """
  callId: ChatItemId!

  """
  `ChatCall` the [Medea] room is ready for.

  [Medea]: https://github.com/instrumetisto/medea
  """
  call: ChatCall!

  """ID of the `Chat` the ready `ChatCall` belongs to."""
  chatId: ChatId!

  """
  Link for joining the room on [Medea] media server.

  Use `ChatCallCredentials` (generated for `Mutation.startChatCall` or
  `Mutation.joinChatCall`) to authenticate.

  [Medea]: https://github.com/instrumetisto/medea
  """
  joinLink: ChatCallRoomJoinLink!

  """
  `DateTime` when the [Medea] room became ready.

  [Medea]: https://github.com/instrumetisto/medea
  """
  at: DateTime!
}

"""
Event of a `ChatCall` being started.

Either `Mutation.joinChatCall` or `Mutation.declineChatCall` should be
executed when this event is received. Otherwise, the authenticated `MyUser`
will be considered as timed out to answer the `ChatCall`.
"""
type EventChatCallStarted implements ChatEvent {
  """ID of the `ChatCall` being started."""
  callId: ChatItemId!

  """Started `ChatCall`."""
  call: ChatCall!

  """ID of the `Chat` the started `ChatCall` belongs to."""
  chatId: ChatId!

  """`DateTime` when the `ChatCall` was started."""
  at: DateTime!
}

"""Event of a `Chat` being cleared by the authenticated `MyUser`."""
type EventChatCleared implements ChatEvent {
  """ID of the `Chat` being cleared by the authenticated `MyUser`."""
  chatId: ChatId!

  """`DateTime` when the `Chat` was cleared."""
  at: DateTime!
}

"""Event of a new `ChatContact` being created."""
type EventChatContactCreated implements ChatContactEvent {
  """ID of the created `ChatContact`."""
  contactId: ChatContactId!

  """Name of the created `ChatContact`"""
  name: UserName!

  """`DateTime` when the `ChatContact` was created."""
  at: DateTime!
}

"""Event of a `ChatContact` being deleted."""
type EventChatContactDeleted implements ChatContactEvent {
  """ID of the deleted `ChatContact`."""
  contactId: ChatContactId!

  """`DateTime` when the `ChatContact` was deleted."""
  at: DateTime!
}

"""Event of a `ChatContactEmail` being added to the `ChatContact`."""
type EventChatContactEmailAdded implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """Added `ChatContactEmail`."""
  email: ChatContactEmail!

  """`DateTime` when the `ChatContactEmail` was added to the `ChatContact`."""
  at: DateTime!
}

"""Event of a `ChatContactEmail` being removed from the `ChatContact`."""
type EventChatContactEmailRemoved implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """Removed `ChatContactEmail`."""
  email: ChatContactEmail!

  """
  `DateTime` when the `ChatContactEmail` was removed from the
  `ChatContact`.
  """
  at: DateTime!
}

"""Event of a `ChatContact` being favorited."""
type EventChatContactFavorited implements ChatContactEvent {
  """ID of the favorited `ChatContact`."""
  contactId: ChatContactId!

  """Position of the `ChatContact` in the favorites list."""
  position: ChatContactFavoritePosition!

  """`DateTime` when the `ChatContact` was favorited."""
  at: DateTime!
}

"""Event of a `Chat`-group being added to the `ChatContact`."""
type EventChatContactGroupAdded implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """`Chat`-group added to the `ChatContact`."""
  group: Chat!

  """`DateTime` when the `Chat`-group was added to the `ChatContact`."""
  at: DateTime!
}

"""Event of a `Chat`-group being removed from a `ChatContact`."""
type EventChatContactGroupRemoved implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """ID of removed `Chat`-group."""
  groupId: ChatId!

  """`DateTime` when the `Chat`-group was removed from the `ChatContact`."""
  at: DateTime!
}

"""Event of a `ChatContact`'s name being updated."""
type EventChatContactNameUpdated implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """Updated name of the `ChatContact`."""
  name: UserName!

  """`DateTime` when the `ChatContact`'s name was updated."""
  at: DateTime!
}

"""Event of a `ChatContactPhone` being added to the `ChatContact`."""
type EventChatContactPhoneAdded implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """Added `ChatContactPhone`."""
  phone: ChatContactPhone!

  """`DateTime` when the `UserPhone` was added to the `ChatContact`."""
  at: DateTime!
}

"""Event of an `ChatContactPhone` being removed from a `ChatContact`."""
type EventChatContactPhoneRemoved implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """Removed `ChatContactPhone`."""
  phone: ChatContactPhone!

  """`DateTime` when the `UserPhone` was removed from the `ChatContact`."""
  at: DateTime!
}

"""Event of a `ChatContact` being unfavorited."""
type EventChatContactUnfavorited implements ChatContactEvent {
  """ID of the unfavorited `ChatContact`."""
  contactId: ChatContactId!

  """`DateTime` when the `ChatContact` was unfavorited."""
  at: DateTime!
}

"""Event of a `User` being added to the `ChatContact`."""
type EventChatContactUserAdded implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """`User` added to the `ChatContact`."""
  user: User!

  """`DateTime` when the `User` was added to the `ChatContact`."""
  at: DateTime!
}

"""Event of a `User` being removed from a `ChatContact`."""
type EventChatContactUserRemoved implements ChatContactEvent {
  """ID of the `ChatContact`."""
  contactId: ChatContactId!

  """ID of the removed `User`."""
  userId: UserId!

  """`DateTime` when the `User` was removed from the `ChatContact`."""
  at: DateTime!
}

"""
Event of posted `ChatItem`s being delivered to `ChatMember`s other than
the authenticated `MyUser`.
"""
type EventChatDelivered implements ChatEvent {
  """ID of the `Chat` where `ChatItem`s are delivered."""
  chatId: ChatId!

  """
  `DateTime` until which the `ChatItem`s in `Chat` were delivered.

  Can be used to determine whether the last `ChatItem` posted by the
  authenticated `MyUser` was delivered to other `ChatMember`s by checking
  it was posted not later than this `DateTime`.
  """
  until: DateTime!
}

"""Event of a `Chat`'s `ChatDirectLink` being deleted."""
type EventChatDirectLinkDeleted implements ChatEvent {
  """ID of the `Chat` which `ChatDirectLink` was deleted."""
  chatId: ChatId!
}

"""Event of a `Chat`'s `ChatDirectLink` being updated."""
type EventChatDirectLinkUpdated implements ChatEvent {
  """ID of the `Chat` which `ChatDirectLink` was updated."""
  chatId: ChatId!

  """New `Chat`'s `ChatDirectLink`."""
  directLink: ChatDirectLink!
}

"""Event of a `Chat`'s `ChatDirectLink.usageCount` being updated."""
type EventChatDirectLinkUsageCountUpdated implements ChatEvent {
  """ID of the `Chat` which `ChatDirectLink` was updated."""
  chatId: ChatId!

  """New `Chat`'s `ChatDirectLink.usageCount`."""
  usageCount: Int!
}

"""
Event of a `Chat` being added to the favorites list of the authenticated
`MyUser`.
"""
type EventChatFavorited implements ChatEvent & FavoriteChatsEvent {
  """ID of the favorited `Chat`."""
  chatId: ChatId!

  """Position of the `Chat` in the favorites list."""
  position: ChatFavoritePosition!

  """`DateTime` when the `Chat` was favorited."""
  at: DateTime!
}

"""Event of a `Chat` being hidden by the authenticated `MyUser`."""
type EventChatHidden implements ChatEvent {
  """ID of the `Chat` being hidden by the authenticated `MyUser`."""
  chatId: ChatId!

  """`DateTime` when the `Chat` was hidden."""
  at: DateTime!
}

"""Event of a `ChatItem` being deleted by some `User`."""
type EventChatItemDeleted implements ChatEvent {
  """ID of the `Chat` where `ChatItem` is being deleted by some `User`."""
  chatId: ChatId!

  """ID of the deleted `ChatItem`."""
  itemId: ChatItemId!
}

"""Event of a `ChatItem` being edited by its author."""
type EventChatItemEdited implements ChatEvent {
  """ID of the `Chat` where the `ChatItem` was edited by its author."""
  chatId: ChatId!

  """ID of the edited `ChatItem`."""
  itemId: ChatItemId!

  """
  Edited `ChatItem`'s text.

  `null` means that the previous `ChatItem`'s text remains unchanged.
  """
  text: ChangedChatMessageText

  """
  Edited `Attachment`s of the `ChatItem`.

  `null` means that the previous `Attachment`s remain unchanged.
  """
  attachments: ChangedChatMessageAttachments

  """
  `ChatItemQuote`s the edited `ChatItem` replies to.

  `null` means that the previous `ChatItemQuote`s remain unchanged.
  """
  repliesTo: ChangedChatMessageReplies
}

"""Event of a `ChatItem` being hidden by the authenticated `MyUser`."""
type EventChatItemHidden implements ChatEvent {
  """
  ID of the `Chat` where `ChatItem` is being hidden by the authenticated
  `MyUser`.
  """
  chatId: ChatId!

  """ID of the hidden `ChatItem`."""
  itemId: ChatItemId!
}

"""
Event of a new `ChatItem` being posted in a `Chat`.

If the `item` field contains a `ChatCall` this event is immediately followed
by a `EventChatCallStarted` right after. Making a `Subscription.chatEvents`
starting from the version of this event won't emit the related
`EventChatCallStarted`, however.
"""
type EventChatItemPosted implements ChatEvent {
  """ID of the `Chat` where `ChatItem` is being posted."""
  chatId: ChatId!

  """Posted `ChatItem`."""
  item: ChatItemsEdge!
}

"""Event of a `Chat` last item being updated."""
type EventChatLastItemUpdated implements ChatEvent {
  """ID of the `Chat` where last item was updated."""
  chatId: ChatId!

  """Updated last `ChatItem`."""
  lastItem: ChatItemsEdge
}

"""
Event of a `Chat` being muted by the authenticated `MyUser`.

Once `duration` pasts (or is in the past already), it should be considered
by a client side as automatically unmuted. Server won't notify a client side
about that.
"""
type EventChatMuted implements ChatEvent {
  """ID of the `Chat` being muted by the authenticated `MyUser`."""
  chatId: ChatId!

  """Duration the `Chat` should be muted until."""
  duration: MuteDuration!
}

"""Event of a `Chat` being read by a `User`."""
type EventChatRead implements ChatEvent {
  """ID of the `Chat` being read by the `User`."""
  chatId: ChatId!

  """`User` who read the `Chat`."""
  byUser: User!

  """`DateTime` when the `Chat` was read by the `User`."""
  at: DateTime!
}

"""Event of a `Chat` total items count being updated."""
type EventChatTotalItemsCountUpdated implements ChatEvent {
  """ID of the `Chat` where total items count was updated."""
  chatId: ChatId!

  """Updated total `ChatItem`s count."""
  count: Int!
}

"""Event of a `ChatMember` started typing in a `Chat`."""
type EventChatTypingStarted implements ChatEvent {
  """ID of the `Chat` where `User` started typing."""
  chatId: ChatId!

  """`User` who started typing."""
  user: User!
}

"""Event of a `ChatMember` stopped typing in a `Chat`."""
type EventChatTypingStopped implements ChatEvent {
  """ID of the `Chat` where `User` stopped typing."""
  chatId: ChatId!

  """`User` who stopped typing."""
  user: User!
}

"""
Event of a `Chat` being removed from the favorites list of the authenticated
`MyUser`.
"""
type EventChatUnfavorited implements ChatEvent & FavoriteChatsEvent {
  """ID of the unfavorited `Chat`."""
  chatId: ChatId!

  """`DateTime` when the `Chat` was unfavorited."""
  at: DateTime!
}

"""
Event of a `Chat` being unmuted by the authenticated `MyUser`.

This event means that `MyUser` had manually unmuted the `Chat` before
`MuteDuration` expired.
"""
type EventChatUnmuted implements ChatEvent {
  """ID of the `Chat` being unmuted by the authenticated `MyUser`."""
  chatId: ChatId!
}

"""Event of a `Chat` unread items count being updated."""
type EventChatUnreadItemsCountUpdated implements ChatEvent {
  """ID of the `Chat` where unread items count was updated."""
  chatId: ChatId!

  """Updated unread `ChatItem`s count."""
  count: Int!
}

"""
Event of a `ChatCall` becoming the topmost in `Query.incomingChatCalls`
list.
"""
type EventIncomingChatCallsTopChatCallAdded {
  """`ChatCall` becoming the topmost one."""
  call: ChatCall!
}

"""
Event of a `ChatCall` being removed from `Query.incomingChatCalls` list.
"""
type EventIncomingChatCallsTopChatCallRemoved {
  """`ChatCall` removed from the top."""
  call: ChatCall!
}

"""
Event of a `Chat` being removed from a top of `Query.recentChats` list.
"""
type EventRecentChatsTopChatDeleted {
  """ID of the `Chat` removed from the top."""
  chatId: ChatId!
}

"""Event of a `Chat` becoming the topmost in `Query.recentChats` list."""
type EventRecentChatsTopChatUpdated {
  """`Chat` becoming the topmost one."""
  chat: Chat!
}

"""Event of a `UserAvatar` being deleted."""
type EventUserAvatarDeleted implements UserEvent {
  """ID of the `User` whose `UserAvatar` was deleted."""
  userId: UserId!

  """`DateTime` when the `UserAvatar` was deleted."""
  at: DateTime!
}

"""Event of a `UserAvatar` being updated."""
type EventUserAvatarUpdated implements UserEvent {
  """ID of the `User` whose `UserAvatar` was updated."""
  userId: UserId!

  """New `UserAvatar`."""
  avatar: UserAvatar!

  """`DateTime` when the `UserAvatar` was updated."""
  at: DateTime!
}

"""Event of a `UserBio` being deleted."""
type EventUserBioDeleted implements UserEvent {
  """ID of the `User` whose `UserBio` was deleted."""
  userId: UserId!

  """`DateTime` when the `UserBio` was deleted."""
  at: DateTime!
}

"""Event of a `UserBio` being updated."""
type EventUserBioUpdated implements UserEvent {
  """ID of the `User` whose `UserBio` was updated."""
  userId: UserId!

  """New `UserBio`."""
  bio: UserBio!

  """`DateTime` when the `UserBio` was updated."""
  at: DateTime!
}

"""Event of a `UserCallCover` being deleted."""
type EventUserCallCoverDeleted implements UserEvent {
  """ID of the `User` whose `UserCallCover` was deleted."""
  userId: UserId!

  """`DateTime` when the `UserCallCover` was deleted."""
  at: DateTime!
}

"""Event of a `UserCallCover` being updated."""
type EventUserCallCoverUpdated implements UserEvent {
  """ID of the `User` whose `UserCallCover` was updated."""
  userId: UserId!

  """New `UserCallCover`."""
  callCover: UserCallCover!

  """`DateTime` when the `UserCallCover` was updated."""
  at: DateTime!
}

"""Event of a `User` coming offline."""
type EventUserCameOffline implements UserEvent {
  """ID of the `User` who came offline."""
  userId: UserId!

  """`DateTime` when the `User` was online the last time."""
  at: DateTime!
}

"""Event of a `User` coming online."""
type EventUserCameOnline implements UserEvent {
  """ID of the `User` who came online."""
  userId: UserId!
}

"""Event of a `User` being deleted."""
type EventUserDeleted implements UserEvent {
  """ID of the deleted `User`."""
  userId: UserId!

  """`DateTime` when the `User` was deleted."""
  at: DateTime!
}

"""Event of a `User`'s `ChatDirectLink` being deleted."""
type EventUserDirectLinkDeleted {
  """ID of the `User` whose `ChatDirectLink` was deleted."""
  userId: UserId!
}

"""Event of a `User`'s `ChatDirectLink` being updated."""
type EventUserDirectLinkUpdated {
  """ID of the `User` whose `ChatDirectLink` was updated."""
  userId: UserId!

  """New `User`'s `ChatDirectLink`."""
  directLink: ChatDirectLink!
}

"""Event of a `User`'s email address being added."""
type EventUserEmailAdded {
  """ID of the `User` whose email address was added."""
  userId: UserId!

  """Added `UserEmail`."""
  email: UserEmail!

  """`DateTime` when the `User`'s email address was added."""
  at: DateTime!
}

"""Event of a `User`'s email address being confirmed."""
type EventUserEmailConfirmed {
  """ID of the `User` whose email address was confirmed."""
  userId: UserId!

  """Confirmed `UserEmail`."""
  email: UserEmail!

  """`DateTime` when the `User`'s email address was confirmed."""
  at: DateTime!
}

"""Event of a `User`'s email address being deleted."""
type EventUserEmailDeleted {
  """ID of the `User` whose email address was deleted."""
  userId: UserId!

  """Deleted `UserEmail`."""
  email: UserEmail!

  """`DateTime` when the `User`'s email address was deleted."""
  at: DateTime!
}

"""Event of a `UserLogin` being updated."""
type EventUserLoginUpdated {
  """ID of the `User` whose log`UserLogin`in was updated."""
  userId: UserId!

  """New `UserLogin`."""
  login: UserLogin!

  """`DateTime` when the `UserLogin` was updated."""
  at: DateTime!
}

"""Event of a `User` being muted."""
type EventUserMuted {
  """ID of the muted `User`."""
  userId: UserId!

  """Duration of the mute."""
  until: MuteDuration!
}

"""Event of a `UserName` being deleted."""
type EventUserNameDeleted implements UserEvent {
  """ID of the `User` whose `UserName` was deleted."""
  userId: UserId!

  """`DateTime` when the `UserName` was deleted."""
  at: DateTime!
}

"""Event of a `UserName` being updated."""
type EventUserNameUpdated implements UserEvent {
  """ID of the `User` whose `UserName` was updated."""
  userId: UserId!

  """New `UserName`."""
  name: UserName!

  """`DateTime` when the `UserName` was updated."""
  at: DateTime!
}

"""Event of a `User`'s password being updated."""
type EventUserPasswordUpdated {
  """ID of the `User` whose password was updated."""
  userId: UserId!

  """`DateTime` when the `User`'s password was updated."""
  at: DateTime!
}

"""Event of a `User`'s phone number being added."""
type EventUserPhoneAdded {
  """ID of the `User` whose phone number was added."""
  userId: UserId!

  """Added `UserPhone`."""
  phone: UserPhone!

  """`DateTime` when the `User`'s phone number was added."""
  at: DateTime!
}

"""Event of a `User`'s phone number being confirmed."""
type EventUserPhoneConfirmed {
  """ID of the `User` whose phone number was confirmed."""
  userId: UserId!

  """Confirmed `UserPhone`."""
  phone: UserPhone!

  """`DateTime` when the `User`'s phone number was confirmed."""
  at: DateTime!
}

"""Event of a `User`'s phone number being deleted."""
type EventUserPhoneDeleted {
  """ID of the `User` whose phone number was deleted."""
  userId: UserId!

  """Deleted `UserPhone`."""
  phone: UserPhone!

  """`DateTime` when the `User`'s phone number was deleted."""
  at: DateTime!
}

"""Event of a `User`'s `Presence` being updated."""
type EventUserPresenceUpdated implements UserEvent {
  """ID of the `User` whose `Presence` was updated."""
  userId: UserId!

  """New `User`'s `Presence`."""
  presence: Presence!

  """`DateTime` when the `User`'s `Presence` was updated."""
  at: DateTime!
}

"""Event of a `UserTextStatus` being deleted."""
type EventUserStatusDeleted implements UserEvent {
  """ID of the `User` whose `UserTextStatus` was deleted."""
  userId: UserId!

  """`DateTime` when the `UserTextStatus` was deleted."""
  at: DateTime!
}

"""Event of a `UserTextStatus` being updated."""
type EventUserStatusUpdated implements UserEvent {
  """ID of the `User` whose `UserTextStatus` was updated."""
  userId: UserId!

  """New `UserTextStatus`."""
  status: UserTextStatus!

  """`DateTime` when the `UserTextStatus` was updated."""
  at: DateTime!
}

"""Event of a `User` being unmuted."""
type EventUserUnmuted {
  """ID of the unmuted `User`."""
  userId: UserId!
}

"""Event of a `User`'s unread `Chat`s count being updated."""
type EventUserUnreadChatsCountUpdated {
  """ID of the `User` whose unread `Chat`s count was updated."""
  userId: UserId!

  """New `User`'s unread `Chat`s count."""
  count: Int!
}

"""Error of performing `Mutation.favoriteChatContact`."""
type FavoriteChatContactError {
  """Code indicating why this error has happened."""
  code: FavoriteChatContactErrorCode!
}

"""Possible error codes of performing `Mutation.favoriteChatContact`."""
enum FavoriteChatContactErrorCode {
  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT
}

"""Result of performing `Mutation.favoriteChatContact`."""
union FavoriteChatContactResult = ChatContactEventsVersioned | FavoriteChatContactError

"""
[Connection] with favorite `ChatContact`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type FavoriteChatContactsConnection {
  """
  List of favorite `ChatContact` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [FavoriteChatContactsEdge!]!

  """
  List of favorite `ChatContact`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatContact!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!

  """
  Version of this `ChatContact`s list.

  It increases monotonically, so may be used (and is intended to) for
  tracking list state's actuality.

  Also, intended to be used in `Subscription.chatContactsEvents`.
  """
  ver: ChatContactsListVersion!
}

"""Cursor of favorite `ChatContact`s."""
scalar FavoriteChatContactsCursor

"""
[Edge] with a favorite `ChatContact`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type FavoriteChatContactsEdge {
  """
  `ChatContact` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatContact!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: FavoriteChatContactsCursor!
}

"""Error of performing `Mutation.favoriteChat`."""
type FavoriteChatError {
  """Code indicating why this error has happened."""
  code: FavoriteChatErrorCode!
}

"""Possible error codes of performing `Mutation.favoriteChat`."""
enum FavoriteChatErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.favoriteChat`."""
union FavoriteChatResult = ChatEventsVersioned | FavoriteChatError

"""
[Connection] with favorite `Chat`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type FavoriteChatsConnection {
  """
  List of favorite `Chat` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [FavoriteChatsEdge!]!

  """
  List of favorite `Chat`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [Chat!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!

  """
  Version of this favorite `Chat`s list.

  It increases monotonically, so may be used (and is intended to) for
  tracking list state's actuality.

  Also, intended to be used in `Subscription.favoriteChatsEvents`.
  """
  ver: FavoriteChatsListVersion!
}

"""Cursor of favorite `Chat`s."""
scalar FavoriteChatsCursor

"""
[Edge] with a favorite `Chat`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type FavoriteChatsEdge {
  """
  `Chat` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: Chat!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: FavoriteChatsCursor!
}

"""Events happening in a `FavoriteChatsList`."""
interface FavoriteChatsEvent {
  """ID of the `Chat` this `FavoriteChatsEvent` is happened in."""
  chatId: ChatId!

  """`DateTime` when this `FavoriteChatsEvent` happened."""
  at: DateTime!
}

"""Events indicating changes in a `Query.favoriteChats`."""
union FavoriteChatsEvents = SubscriptionInitialized | FavoriteChatsList | FavoriteChatsEventsVersioned

"""
`FavoriteChatsEvent`s along with the corresponding
`FavoriteChatsListVersion`.
"""
type FavoriteChatsEventsVersioned {
  """`FavoriteChatsEvent`s themselves."""
  events: [FavoriteChatsEvent!]!

  """
  Version of the `FavoriteChatsList`'s state updated by these
  `FavoriteChatsEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: FavoriteChatsListVersion!
}

"""List of favorite `Chat`s."""
type FavoriteChatsList {
  """
  Returns favorite `Chat`s of the authenticated `MyUser` ordered by the
  custom order of `MyUser`'s favorites list (using `Chat.favoritePosition`
  field).

  Aliases `Query.favoriteChats`.
  """
  chats(
    """Number of next `Chat`s to return."""
    first: Int

    """
    Cursor indicating the `FavoriteChatsEdge` position to return next `Chat`s after.
    """
    after: FavoriteChatsCursor

    """Number of prior `Chat`s to return."""
    last: Int

    """
    Cursor indicating the `FavoriteChatsEdge` position to return prior `Chat`s before.
    """
    before: FavoriteChatsCursor
  ): FavoriteChatsConnection!
}

"""
Version of a favorite `Chat`s list.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar FavoriteChatsListVersion

"""
[Firebase Cloud Messaging][0] registration token.

Its values are always considered to be non-empty, and meet the following
requirements:
- be maximum 512 bytes long.

See [Firebase Cloud Messaging][0] documentation for how to generate
`FcmRegistrationToken`s [for Flutter][1] and [for JavaScript][2].

[0]: https://firebase.google.com/docs/cloud-messaging
[1]: https://firebase.google.com/docs/cloud-messaging/flutter/client
[2]: https://firebase.google.com/docs/cloud-messaging/js/client
"""
scalar FcmRegistrationToken

"""File on a file storage."""
interface File {
  """
  [Relative reference][1] to this `File` on a file storage.

  Prepend it with a file storage URL to obtain the full link to this
  `File`.

  If `404` HTTP status code is returned while trying to download this
  `File` from a file storage, then the `File` is not ready yet. Back off,
  and retry again later.

  `403` HTTP status code, on the other hand, means that the link has been
  expired and this [relative reference][1] should be re-fetched to rebuild
  the link.

  [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!

  """
  [SHA-256] checksum of this `File`.

  May be `null` in case this `File` is not ready on a file storage yet.
  May be also computed on a client side, once this `File` is ready and
  successfully downloaded from a file storage.

  This checksum is especially useful if a client side requires to verify
  the integrity and authenticity of this `File`, downloaded from a file
  storage.

  Also, this checksum may be useful as a key in a client side cache,
  allowing to store `File`s in deduplicated manner.

  [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String

  """
  Size of this `File` (in bytes).

  May be `null` in case this `File` is not ready on a file storage yet.
  May be also computed on a client side, once this `File` is ready and
  successfully downloaded from a file storage.
  """
  size: Int
}

"""Plain file `Attachment`."""
type FileAttachment implements Attachment {
  """Unique ID of this `FileAttachment`."""
  id: AttachmentId!

  """Original `PlainFile` representing this `FileAttachment`."""
  original: PlainFile!

  """Uploaded `PlainFile`'s name."""
  filename: String!
}

"""Error of performing `Mutation.forwardChatItems`."""
type ForwardChatItemsError {
  """Code indicating why this error has happened."""
  code: ForwardChatItemsErrorCode!
}

"""Possible error codes of performing `Mutation.forwardChatItems`."""
enum ForwardChatItemsErrorCode {
  """
  Authenticated `MyUser` is blocked by the `User`, who receives the `ChatForward`.

  This error can happen only if `Chat` represents a dialog (consists only of two `User`s).

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  Either `withText` field or at least one ID in `attachments` field should be specified in all of the `ChatItemQuoteInput`s.

  Status code: 400 Bad Request.
  """
  NO_TEXT_AND_NO_ATTACHMENT

  """
  One of the specified `Attachment`s doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_ATTACHMENT

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  One or more forwarded `Attachments`s don't belong to the corresponding `ChatItem`s.

  Status code: 404 Not Found.
  """
  UNKNOWN_FORWARDED_ATTACHMENT

  """
  One or more forwarded `ChatItem`s not found.

  Status code: 404 Not Found.
  """
  UNKNOWN_FORWARDED_ITEM

  """
  One or more forwarded `ChatItem`s have an unsupported kind. Only `ChatMessage` and `ChatForward` are allowed.

  Status code: 400 Bad Request.
  """
  UNSUPPORTED_FORWARDED_ITEM

  """
  List of `Item`s to forward should contain at least 1 element and at most 100 elements.

  Status code: 400 Bad Request.
  """
  WRONG_ITEMS_COUNT
}

"""Result of performing `Mutation.forwardChatItems`."""
union ForwardChatItemsResult = ChatEventsVersioned | ForwardChatItemsError

"""Error of performing `Mutation.hideChat`."""
type HideChatError {
  """Code indicating why this error has happened."""
  code: HideChatErrorCode!
}

"""Possible error codes of performing `Mutation.hideChat`."""
enum HideChatErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Error of performing `Mutation.hideChatItem`."""
type HideChatItemError {
  """Code indicating why this error has happened."""
  code: HideChatItemErrorCode!
}

"""Possible error codes of performing `Mutation.hideChatItem`."""
enum HideChatItemErrorCode {
  """
  `ChatItem` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM
}

"""Result of performing `Mutation.hideChatItem`."""
union HideChatItemResult = ChatEventsVersioned | HideChatItemError

"""Result of performing `Mutation.hideChat`."""
union HideChatResult = ChatEventsVersioned | HideChatError

"""Image `Attachment`."""
type ImageAttachment implements Attachment {
  """Unique ID of this `ImageAttachment`."""
  id: AttachmentId!

  """Original `ImageFile` representing this `ImageAttachment`."""
  original: ImageFile!

  """Uploaded `ImageFile`'s name."""
  filename: String!

  """
  `big` view `ImageFile` of this `ImageAttachment`, scaled proportionally
  to `800px` of its maximum dimension (either width or height).
  """
  big: ImageFile!

  """
  `medium` view `ImageFile` of this `ImageAttachment`, scaled
  proportionally to `200px` of its maximum dimension (either width or
  height).
  """
  medium: ImageFile!

  """
  `small` view `ImageFile` of this `ImageAttachment`, scaled
  proportionally to `30px` of its maximum dimension (either width or
  height).
  """
  small: ImageFile!
}

"""Image-`File` on a file storage."""
type ImageFile implements File {
  """
  [Relative reference][1] to this `ImageFile` on a file storage.

  Prepend it with a file storage URL to obtain the full link to this
  `ImageFile`.

  If `404` HTTP status code is returned while trying to download this
  `ImageFile` from a file storage, then the `ImageFile` is not ready yet.
  Back off, and retry again later.

  `403` HTTP status code, on the other hand, means that the link has been
  expired and this [relative reference][1] should be re-fetched to rebuild
  the link.

  [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!

  """Width of this `ImageFile` in pixels."""
  width: Int

  """Height of this `ImageFile` in pixels."""
  height: Int

  """
  [SHA-256] checksum of this `ImageFile`.

  May be `null` in case this `ImageFile` is not ready on a file storage
  yet. May be also computed on a client side, once this `ImageFile`
  is ready and successfully downloaded from a file storage.

  This checksum is especially useful if a client side requires to verify
  the integrity and authenticity of this `ImageFile`, downloaded from
  a file storage.

  Also, this checksum may be useful as a key in a client side cache,
  allowing to store `ImageFile`s in deduplicated manner.

  [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String

  """
  Size of this `ImageFile` (in bytes).

  May be `null` in case this `ImageFile` is not ready on a file storage
  yet. May be also computed on a client side, once this `ImageFile`
  is ready and successfully downloaded from a file storage.
  """
  size: Int

  """
  [Base64URL]-encoded [ThumbHash] of this `ImageFile`.

  May be `null` in case this `ImageFile` is an `original`, or it is not
  ready on a file storage yet.

  This [ThumbHash] is especially useful on a client side to pre-render
  this `ImageFile` before downloading it from a file storage.

  > __WARNING__: As [ThumbHash] dimensions are 32 pixels at most, the
  >              aspect ratio of this `thumbhash` may differ a little bit
  >              from the one of `width` and `height` fields, due to
  >              precision loss in rescaling process. That's why, to
  >              pre-render this `ImageFile` properly, just scaling the
  >              `thumbhash` proportionally won't be enough, and it rather
  >              should be stretched to fill the whole area of `width` and
  >              `height` dimensions.

  [Base64URL]: https://base64.guru/standards/base64url
  [ThumbHash]: https://evanw.github.io/thumbhash
  """
  thumbhash: ThumbHash
}

"""
[Connection] used in `Query.incomingChatCalls`.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type IncomingChatCallsConnection {
  """
  List of incoming `ChatCall` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [IncomingChatCallsEdge!]!

  """
  List of incoming `ChatCall`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [ChatCall!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""Cursor of incoming `ChatCall`s."""
scalar IncomingChatCallsCursor

"""
[Edge] used in `Query.incomingChatCalls`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type IncomingChatCallsEdge {
  """
  Incoming `ChatCall` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: ChatCall!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: IncomingChatCallsCursor!
}

"""
Initial top of `Query.incomingChatCalls` list emitted by
`Subscription.incomingChatCallsTopEvents`.
"""
type IncomingChatCallsTop {
  """
  List of top incoming `ChatCall`s.

  ## Sorting

  Returned `ChatCall`s are sorted primarily by their starting `DateTime`,
  and secondary by their IDs (if the starting `DateTime` is the same), in
  descending order.
  """
  list: [ChatCall!]!
}

"""Events emitted by `Subscription.incomingChatCallsTopEvents`."""
union IncomingChatCallsTopEvents = SubscriptionInitialized | IncomingChatCallsTop | EventIncomingChatCallsTopChatCallAdded | EventIncomingChatCallsTopChatCallRemoved

"""
Information about some `User` being present in a `Query.blocklist` of the
authenticated `MyUser`.
"""
type IsBlocked {
  """
  `BlocklistRecord` of the `User` in the `Query.blocklist`.

  `null` if the `User` is not blocked by the authenticated `MyUser`.
  """
  record: BlocklistRecord

  """Version of the authenticated `MyUser`'s state."""
  ver: MyUserVersion!
}

"""Error of performing `Mutation.joinChatCall`."""
type JoinChatCallError {
  """Code indicating why this error has happened."""
  code: JoinChatCallErrorCode!
}

"""Possible error codes of performing `Mutation.joinChatCall`."""
enum JoinChatCallErrorCode {
  """
  There is no ongoing `ChatCall` in this `Chat` at the moment.

  Status code: 404 Not Found.
  """
  NO_CALL

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of a successful performing `Mutation.joinChatCall`."""
type JoinChatCallOk {
  """
  ID of the device the authenticated `MyUser` joined the `ChatCall` from.

  Use this ID in `Subscription.chatCallEvents` and
  `Mutation.leaveChatCall` to distinguish between different devices of the
  authenticated `MyUser`.
  """
  deviceId: ChatCallDeviceId!

  """
  The only `ChatEvent` which may be produced by performing
  `Mutation.joinChatCall`:
  - `EventChatCallMemberJoined`.

  `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

"""Result of performing `Mutation.joinChatCall`."""
union JoinChatCallResult = JoinChatCallOk | JoinChatCallError

"""Information about a `Chat` being read last time by a `User`."""
type LastChatRead {
  """ID of the `User` who read the `Chat`."""
  memberId: UserId!

  """`DateTime` when the `Chat` was read last time."""
  at: DateTime!
}

"""Error of performing `Mutation.leaveChatCall`."""
type LeaveChatCallError {
  """Code indicating why this error has happened."""
  code: LeaveChatCallErrorCode!
}

"""Possible error codes of performing `Mutation.leaveChatCall`."""
enum LeaveChatCallErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `User`'s device with the provided ID doesn't participate in the `ChatCall`.

  Status code: 404 Not Found.
  """
  UNKNOWN_DEVICE
}

"""Result of performing `Mutation.leaveChatCall`."""
union LeaveChatCallResult = ChatEventsVersioned | LeaveChatCallError

type Mutation {
  """
  Creates a new `MyUser` having only `id` and unique `num` fields, along
  with a `Session` for him (valid for the returned expiration).

  The created `Session` may be prolonged via `Mutation.renewSession`.

  Once the created `Session` expires and cannot be prolonged, the created
  `MyUser` looses its access, if he doesn't provide a password via
  `Mutation.updateUserPassword` within that period of time.

  [`User-Agent` HTTP header][0] must be specified for this action and meet
  the `UserAgent` scalar format.

  ## Authentication

  None.

  ## Non-idempotent

  Each time creates a new unique `MyUser` and a new `Session`.

  [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  createUser: CreateUserResult!

  """
  Adds a new `email` address for the authenticated `MyUser`.

  Sets the given `email` address as an `unconfirmed` sub-field of a
  `MyUser.emails` field and sends to this address an email message with a
  `ConfirmationCode`. Once the `MyUser` successfully uses this
  `ConfirmationCode` in a `Mutation.confirmUserEmail`, the `email` address
  becomes a confirmed one and moves to `MyUser.emails.confirmed` sub-field
  unlocking the related capabilities.

  `MyUser` can have maximum one `MyUser.emails.unconfirmed` address at the
  same time.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserEmailAdded`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the provided `email`
  is already present in a `MyUser.emails` field (either in `confirmed` or
  `unconfirmed` sub-field).
  """
  addUserEmail(
    """Email address to add to `MyUser.emails`."""
    email: UserEmail!
  ): AddUserEmailResult

  """
  Adds a new `phone` number for the authenticated `MyUser`.

  Sets the given `phone` number as an `unconfirmed` sub-field of a
  `MyUser.phones` field and sends to this number SMS with a
  `ConfirmationCode`. Once the `MyUser` successfully uses this
  `ConfirmationCode` in a `Mutation.confirmUserPhone`, the `phone` number
  becomes a confirmed one and moves to `MyUser.phones.confirmed` sub-field
  unlocking the related capabilities.

  `MyUser` can have maximum one `MyUser.phone.unconfirmed` number at the
  same time.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserPhoneAdded`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the provided `phone`
  already is present in a `MyUser.phones` field (either in `confirmed` or
  `unconfirmed` sub-field).
  """
  addUserPhone(
    """Phone number to add to `MyUser.phones`."""
    phone: UserPhone!
  ): AddUserPhoneResult

  """
  Resends a new `ConfirmationCode` to the `MyUser.emails.unconfirmed`
  address of the authenticated `MyUser`.

  Once the authenticated `MyUser` successfully uses this
  `ConfirmationCode` in the `Mutation.confirmUserEmail`, the given `email`
  address moves to the `MyUser.emails.confirmed` sub-field unlocking the
  related capabilities.

  The number of generated `ConfirmationCode`s is limited up to 10 per 1
  hour.

  ## Authentication

  Mandatory.

  ## Result

  Always returns `null` on success.

  ## Non-idempotent

  Each time generates a new `ConfirmationCode`.
  """
  resendUserEmailConfirmation: ResendUserEmailConfirmationErrorCode

  """
  Resends a new `ConfirmationCode` to the `MyUser.phones.unconfirmed`
  number of the authenticated `MyUser`.

  Once the authenticated `MyUser` successfully uses this
  `ConfirmationCode` in the `Mutation.confirmUserPhone`, the given `phone`
  number moves to the `MyUser.phones.confirmed` sub-field unlocking the
  related capabilities.

  The number of generated `ConfirmationCode`s is limited up to 10 per 1
  hour.

  ## Authentication

  Mandatory.

  ## Result

  Always returns `null` on success.

  ## Non-idempotent

  Each time generates a new `ConfirmationCode`.
  """
  resendUserPhoneConfirmation: ResendUserPhoneConfirmationErrorCode

  """
  Confirms the `MyUser.emails.unconfirmed` address with the provided
  `ConfirmationCode` for the authenticated `MyUser`, and moves it to the
  `MyUser.emails.confirmed` sub-field unlocking the related capabilities.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` is always produced on success:
  - `EventUserEmailConfirmed`.

  ## Non-idempotent

  Errors with `WRONG_CODE` if the provided `ConfirmationCode` has been
  used already.
  """
  confirmUserEmail(
    """Email address `ConfirmationCode`."""
    code: ConfirmationCode!
  ): ConfirmUserEmailResult!

  """
  Confirms the `MyUser.phones.unconfirmed` number with the provided
  `ConfirmationCode` for the authenticated `MyUser`, and moves it to the
  `MyUser.phones.confirmed` sub-field unlocking the related capabilities.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` is always produced on success:
  - `EventUserPhoneConfirmed`.

  ## Non-idempotent

  Errors with `WRONG_CODE` if the provided `ConfirmationCode` has been
  used already.
  """
  confirmUserPhone(
    """Phone number `ConfirmationCode`."""
    code: ConfirmationCode!
  ): ConfirmUserPhoneResult!

  """
  Deletes the provided `email` address from the `MyUser.emails` field of
  the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserEmailDeleted`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` doesn't have the provided `email` in his `MyUser.emails`
  already.
  """
  deleteUserEmail(
    """`UserEmail` address to delete from `MyUser.emails`."""
    email: UserEmail!
  ): MyUserEventsVersioned

  """
  Deletes the provided `phone` number from the `MyUser.phones` field of
  the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserPhoneDeleted`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` doesn't have the provided `phone` in his `MyUser.phones`
  already.
  """
  deleteUserPhone(
    """`UserPhone` number to delete from `MyUser.phones`."""
    phone: UserPhone!
  ): MyUserEventsVersioned

  """
  Updates the `MyUser.login` field of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserLoginUpdated`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` uses the provided `login` already.
  """
  updateUserLogin(
    """Login to update `MyUser` with."""
    login: UserLogin!
  ): UpdateUserLoginResult

  """
  Updates or resets the `MyUser.name` field of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent`s may be produced on success:
  - `EventUserNameUpdated` (if `name` argument is specified);
  - `EventUserNameDeleted` (if `name` argument is absent or is `null`).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` uses the provided `name` already.
  """
  updateUserName(
    """
    Name to update `MyUser` with.

    If absent or is `null` then the `MyUser.name` field will be reset.
    """
    name: UserName
  ): MyUserEventsVersioned

  """
  Updates or resets the `MyUser.bio` field of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent`s may be produced on success:
  - `EventUserBioUpdated` (if the `bio` argument is specified);
  - `EventUserBioDeleted` (if the `bio` argument is absent or is `null`).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` uses the provided `bio` already.
  """
  updateUserBio(
    """
    Bio to update the authenticated `MyUser` with.

    If absent or is `null` then the `MyUser.bio` field will be reset.
    """
    bio: UserBio
  ): MyUserEventsVersioned

  """
  Updates password of the authenticated `MyUser`.

  If the authenticated `MyUser` has no password yet (when sets his
  password), then `old` password is not required. Otherwise (when changes
  his password), it's mandatory to specify the `old` one.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` is always produced on success:
  - `EventUserPasswordUpdated`.

  ## Non-idempotent

  Each time renews the password (recalculates hash) even if it's the same
  one.
  """
  updateUserPassword(
    """Password to update `MyUser` with."""
    new: UserPassword!

    """Current password of `MyUser` for mutation authentication (if exists)."""
    old: UserPassword
  ): UpdateUserPasswordResult!

  """
  Initiates password recovery for the `MyUser` identified by the provided
  `num`/`login`/`email`/`phone` (exactly one of fourth should be
  specified).

  Sends a recovery `ConfirmationCode` to the `MyUser`'s `email` addresses
  and `phone` numbers.

  If the `MyUser` has no password yet, then this mutation still may be
  used for recovering his sign-in capability.

  The number of generated `ConfirmationCode`s is limited up to 10 per 1
  hour.

  ## Authentication

  None.

  ## Result

  Always returns `true` on success.

  ## Non-idempotent

  Each time sends a new unique password recovery `ConfirmationCode`.
  """
  recoverUserPassword(
    """Number of `MyUser`."""
    num: UserNum

    """Login of `MyUser`."""
    login: UserLogin

    """Email address of `MyUser`."""
    email: UserEmail

    """Phone number of `MyUser`."""
    phone: UserPhone
  ): Boolean!

  """
  Validates the provided password recovery `ConfirmationCode` for the
  `MyUser` identified by the provided `num`/`login`/`email`/`phone`
  (exactly one of fourth should be specified).

  ## Authentication

  None.

  ## Result

  Always returns `null` on success.

  ## Idempotent

  `ConfirmationCode` can be validated unlimited number of times (for now).
  """
  validateUserPasswordRecoveryCode(
    """Number of `MyUser`."""
    num: UserNum

    """Login of `MyUser`."""
    login: UserLogin

    """Email address of `MyUser`."""
    email: UserEmail

    """Phone number of `MyUser`."""
    phone: UserPhone

    """Recovery `ConfirmationCode` to validate."""
    code: ConfirmationCode!
  ): ValidateUserPasswordRecoveryErrorCode

  """
  Resets password for the `MyUser` identified by the provided
  `num`/`login`/`email`/`phone` (exactly one of fourth should be
  specified), authenticating the mutation with the provided recovery
  `ConfirmationCode`.

  If the `MyUser` has no password yet, then `new_password` will be his
  first password unlocking the sign-in capability.

  ## Authentication

  None.

  ## Result

  Only the following `MyUserEvent` is always produced on success:
  - `EventUserPasswordUpdated`.

  ## Non-idempotent

  Errors with `WRONG_CODE` if the provided `ConfirmationCode` was used
  already.
  """
  resetUserPassword(
    """Number of `MyUser`."""
    num: UserNum

    """Login of `MyUser`."""
    login: UserLogin

    """Email address of `MyUser`."""
    email: UserEmail

    """Phone number of `MyUser`."""
    phone: UserPhone

    """Password to update `MyUser` with."""
    newPassword: UserPassword!

    """
    Recovery `ConfirmationCode` for `MyUser` identification and mutation authentication.
    """
    code: ConfirmationCode!
  ): ResetUserPasswordResult!

  """
  Updates or resets the `MyUser.avatar` field with the provided image
  file.

  HTTP request for this mutation must be
  `Content-Type: multipart/form-data` containing the uploaded file and the
  `file` argument itself must be `null`, otherwise this mutation will
  fail.

  See [GraphQL multipart request specification][1] for details.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent`s may be produced on success:
  - `EventUserAvatarUpdated` (if image `file` is provided);
  - `EventUserAvatarDeleted` (if image `file` is not provided).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` uses the specified image `file` already as his `avatar` with
  the same `crop` area.

  [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  updateUserAvatar(
    """
    File to use as a `UserAvatar`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded file's size is 15 MiB.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
    """
    file: Upload

    """
    Optional area to crop the uploaded image.

    Only makes sense if the image file is provided.
    """
    crop: CropAreaInput
  ): UpdateUserAvatarResult

  """
  Updates or resets the `MyUser.callCover` field with the provided image
  file.

  HTTP request for this mutation must be
  `Content-Type: multipart/form-data` containing the uploaded file and the
  `file` argument itself must be `null`, otherwise this mutation will
  fail.

  See [GraphQL multipart request specification][1] for details.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent`s may be produced on success:
  - `EventUserCallCoverUpdated` (if image file is provided);
  - `EventUserCallCoverDeleted` (if image file is not provided).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` uses the specified image `file` already as his `callCover` with
  the same `crop` area.

  [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  updateUserCallCover(
    """
    File to use as a `UserCallCover`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded file's size is 15 MiB.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
    """
    file: Upload

    """
    Optional area to crop the uploaded image.

    Only makes sense if the image file is provided.
    """
    crop: CropAreaInput
  ): UpdateUserCallCoverResult

  """
  Mutes or unmutes all the `Chat`s of the authenticated `MyUser`.
  Overrides any already existing mute even if it's longer.

  Muted `MyUser` implies that all his `Chat`s events don't produce sounds
  and notifications on a client side. This, however, has nothing to do
  with a server and is the responsibility to be satisfied by a client
  side. Server side may try to optimize this in some cases (like omit
  sending notifications), but a client side should not rely on any such
  behaviour and should implement best-effort muting by itself.

  Note, that `Mutation.toggleMyUserMute` doesn't correlate with
  `Mutation.toggleChatMute`. Unmuted `Chat` of muted `MyUser` should not
  produce any sounds, and so, muted `Chat` of unmuted `MyUser` should not
  produce any sounds too.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent` may be produced on success:
  - `EventUserMuted` (if `mute` argument is not `null`);
  - `EventUserUnmuted` (if `mute` argument is `null`).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` is muted already `until` the specified `DateTime` (or unmuted).
  """
  toggleMyUserMute(
    """
    Muting options for the authenticated `MyUser`.

    `null` means unmuting.
    """
    mute: Muting
  ): ToggleMyUserMuteResult

  """
  Updates the `MyUser.presence` field of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` may be produced on success:
  - `EventUserPresenceUpdated`.

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` has the provided `presence` value already.
  """
  updateUserPresence(
    """`Presence` to update `MyUser` with."""
    presence: Presence!
  ): MyUserEventsVersioned

  """
  Updates or resets the `MyUser.status` field of the authenticated
  `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `MyUserEvent`s may be produced on success:
  - `EventUserStatusUpdated` (if `text` argument is specified);
  - `EventUserStatusDeleted` (if `text` argument is absent or is `null`).

  ## Idempotent

  Succeeds as no-op (and returns no `MyUserEvent`) if the authenticated
  `MyUser` has the provided `text` as his `status` value already.
  """
  updateUserStatus(
    """
    `UserTextStatus` to update `MyUser` with.

    If absent or is `null` then the `MyUser.status` field will be reset.
    """
    text: UserTextStatus
  ): MyUserEventsVersioned

  """
  Deletes the authenticated `MyUser` completely.

  **This action cannot be reverted.**

  Also deletes all the `Session`s and `RememberedSession`s of the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `MyUserEvent` is always produced on success:
  - `EventUserDeleted`.

  ## Non-idempotent

  Once deleted `MyUser` cannot be deleted again.
  """
  deleteMyUser: MyUserEventsVersioned!

  """
  Creates a new `Session` for the `MyUser` identified by the provided
  `num`/`login`/`email` (exactly one of three should be specified).

  Represents a sing-in action.

  The created `Session` has expiration, which may be prolonged via
  `Mutation.renewSession`.

  [`User-Agent` HTTP header][0] must be specified for this action and meet
  the `UserAgent` scalar format.

  ## Authentication

  None.

  ## Non-idempotent

  Each time creates a new `Session`.

  [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  createSession(
    """Number of `MyUser` to create the `Session` for."""
    num: UserNum

    """Login of `MyUser` to create the `Session` for."""
    login: UserLogin

    """Email address of `MyUser` to create the `Session` for."""
    email: UserEmail

    """Phone number of `MyUser` to create the `Session` for."""
    phone: UserPhone

    """Password of `MyUser` to authenticate with."""
    password: UserPassword!
  ): CreateSessionResult!

  """
  Renews a `Session` of the `MyUser` identified by the provided
  `RefreshToken`.

  Invalidates the provided `RefreshToken` and returns a new one, which
  should be used instead.

  The renewed `Session` has its own expiration after renewal, so to renew
  it again use this mutation with the new returned `RefreshToken` (omit
  using old ones).

  The expiration of the renewed `RememberedSession` is not prolonged
  comparing to the previous one, and remains the same for all the
  `RememberedSession`s obtained via `Mutation.renewSession`. Use
  `Mutation.createSession` to reset expiration of a `RememberedSession`.

  [`User-Agent` HTTP header][0] must be specified for this action and meet
  the `UserAgent` scalar format.

  ## Authentication

  None.

  ## Non-idempotent

  Each time creates a new `Session` and generates a new `RefreshToken`.

  [0]: https://developer.mozilla.org/docs/Web/HTTP/Headers/User-Agent
  """
  renewSession(
    """
    `RefreshToken` for mutation authentication and `MyUser` identification.
    """
    token: RefreshToken!
  ): RenewSessionResult!

  """
  Destroys the `Session` (and the associated `RememberedSession`, if
  exists) identified by the provided `AccessToken` of the authenticated
  `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Always returns `true` on success.

  ## Idempotent

  Succeeds as no-op if the `Session` with the provided `AccessToken` has
  been deleted already.
  """
  deleteSession(
    """`AccessToken` of the `Session` to destroy."""
    token: AccessToken!
  ): Boolean!

  """
  Creates a `Chat`-monolog for the authenticated `MyUser`.

  There can be only one `Chat`-monolog for the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Idempotent

  Succeeds as no-op if the `Chat`-monolog for the authenticated `MyUser`
  exists already, and returns it.
  """
  createMonologChat(
    name: ChatName

    """Indicates whether the created `Chat`-monolog should be hidden."""
    isHidden: Boolean
  ): Chat!

  """
  Creates a `Chat`-dialog with the provided responder `User` for the
  authenticated `MyUser`.

  There can be only one `Chat`-dialog between two `User`s.

  ## Authentication

  Mandatory.

  ## Idempotent

  Succeeds as no-op if a `Chat` with the given responder `User` exists
  already, and returns this `Chat`.
  """
  createDialogChat(
    """ID of the responder `User` to create a `Chat`-dialog with."""
    responderId: UserId!
  ): CreateDialogChatResult!

  """
  Creates a `Chat`-group with the provided `User`s as members and the
  authenticated `MyUser`.

  There can be many `Chat`-group between the same `User`s.

  ## Authentication

  Mandatory.

  ## Non-idempotent

  Each time creates a new `Chat`-group.
  """
  createGroupChat(
    """IDs of the `User`s to create a `Chat`-group with."""
    memberIds: [UserId!]!

    """Optional name to assign to the created `Chat`-group."""
    name: ChatName
  ): CreateGroupChatResult!

  """
  Marks the specified `Chat` as favorited for the authenticated `MyUser`
  and sets its position in the favorites list.

  To move the `Chat` to a concrete position in a favorites list, provide
  the average value of two other `Chat`s positions surrounding it.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatFavorited`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is already favorited at the same position.
  """
  favoriteChat(
    """ID of the `Chat` to mark as favorited."""
    id: ChatId!

    """Position of the `Chat` in a favorites list."""
    pos: ChatFavoritePosition!
  ): FavoriteChatResult

  """
  Removes the specified `Chat` from the favorites list of the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatUnfavorited`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is not in the favorites list already.
  """
  unfavoriteChat(
    """ID of the `Chat` to remove from the favorites list."""
    id: ChatId!
  ): UnfavoriteChatResult

  """
  Adds the specified `User` to the specified `Chat`-group by authority of
  the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionMemberAdded`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
  is a member of the specified `Chat` already.
  """
  addChatMember(
    """ID of the `User` to become a member of the `Chat`-group."""
    userId: UserId!

    """ID of the `Chat`-group to add the `User` to."""
    chatId: ChatId!
  ): AddChatMemberResult

  """
  Removes the specified `User` from the specified `Chat`-group by
  authority of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionMemberRemoved`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
  is not a member of the specified `Chat` already.
  """
  removeChatMember(
    """ID of the `User` to be removed from the `Chat`-group."""
    userId: UserId!

    """ID of the `Chat`-group to remove the `User` from."""
    chatId: ChatId!
  ): RemoveChatMemberResult

  """
  Updates the `Chat.avatar` field with the provided image, or resets it to
  `null`, by authority of the authenticated `MyUser`.

  HTTP request for this mutation must be
  `Content-Type: multipart/form-data` containing the uploaded file and the
  `file` argument must be `null`, otherwise this mutation will fail.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionAvatarUpdated`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  uses the specified `file` already as an `avatar` with the same `crop`
  area.
  """
  updateChatAvatar(
    """ID of the `Chat` to update `avatar` of."""
    chatId: ChatId!

    """
    File to use as a `ChatAvatar`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real file must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded file's size is 15 MiB.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
    """
    file: Upload

    """
    Optional area to crop the provided image file.

    Only makes sense if the image file is provided.
    """
    crop: CropAreaInput
  ): UpdateChatAvatarResult

  """
  Renames the specified `Chat` by authority of the authenticated `MyUser`.

  `Chat`-dialogs cannot be named or renamed.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemPosted` (`ChatInfo` with `ChatInfoActionNameUpdated`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  has the specified `name` already.
  """
  renameChat(
    """ID of the `Chat` to rename."""
    id: ChatId!

    """
    `ChatName` to rename the `Chat` with.

    `null` removes the current `ChatName`.
    """
    name: ChatName
  ): RenameChatResult

  """
  Clears an existing `Chat` (hides all its `ChatItem`s) for the
  authenticated `MyUser` until the specified `ChatItem` inclusively.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatCleared`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is already cleared until the specified `ChatItem`.
  """
  clearChat(
    """ID of the `Chat` to be cleared."""
    id: ChatId!

    """ID of the `ChatItem` to clear the `Chat` until (inclusively)."""
    untilId: ChatItemId!
  ): ClearChatResult

  """
  Marks the specified `Chat` as hidden for the authenticated `MyUser`.

  Hidden `Chat` is excluded from `Query.recentChats`, but preserves all
  its content. Once a new `ChatItem` posted in a `Chat` it becomes visible
  again, and so included into `Query.recentChats` as well.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatHidden`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is already hidden by the authenticated `MyUser`.
  """
  hideChat(
    """ID of the `Chat` to be hidden."""
    id: ChatId!
  ): HideChatResult

  """
  Mutes or unmutes the specified `Chat` for the authenticated `MyUser`.
  Overrides an existing mute even if it's longer.

  Muted `Chat` implies that its events don't produce sounds and
  notifications on a client side. This, however, has nothing to do with
  a server and is the responsibility to be satisfied by a client side.
  Server side may try to optimize this in some cases (like omit sending
  notifications), but a client side should not rely on any such behaviour
  and should implement best-effort muting by itself.

  Note, that `Mutation.toggleChatMute` doesn't correlate with
  `Mutation.toggleMyUserMute`. Muted `Chat` of unmuted `MyUser` should not
  produce any sounds, and so, unmuted `Chat` of muted `MyUser` should not
  produce any sounds too.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `ChatEvent` may be produced on success:
  - `EventChatMuted` (if `until` argument is not `null`);
  - `EventChatUnmuted` (if `until` argument is `null`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is already muted `until` the specified `DateTime` (or unmuted) for the
  authenticated `MyUser`.
  """
  toggleChatMute(
    """ID of the `Chat` to be muted."""
    id: ChatId!

    """
    Muting options for the `Chat`.

    `null` means unmuting.
    """
    mute: Muting
  ): ToggleChatMuteResult

  """
  Posts a new `ChatMessage` to the specified `Chat` by the authenticated
  `MyUser`.

  For the posted `ChatMessage` to be meaningful, at least one of the
  `text` or `attachments` arguments must be specified and non-empty.

  To attach some `Attachment`s to the posted `Message`, first, they should
  be uploaded with `Mutation.uploadAttachment`, and only then, the
  returned `Attachment.id`s may be used as the `attachments` argument of
  this mutation.

  `repliesTo` argument should be specified if the posted `ChatMessage` is
  going to be a reply to some other `ChatItem`s.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemPosted`.

  ## Non-idempotent

  Each time creates a new unique `ChatMessage`, producing a new
  `ChatEvent`.
  """
  postChatMessage(
    """ID of the `Chat` to post a new `ChatMessage` in."""
    chatId: ChatId!

    """
    Optional text of the posted `ChatMessage`. If not specified then `attachments` argument must be specified and non-empty.
    """
    text: ChatMessageText

    """
    Optional IDs of `Attachment`s to be attached to the posted `ChatMessage`. If
    not specified or empty then `text` argument must be specified.
    """
    attachments: [AttachmentId!]

    """
    IDs of the `ChatItem`s that the posted `ChatMessage` is replying to. The
    replied `ChatItem`s may belong to the current `Chat` only.
    """
    repliesTo: [ChatItemId!]!
  ): PostChatMessageResult!

  """
  Marks the specified `Chat` as read for the authenticated `MyUser` until
  the specified `ChatItem` inclusively.

  There is no notion of a single `ChatItem` being read or not separately
  in a `Chat`. Only a whole `Chat` as a sequence of `ChatItem`s can be
  read until some its position (concrete `ChatItem`). So, any `ChatItem`
  may be considered as read (or not) by comparing its `ChatItem.at` field
  with the `Chat.lastReads.at` field of the authenticated `MyUser`: if
  it's below (less or equal) then the `ChatItem` is read, otherwise it's
  unread.

  This mutation should be called whenever the authenticated `MyUser` reads
  new `ChatItem`s appeared in the `Chat`'s UI and directly influences the
  `Chat.unreadCount` value.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatEvent`s may be produced on success:
  - `EventChatRead`;
  - `EventChatDelivered` (if some of read `ChatItem`s were not delivered
     yet).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `Chat`
  is already read by the authenticated `MyUser` until the specified
  `ChatItem`.
  """
  readChat(
    """ID of the `Chat` to be read."""
    id: ChatId!

    """ID of the `ChatItem` to read the `Chat` until (inclusively)."""
    untilId: ChatItemId!
  ): ReadChatResult

  """
  Creates a new `Attachment` linked to the authenticated `MyUser` for a
  later use in `Mutation.postChatMessage`.

  HTTP request for this mutation must be
  `Content-Type: multipart/form-data` containing the uploaded file and the
  `attachment` argument must be `null`, otherwise this mutation will fail.

  See [GraphQL multipart request specification][1] for details.

  ## Authentication

  Mandatory.

  ## Non-idempotent

  Each time creates a new unique `Attachment`.

  [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
  """
  uploadAttachment(
    """
    File to be uploaded as an `Attachment`.

    Not really used and must be always specified as `null`. For schema declaration only.

    Real attachment data must be sent as `Content-Type: multipart/form-data` along.
    See [GraphQL multipart request specification][1] for details.

    Maximum allowed uploaded file's size is 15 MiB.

    Maximum allowed uploaded image's dimensions are 32767x32767.

    [1]: https://github.com/jaydenseric/graphql-multipart-request-spec
    """
    file: Upload
  ): UploadAttachmentResult!

  """
  Deletes the specified `ChatMessage` posted by the authenticated
  `MyUser`.

  `ChatMessage` is allowed to be deleted only when it's not read by any
  other `Chat` member and neither forwarded, nor replied. Once deleted,
  `ChatMessage` is not visible for anyone in the `Chat`.

  If this mutation returns `READ` (or `QUOTED`) error, use
  `Mutation.hideChatItem` to "remove" the `ChatMessage` for the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemDeleted`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified
  `ChatMessage` is deleted already.
  """
  deleteChatMessage(
    """ID of the `ChatMessage` to delete."""
    id: ChatItemId!
  ): DeleteChatMessageResult

  """
  Edits a `ChatMessage` by the authenticated `MyUser` with the provided
  `text`/`attachments`/`repliesTo` (at least one of three must be
  specified).

  `ChatMessage` is allowed to be edited within 5 minutes since its
  creation __or__ if it hasn't been read by any other `Chat` member yet.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemEdited`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`s) if the specified
  `ChatMessage` already has the specified `text`, `attachments` and
  `replies_to` in the same order.
  """
  editChatMessage(
    """ID of the `ChatMessage` to edit."""
    id: ChatItemId!

    """
    New text to assign to the `ChatMessage`.

    - If `null`, then the previous `ChatMessageText` will remain unchanged.
    - If `ChatMessageTextInput.new` is empty, then the previous `ChatMessageText` will be deleted.
    - Otherwise, `ChatMessageTextInput.new` will replace the previous `ChatMessageText`.

    `ChatMessageTextInput.new` can be `null` only if the resulting `ChatMessage` has at least one `Attachment`.

    Mandatory, if `attachments` and `repliesTo` arguments are missing.
    """
    text: ChatMessageTextInput

    """
    IDs of `Attachment`s to assign to the `ChatMessage`.

    - If `null`, then the previous `Attachment`s will remain unchanged.
    - If `ChatMessageAttachmentsInput.new` is empty, then the previous `ChatMessage`'s `Attachment`s will be deleted.
    - Otherwise, `ChatMessageAttachmentsInput.new` will replace the previous `Attachment`s.

    `ChatMessageAttachmentsInput.new` can be empty only if the resulting `ChatMessage` has a `ChatMessageText`.

    Mandatory, if `text` and `repliesTo` arguments are missing.
    """
    attachments: ChatMessageAttachmentsInput

    """
    IDs of the `ChatItem`s that the edited `ChatMessage` is replying to.

    - If `null`, then the previous `ChatItemQuote`s will remain unchanged.
    - If `ChatMessageRepliesInput.new` is empty, then the previous `ChatItemQuote`s will be deleted.
    - Otherwise, `ChatMessageRepliesInput.new` will replace the previous `ChatItemQuote`s.

    The replied `ChatItem`s may belong to the current `Chat` only.

    Mandatory, if `text` and `attachments` arguments are missing.
    """
    repliesTo: ChatMessageRepliesInput
  ): EditChatMessageResult

  """
  Hides the specified `ChatItem` for the authenticated `MyUser`.

  Hidden `ChatItem` is not visible only for the one who hid it, remaining
  visible for other `User`s.

  Use this mutation for "deleting" a `ChatItem` for the authenticated
  `MyUser` in `Chat`'s UI in case `Mutation.deleteChatMessage` (or
  `Mutation.deleteChatForward`) returns `READ` (or `QUOTED`) error.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemHidden`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified
  `ChatItem` is hidden by the authenticated `MyUser` already.
  """
  hideChatItem(
    """ID of the `ChatItem` to hide."""
    id: ChatItemId!
  ): HideChatItemResult

  """
  Forwards `ChatItem`s to the specified `Chat` by the authenticated
  `MyUser`.

  Supported `ChatItem`s are `ChatMessage` and `ChatForward`.

  If `text` or `attachments` argument is specified, then the forwarded
  `ChatItem`s will be followed with a posted `ChatMessage` containing that
  text and/or attachments.

  When re-forwarding a `ChatForward`, the `ChatItemQuoteInput` arguments
  should be filled, as operation is performed on the inner `ChatMessage`.
  This allows to re-forward only part of the existing `ChatForward`.
  Re-forwarding a `ChatForward` is indistinguishable from just forwarding
  its inner `ChatMessage` (`ChatItemQuote` depth will still be just 1).

  The maximum number of forwarded `ChatItem`s at once is 100.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent`s may be produced on success:
  - `EventChatItemPosted` (`ChatForward` and optionally `ChatMessage`).

  ## Non-idempotent

  Each time posts a new `ChatForward`.
  """
  forwardChatItems(
    """ID of the `Chat` to forward `ChatItem`s from."""
    from: ChatId!

    """ID of the `Chat` to forward `ChatItem`s into."""
    to: ChatId!

    """Quotes of the `ChatItem`s to be forwarded."""
    items: [ChatItemQuoteInput!]!

    """
    Optional text to post a `ChatMessage` along with the forwarded `ChatItem`s.
    """
    text: ChatMessageText

    """
    Optional IDs of `Attachment`s to be attached to the `ChatMessage` posted along with the forwarded `ChatItem`s.
    """
    attachments: [AttachmentId!]
  ): ForwardChatItemsResult!

  """
  Deletes the specified `ChatForward` posted by the authenticated
  `MyUser`.

  `ChatForward` is allowed to be deleted only when it's not read by any
  other `Chat` member and neither forwarded, nor replied. Once deleted,
  `ChatForward` is not visible for anyone in the `Chat`.

  If this mutation returns `READ` (or `QUOTED`) error, use
  `Mutation.hideChatItem` to "remove" the `ChatForward` for the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatItemDeleted`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified
  `ChatForward` is deleted already.
  """
  deleteChatForward(
    """ID of the `ChatForward` to delete."""
    id: ChatItemId!
  ): DeleteChatForwardResult

  """
  Starts a new `ChatCall` in the specified `Chat` by the authenticated
  `MyUser`.

  Once this mutation succeeds the `EventChatCallStarted` is fired to all
  `Chat` members via `Subscription.chatEvents`, and it's required to use
  `Subscription.chatCallEvents` (use the `StartChatCallOk.deviceId`
  returned by this mutation) for the authenticated `MyUser` to be able to
  react on all `ChatCallEvent`s happening during the started `ChatCall`.

  ## Lifecycle

  The best-effort `ChatCall` lifecycle on a client side should look like:
  1. Initiate (start or join) a `ChatCall` via `Mutation.startChatCall` or
     `Mutation.joinChatCall`.
  2. Make a `Subscription.chatCallEvents` using the `deviceId` from the
     previous step.
  3. Once an `EventChatCallRoomReady` is emitted (or in case a
     `ChatCall.joinLink` is present already in the initial `ChatCall`
     returned by the `Subscription.chatCallEvents` from the previous
     step), establish a WebSocket connection with a media server using the
     emitted `joinLink`.
  4. Whenever an `EventChatCallRoomReady` is emitted again, reestablish a
     WebSocket connection with a media server forcefully, using the new
     emitted `joinLink`, even if the previous one is healthy.
  5. Finish or leave the ongoing `ChatCall` via executing
     `Mutation.leaveChatCall` first, then dropping the
     `Subscription.chatCallEvents`, and, finally, dropping the WebSocket
     connection with a media server. Do not try to reconnect if the media
     server drops it earlier, after execution of the
     `Mutation.leaveChatCall`.

  ## Authentication

  Mandatory.

  ## Result

  Only of the following `ChatEvent`s may be produced on success:
  - `EventChatItemPosted` (if no `ChatCall` exists);
  - `EventChatCallStarted` (if no `ChatCall` exists);
  - `EventChatCallMemberJoined` (if `ChatCall` exists already).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`s) if there is a `ChatCall`
  in this `Chat` already and the authenticated `MyUser` is a member of it.
  Joins it if the authenticated `MyUser` is not a member yet.
  """
  startChatCall(
    """ID of the `Chat` to start a `ChatCall` in."""
    chatId: ChatId!

    """
    One-time `MyUser`'s secret credentials to authorize him with on a media server for this `ChatCall`.

    Use these credentials to establish a WebSocket connection with a media
    server after `EventChatCallRoomReady` is received via
    `Subscription.chatCallEvents`.

    Must be different per each `MyUser`'s device. Reuse these credentials for
    the same `ChatCall` (distinguish by `ChatCall.id`) and the same client
    device. Generate new credentials in any other case.
    """
    creds: ChatCallCredentials!

    """Indicates whether the `ChatCall` is intended to start with video."""
    withVideo: Boolean = false
  ): StartChatCallResult!

  """
  Moves an ongoing `ChatCall` in a `Chat`-dialog to a newly created
  `Chat`-group, optionally adding new members.

  The ongoing `ChatCall` should have its [Medea] room being created before
  moving, otherwise the `ChatCall` is not considered by this mutation as
  an ongoing one.

  Once this mutation succeeds the `EventChatCallMoved` is fired to all
  `Chat`-dialog members via `Subscription.chatCallEvents`, and it's
  required to establish a new `Subscription.chatCallEvents` using the
  emitted `EventChatCallMoved.newCallId`. Note, that the connection to the
  [Medea] room of the moved `ChatCall` should not be dropped, as it's
  simply moved to the returned `EventChatCallMoved.newCall`, ensuring
  smooth experience for the `ChatCall` members.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent`s are produced on success:
  - `EventChatCallMoved`;
  - `EventChatCallFinished`.

  ## Non-idempotent

  Each time tries to move the ongoing `ChatCall` into a new unique
  `Chat`-group.

  [Medea]: https://github.com/instrumetisto/medea
  """
  transformDialogCallIntoGroupCall(
    """ID of the `Chat`-dialog to move the ongoing `ChatCall` from."""
    chatId: ChatId!

    """
    IDs of `User`s to create the new `Chat`-group with (in addition to the existing `Chat`-dialog members).
    """
    additionalMemberIds: [UserId!]!

    """Optional name to assign to the new `Chat`-group."""
    groupName: ChatName
  ): TransformDialogCallIntoGroupCallResult

  """
  Declines the ongoing `ChatCall` in the specified `Chat` by the
  authenticated `MyUser`.

  Use this mutation when an `EventChatCallStarted` is received via
  `Subscription.chatEvents` and `MyUser` doesn't want to accept the
  `ChatCall`.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `ChatEvent`s may be produced on success:
  - `EventChatCallDeclined` (for `Chat`-groups);
  - `EventChatCallFinished` (for `Chat`-dialogs).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if there is no current
  `ChatCall`, or it is declined by the authenticated `MyUser` already.
  """
  declineChatCall(
    """ID of the `Chat` to decline a `ChatCall` in."""
    chatId: ChatId!
  ): DeclineChatCallResult

  """
  Joins the ongoing `ChatCall` in the specified `Chat` by the
  authenticated `MyUser`.

  Use this mutation when an `EventChatCallStarted` is received via
  `Subscription.chatEvents` and `MyUser` wants to accept the `ChatCall`,
  or he wants to join an ongoing `ChatCall`.

  Once this mutation succeeds the `EventChatCallMemberJoined` is fired
  to all `ChatCall` members via `Subscription.chatCallEvents`, and it's
  required to use `Subscription.chatCallEvents` (use the
  `JoinChatCallOk.deviceId` returned by this mutation) for the
  authenticated `MyUser` to be able to react on all `ChatCallEvent`s
  happening during the accepted `ChatCall`.

  ## Lifecycle

  The best-effort `ChatCall` lifecycle on a client side should look like:
  1. Initiate (start or join) a `ChatCall` via `Mutation.startChatCall` or
     `Mutation.joinChatCall`.
  2. Make a `Subscription.chatCallEvents` using the `deviceId` from the
     previous step.
  3. Once an `EventChatCallRoomReady` is emitted (or in case a
     `ChatCall.joinLink` is present already in the initial `ChatCall`
     returned by the `Subscription.chatCallEvents` from the previous
     step), establish a WebSocket connection with a media server using the
     emitted `joinLink`.
  4. Whenever an `EventChatCallRoomReady` is emitted again, reestablish a
     WebSocket connection with a media server forcefully, using the new
     emitted `joinLink`, even if the previous one is healthy.
  5. Finish or leave the ongoing `ChatCall` via executing
     `Mutation.leaveChatCall` first, then dropping the
     `Subscription.chatCallEvents`, and, finally, dropping the WebSocket
     connection with a media server. Do not try to reconnect if the media
     server drops it earlier, after execution of the
     `Mutation.leaveChatCall`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatCallMemberJoined`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
  `MyUser` joined the current `ChatCall` already (is a member of it).
  """
  joinChatCall(
    """ID of the `Chat` to accept a `ChatCall` in."""
    chatId: ChatId!

    """
    One-time `MyUser`'s secret credentials to authorize him with on a media server for this `ChatCall`.

    Use these credentials to establish a WebSocket connection with a media
    server after `EventChatCallRoomReady` is received via
    `Subscription.chatCallEvents`.

    Must be different per each `MyUser`'s device. Reuse these credentials for
    the same `ChatCall` (distinguish by `ChatCall.id`) and the same client
    device. Generate new credentials in any other case.
    """
    creds: ChatCallCredentials!
  ): JoinChatCallResult!

  """
  Leaves the ongoing `ChatCall` in the specified `Chat` by the
  authenticated `MyUser`.

  Use this mutation when the authenticated `MyUser` wants to finish or
  leave the `ChatCall` he's participating in at the moment.

  Once the authenticated `MyUser` lefts the ongoing `ChatCall` from all
  his devices, then the state of his hand specified by
  `Mutation.toggleChatCallHand` changes to lowered.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `ChatEvent`s may be produced on success:
  - `EventChatCallMemberLeft` (for `Chat`-groups);
  - `EventChatCallFinished` (for `Chat`-dialogs).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) when:
  - There is no ongoing `ChatCall` in the specified `Chat` at the moment.
  - The authenticated `MyUser` is not a member of the specified `Chat`
    already.
  - The authenticated `MyUser` is not a member of the ongoing `ChatCall`
    already.
  """
  leaveChatCall(
    """ID of the `Chat` to leave the ongoing `ChatCall` of."""
    chatId: ChatId!

    """
    ID of the `MyUser`'s device to leave the ongoing `ChatCall` from.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
    """
    deviceId: ChatCallDeviceId!
  ): LeaveChatCallResult

  """
  Removes the specified `User` from the `ChatCall` of the specified
  `Chat`-group by authority of the authenticated `MyUser`.

  If the specified `User` participates in the `ChatCall` from multiple
  devices simultaneously, then removes all the devices at once.

  Lowers the specified `User`'s hand raised by
  `Mutation.toggleChatCallHand`, if any.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatEvent`s may be produced on success:
  - `EventChatCallMemberLeft` (for each device of the `User`);
  - `EventChatCallFinished`;
  - `EventChatCallMemberUndialed` (for dialed `User`);
  - `EventChatCallDeclined` (for dialed `MyUser`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the specified `User`
  is not a `ChatCallMember` of the specified `ChatCall` already.
  """
  removeChatCallMember(
    """ID of the `User` to be removed from the `ChatCall`."""
    userId: UserId!

    """
    ID of the `Chat`-group to remove the `User` from ongoing `ChatCall` of.
    """
    chatId: ChatId!
  ): RemoveChatCallMemberResult

  """
  Redials a `User` who left or declined the ongoing `ChatCall` in the
  specified `Chat`-group by the authenticated `MyUser`.

  For using this mutation the authenticated `MyUser` must be a member of
  the ongoing `ChatCall`.

  Redialed `User` should see the `ChatCall.answered` indicator as `false`,
  and the ongoing `ChatCall` appearing in his `Query.incomingChatCallsTop`
  and `Subscription.incomingChatCallsTopEvents` again.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent` may be produced on success:
  - `EventChatCallMemberRedialed`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the redialed `User`
  didn't decline or leave the `ChatCall` yet, or has been redialed
  already.
  """
  redialChatCallMember(
    """ID of the `Chat` where the `ChatCall` is going on."""
    chatId: ChatId!

    """ID of the `User` (being `ChatMember`) to be redialed."""
    memberId: UserId!
  ): RedialChatCallMemberResult

  """
  Raises/lowers a hand of the authenticated `MyUser` in the specified
  `ChatCall`.

  Use this mutation when the authenticated `MyUser` wants to notify other
  `ChatCall` members about his desire to start talking. New
  `ChatCallMember`s always join a `ChatCall` with a lowered hand.

  For using this mutation the authenticated `MyUser` must be a member of
  the `ChatCall`.

  Raised hand is lowered automatically whenever the authenticated
  `MyUser` lefts the `ChatCall` from all his devices.

  ## Authentication

  Mandatory.

  ## Result

  One of the following `ChatEvent`s may be produced on success:
  - `EventChatCallHandRaised` (if `raised` argument is `true`);
  - `EventChatCallHandLowered` (if `raised` argument is `false`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
  `MyUser` has raised/lowered his hand already.
  """
  toggleChatCallHand(
    """ID of the `Chat` where the `ChatCall` is going on."""
    chatId: ChatId!

    """Indicator whether to raise a hand (`true`), or to lower it (`false`)."""
    raised: Boolean!
  ): ToggleChatCallHandResult

  """
  Blocks the specified `User` for the authenticated `MyUser`.

  Blocked `User`s are not able to communicate with the authenticated
  `MyUser` directly (in `Chat`-dialogs) and add him to `Chat`-groups.

  `MyUser`'s blocklist can be obtained via `Query.blocklist`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `BlocklistEvent` may be produced on success:
  - `EventBlocklistRecordAdded`.

  ## Idempotent

  Succeeds as no-op (and returns no `BlocklistEvent`) if the specified
  `User` is blocked by the authenticated `MyUser` already with the same
  `BlocklistReason`.
  """
  blockUser(
    """ID of the `User` to block."""
    id: UserId!

    """Reason to block the `User`."""
    reason: BlocklistReason
  ): BlockUserResult

  """
  Removes the specified `User` from the blocklist of the authenticated
  `MyUser`.

  Reverses the action of `Mutation.blockUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `BlocklistEvent` may be produced on success:
  - `EventBlocklistRecordRemoved`.

  ## Idempotent

  Succeeds as no-op (and returns no `BlocklistEvent`) if the specified
  `User` is not blocked by the authenticated `MyUser` already.
  """
  unblockUser(
    """ID of the `User` to remove from the blocklist."""
    id: UserId!
  ): UnblockUserResult

  """
  Creates a new `ChatDirectLink` with the specified `ChatDirectLinkSlug`
  and deletes the current active `ChatDirectLink` of the given
  `Chat`-group or the authenticated `MyUser` (if any).

  Deleted `ChatDirectLink`s can be re-created again by the original owner
  only (`MyUser` or `Chat`-group) and cannot leak to somebody else.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent`/`MyUserEvent` may be produced on success:
  - `EventChatDirectLinkCreated` (if `group_id` argument is not `null`);
  - `EventUserDirectLinkCreated` (if `group_id` argument is `null`);.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`/`MyUserEvent`) if the
  given `Chat`-group or the authenticated `MyUser` has an active
  `ChatDirectLink` with such `ChatDirectLinkSlug` already.
  """
  createChatDirectLink(
    """Slug to create the `ChatDirectLink` with."""
    slug: ChatDirectLinkSlug!

    """
    ID of the `Chat`-group to create the `ChatDirectLink` for.

    If `null` then `ChatDirectLink` will be created for the authenticated `MyUser`.
    """
    groupId: ChatId
  ): CreateChatDirectLinkResult

  """
  Deletes the current `ChatDirectLink` of the given `Chat`-group or the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatEvent`/`MyUserEvent` may be produced on success:
  - `EventChatDirectLinkDeleted` (if `group_id` argument is not `null`);
  - `EventUserDirectLinkDeleted` (if `group_id` argument is `null`);.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`/`MyUserEvent`) if the
  given `Chat`-group or the authenticated `MyUser` has no active
  `ChatDirectLink`s already.
  """
  deleteChatDirectLink(
    """
    ID of the `Chat`-group to delete the `ChatDirectLink` for.

    If `null` then `ChatDirectLink` will be deleted for the authenticated `MyUser`.
    """
    groupId: ChatId
  ): DeleteChatDirectLinkResult

  """
  Uses the specified `ChatDirectLink` by the authenticated `MyUser`,
  creating a new `Chat`-dialog (or `Chat`-monolog), or joining an existing
  `Chat`-group.

  ## Authentication

  Mandatory.

  ## Result

  Always returns the created or modified `Chat`.

  Only the following `ChatEvent` may be produced on success for the
  `Chat`-group:
  - `EventChatItemPosted` (`ChatInfo` with either `ChatInfoActionCreated`
    or `ChatInfoActionMemberAdded`).

  ## Idempotent

  Succeeds as no-op (and returns no `ChatEvent`) if the authenticated
  `MyUser` is already a member of the `Chat`-group or has already created
  the `Chat`-dialog by the specified `DirectLink`.
  """
  useChatDirectLink(
    """Slug of the `ChatDirectLink` to use."""
    slug: ChatDirectLinkSlug!
  ): UseChatDirectLinkResult!

  """
  Creates a new `ChatContact` in the authenticated `MyUser`'s address
  book.

  Initially, a new `ChatContact` can be created with no more than 20
  `ChatContactRecord`s. Use `Mutation.createChatContactRecords` to add
  more, if you need so.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatContactEvent`s may be produced on success:
  - `EventChatContactCreated`;
  - `EventChatContactEmailAdded`;
  - `EventChatContactGroupAdded`;
  - `EventChatContactPhoneAdded`;
  - `EventChatContactUserAdded`.

  ## Non-idempotent

  Each time creates a new unique `ChatContact`.
  """
  createChatContact(
    """Name to create the `ChatContact` with."""
    name: UserName!

    """
    Optional `ChatContactRecord`s to create and attach to the created `ChatContact`.
    """
    records: [ChatContactRecord!] = []
  ): CreateChatContactResult!

  """
  Marks the specified `ChatContact` as favorited for the authenticated
  `MyUser` and sets its position in the favorites list.

  To move the `ChatContact` to a concrete position in a favorites list,
  provide the average value of two other `ChatContact`s positions
  surrounding it.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatContactEvent` may be produced on success:
  - `EventChatContactFavorited`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
  `ChatContact` is already favorited at the same position.
  """
  favoriteChatContact(
    """ID of the `ChatContact` to mark as favorited."""
    id: ChatContactId!

    """Position of the `ChatContact` in a favorites list."""
    pos: ChatContactFavoritePosition!
  ): FavoriteChatContactResult

  """
  Removes the specified `ChatContact` from the favorites list of the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatContactEvent` may be produced on success:
  - `EventChatContactUnfavorited`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
  `ChatContact` is not in the favorites list already.
  """
  unfavoriteChatContact(
    """ID of the `ChatContact` to remove from the favorites list."""
    id: ChatContactId!
  ): UnfavoriteChatContactResult

  """
  Deletes the specified `ChatContact` from the authenticated `MyUser`'s
  address book.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatContactEvent` may be produced on success:
  - `EventChatContactDeleted`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
  `ChatContact` doesn't exist already.
  """
  deleteChatContact(
    """ID of the `ChatContact` to delete."""
    id: ChatContactId!
  ): ChatContactEventsVersioned

  """
  Updates the `name` of the specified `ChatContact` in the authenticated
  `MyUser`'s address book.

  ## Authentication

  Mandatory.

  ## Result

  Only the following `ChatContactEvent` may be produced on success:
  - `EventChatContactNameUpdated`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
  `ChatContact` has such name already.
  """
  updateChatContactName(
    """ID of the `ChatContact` to update `name` of."""
    id: ChatContactId!

    """Name to update the `ChatContact` with."""
    name: UserName!
  ): UpdateChatContactNameResult

  """
  Creates a new `ChatContactRecord` in the specified `ChatContact` of the
  authenticated `MyUser`'s address book.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatContactEvent`s may be produced on success:
  - `EventChatContactEmailAdded`;
  - `EventChatContactGroupAdded`;
  - `EventChatContactPhoneAdded`;
  - `EventChatContactUserAdded`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`s) if the specified
  `ChatContact` has such `ChatContactRecord` already.
  """
  createChatContactRecord(
    """ID of the `ChatContact` to create a new `ChatContactRecord` in."""
    id: ChatContactId!

    """`ChatContactRecord` to create."""
    record: ChatContactRecord!
  ): CreateChatContactRecordResult

  """
  Creates new multiple `ChatContactRecord`s in the specified `ChatContact`
  of the authenticated `MyUser`'s address book.

  No more than 20 `ChatContactRecord`s can be added at once.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatContactEvent`s may be produced on success:
  - `EventChatContactEmailAdded`;
  - `EventChatContactGroupAdded`;
  - `EventChatContactPhoneAdded`;
  - `EventChatContactUserAdded`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`s) if the specified
  `ChatContact` has such `ChatContactRecord`s already.
  """
  createChatContactRecords(
    """ID of the `ChatContact` to create new `ChatContactRecord`s in."""
    id: ChatContactId!

    """`ChatContactRecord`s to create."""
    records: [ChatContactRecord!]!
  ): CreateChatContactRecordsResult

  """
  Removes the specified `ChatContactRecord` from the specified
  `ChatContact` in the authenticated `MyUser`'s address book.

  ## Authentication

  Mandatory.

  ## Result

  The following `ChatContactEvent` may be produced on success:
  - `EventChatContactEmailRemoved`;
  - `EventChatContactGroupRemoved`;
  - `EventChatContactPhoneRemoved`;
  - `EventChatContactUserRemoved`.

  ## Idempotent

  Succeeds as no-op (and returns no `ChatContactEvent`) if the specified
  `ChatContact` has no such `ChatContactRecord` already.
  """
  deleteChatContactRecord(
    """ID of the `ChatContact` to remove the `ChatContactRecord` from."""
    id: ChatContactId!

    """`ChatContactRecord` to remove."""
    record: ChatContactRecord!
  ): DeleteChatContactRecordResult

  """
  Registers a device (Android, iOS, or Web) for receiving notifications
  via [Firebase Cloud Messaging][0].

  See [Firebase Cloud Messaging][0] documentation for how to generate
  `FcmRegistrationToken`s [for Flutter][1] and [for JavaScript][2].

  ## Localization

  You may provide the device's preferred locale via the
  [`Accept-Language` HTTP header][3], which will localize notifications to
  that device using the [best match][4] of the supported locales.

  In order to change the locale of the device, you should re-register it
  supplying the desired locale (use `Mutation.unregisterFcmDevice`, and
  then `Mutation.registerFcmDevice` once again).

  ## Authentication

  Mandatory.

  ## Result

  Always returns `null` on success.

  ## Idempotent

  Succeeds if the specified `token` is registered already.

  [0]: https://firebase.google.com/docs/cloud-messaging
  [1]: https://firebase.google.com/docs/cloud-messaging/flutter/client
  [2]: https://firebase.google.com/docs/cloud-messaging/js/client
  [3]: https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Language
  [4]: https://www.ietf.org/rfc/rfc4647.html#section-3.3
  """
  registerFcmDevice(
    """Registration token of the device to register."""
    token: FcmRegistrationToken!
  ): RegisterFcmDeviceErrorCode

  """
  Unregisters a device (Android, iOS, or Web) from receiving notifications
  via [Firebase Cloud Messaging][0].

  ## Authentication

  Mandatory.

  ## Result

  Always returns `true` on success.

  ## Idempotent

  Succeeds if the specified `token` is not registered already.

  [0]: https://firebase.google.com/docs/cloud-messaging
  """
  unregisterFcmDevice(
    """Registration token of the device to unregister."""
    token: FcmRegistrationToken!
  ): Boolean!
}

"""Mute duration of a `Chat` or the authenticated `MyUser`."""
union MuteDuration = MuteUntilDuration | MuteForeverDuration

"""Forever mute duration."""
type MuteForeverDuration {
  """
  Indicator that a `Chat` (or the authenticated `MyUser`) is muted
  forever.

  Always is `true`.
  """
  forever: Boolean!
}

"""
Mute duration until an exact `DateTime`.

Once this `DateTime` pasts (or is in the past already), it should be
considered by a client side as automatically unmuted. Server won't notify a
client side about that.
"""
type MuteUntilDuration {
  """`DateTime` until a `Chat` (or the authenticated `MyUser`) is muted."""
  until: DateTime!
}

"""
Muting input argument for `Mutation.toggleChatMute` and
`Mutation.toggleMyUserMute`.
"""
input Muting {
  """
  `DateTime` until a `Chat` (or the authenticated `MyUser`) is muted.

  `null` means indefinite muting.
  """
  duration: DateTime
}

"""`User` of a system being currently signed-in."""
type MyUser {
  """
  Unique ID of this `MyUser`.

  Once assigned it never changes.
  """
  id: UserId!

  """
  Unique number of this `MyUser`.

  `num` is intended for an easier `MyUser` identification by other
  `User`s. It's just like a telephone number in a real life.

  `num` allows `MyUser` to perform a sign-in, when combined with a
  password.

  It may be reused by another `User` in future, once this `MyUser` becomes
  unreachable (sign-in for this `MyUser` is impossible).
  """
  num: UserNum!

  """
  Unique login of this `MyUser`.

  `login` allows `MyUser` to perform a sign-in, when combined with a
  password.
  """
  login: UserLogin

  """List of email addresses of this `MyUser`."""
  emails: UserEmails!

  """List of phone numbers of this `MyUser`."""
  phones: UserPhones!

  """
  Name of this `MyUser`.

  `name` of a `MyUser` is not unique and is intended for displaying a
  `MyUser` in a well-readable form. It can be either first name, or last
  name of a `MyUser`, both of them, or even some nickname.
  """
  name: UserName

  """Arbitrary descriptive information about this `MyUser`."""
  bio: UserBio

  """
  Avatar of this `MyUser`.

  `avatar` is an image helping to identify a `MyUser` visually.
  """
  avatar: UserAvatar

  """
  Call cover of this `MyUser`.

  `callCover` is an image helping to identify a `MyUser` visually in
  `ChatCall`s.
  """
  callCover: UserCallCover

  """
  Indicator whether this `MyUser` has a password.

  Password allows `MyUser` to perform a sign-in, when combined with a
  `login`, `num`, `email` or `phone`.
  """
  hasPassword: Boolean!

  """`ChatDirectLink` to the `Chat` with this `MyUser`."""
  chatDirectLink: ChatDirectLink

  """Count of the unread `Chat`s of this `MyUser`."""
  unreadChatsCount: Int!

  """
  Online state of this `MyUser`.

  `MyUser` is considered to be online, while he is subscribed to
  `Subscription.keepOnline`.
  """
  online: UserOnlineState!

  """`Presence` of this `MyUser`."""
  presence: Presence!

  """Custom text status of this `MyUser`."""
  status: UserTextStatus

  """
  Mute state of this `MyUser`.

  Muted `MyUser` implies that all its `Chat`s events don't produce sounds
  and notifications on a client side. This, however, has nothing to do
  with a server and is the responsibility to be satisfied by a client
  side. Server side may try to optimize this in some cases (like omit
  sending notifications), but a client side should not rely on any such
  behaviour and should implement best-effort muting by itself.

  Note, that `MyUser.muted` doesn't correlate with `Chat.muted`. Muted
  `Chat` of unmuted `MyUser` (and unmuted `Chat` of muted `MyUser`) should
  not produce any sounds.
  """
  muted: MuteDuration

  """
  Returns `User`s blocked by this `MyUser` as `BlocklistRecord`s.

  ## Sorting

  Returned `User`s are sorted primarily by their blocking `DateTime`, and
  secondary by their IDs (if the blocking `DateTime` is the same), in
  descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `BlocklistRecord` pointed by the cursor
  and the requested count of `BlocklistRecord`s preceding and following
  it.

  If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  blocklist(
    """Number of next `BlocklistRecord`s to return."""
    first: Int

    """
    Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after.
    """
    after: BlocklistCursor

    """Number of prior `BlocklistRecord`s to return."""
    last: Int

    """
    Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before.
    """
    before: BlocklistCursor
  ): BlocklistConnection!

  """
  Version of this `MyUser`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: MyUserVersion!
}

"""Events happening with `MyUser`."""
union MyUserEvent = EventUserAvatarDeleted | EventUserAvatarUpdated | EventUserBioDeleted | EventUserBioUpdated | EventBlocklistRecordAdded | EventBlocklistRecordRemoved | EventUserCallCoverDeleted | EventUserCallCoverUpdated | EventUserDeleted | EventUserDirectLinkDeleted | EventUserDirectLinkUpdated | EventUserEmailAdded | EventUserEmailConfirmed | EventUserEmailDeleted | EventUserLoginUpdated | EventUserMuted | EventUserNameDeleted | EventUserNameUpdated | EventUserCameOnline | EventUserCameOffline | EventUserPasswordUpdated | EventUserPhoneAdded | EventUserPhoneConfirmed | EventUserPhoneDeleted | EventUserPresenceUpdated | EventUserStatusDeleted | EventUserStatusUpdated | EventUserUnmuted | EventUserUnreadChatsCountUpdated

"""Events emitted by `Subscription.myUserEvents`."""
union MyUserEvents = SubscriptionInitialized | MyUser | MyUserEventsVersioned

"""`MyUserEvent`s along with the corresponding `MyUserVersion`."""
type MyUserEventsVersioned {
  """`MyUserEvent`s themselves."""
  events: [MyUserEvent!]!

  """
  Actual state of the `MyUser` after the `MyUserEvent` has been emitted
  (so the returned `MyUser.ver` may differ from the `ver` of these
  `MyUserEventsVersioned`).
  """
  myUser: MyUser!

  """
  Version of the `MyUser`'s state updated by these `MyUserEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: MyUserVersion!
}

"""
Version of `MyUser`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar MyUserVersion

"""
[`PageInfo`][1] returned by a [Connection] according to
[GraphQL Cursor Connections Specification][0].

[0]: https://tinyurl.com/gql-relay
[1]: https://tinyurl.com/gql-relay#sec-Connection-Types.Fields.PageInfo
[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type PageInfo {
  """
  [Cursor] pointing to the last [Node] in [Connection]'s [Edges].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sec-Edges
  """
  endCursor: String

  """
  Indicator whether more [Edge]s exist following the set defined by the
  clients arguments.

  If the client is paginating with `first`/`after`, then `true` is
  returned if further [Edge]s exist, otherwise `false`.

  If the client is paginating with `last`/`before`, then `false` is
  returned.

  See [`PageInfo` fields spec][1] for more details.

  [1]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo.Fields
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  hasNextPage: Boolean!

  """
  [Cursor] pointing to the first [Node] in [Connection]'s [Edges].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sec-Edges
  """
  startCursor: String

  """
  Indicator whether more [Edge]s exist prior to the set defined by the
  clients arguments.

  If the client is paginating with `last`/`before`, then `true` is
  returned if prior [Edge]s exist, otherwise `false`.

  If the client is paginating with `first`/`after`, then `false` is
  returned.

  See [`PageInfo` fields spec][1] for more details.

  [1]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo.Fields
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  hasPreviousPage: Boolean!
}

"""Plain-`File` on a file storage."""
type PlainFile implements File {
  """
  [Relative reference][1] to this `PlainFile` on a file storage.

  Prepend it with a file storage URL to obtain the full link to this
  `PlainFile`.

  If `404` HTTP status code is returned while trying to download this
  `PlainFile` from a file storage, then the `PlainFile` is not ready yet.
  Back off, and retry again later.

  `403` HTTP status code, on the other hand, means that the link has been
  expired and this [relative reference][1] should be re-fetched to rebuild
  the link.

  [1]: https://www.rfc-editor.org/rfc/rfc3986#section-4.2
  """
  relativeRef: String!

  """
  [SHA-256] checksum of this `PlainFile`.

  May be `null` in case this `PlainFile` is not ready on a file storage
  yet. May be also computed on a client side, once this `PlainFile`
  is ready and successfully downloaded from a file storage.

  This checksum is especially useful if a client side requires to verify
  the integrity and authenticity of this `PlainFile`, downloaded from
  a file storage.

  Also, this checksum may be useful as a key in a client side cache,
  allowing to store `PlainFile`s in deduplicated manner.

  [SHA-256]: https://en.wikipedia.org/wiki/SHA-2
  """
  checksum: String

  """
  Size of this `PlainFile` (in bytes).

  May be `null` in case this `PlainFile` is not ready on a file storage
  yet. May be also computed on a client side, once this `PlainFile`
  is ready and successfully downloaded from a file storage.
  """
  size: Int
}

"""2D point on an image."""
type Point {
  """X coordinate of this `Point` in `px` (pixels)."""
  x: Int!

  """Y coordinate of this `Point` in `px` (pixels)."""
  y: Int!
}

"""
2D point on an image.

Same as `Point`, but for using in arguments.
"""
input PointInput {
  """X coordinate of this `PointInput` in `px` (pixels)."""
  x: Int!

  """Y coordinate of this `PointInput` in `px` (pixels)."""
  y: Int!
}

"""Error of performing `Mutation.postChatMessage`."""
type PostChatMessageError {
  """Code indicating why this error has happened."""
  code: PostChatMessageErrorCode!
}

"""Possible error codes of performing `Mutation.postChatMessage`."""
enum PostChatMessageErrorCode {
  """
  Authenticated `MyUser` is blocked by the `User` who receives the `ChatMessage`.

  This error can happen only if `Chat` represents a dialog (consists only of two `User`s).

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  Either `text` argument or at least one ID in `attachments` should be specified.

  Status code: 400 Bad Request.
  """
  NO_TEXT_AND_NO_ATTACHMENT

  """
  One of the specified `Attachment`s doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_ATTACHMENT

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  Replied `ChatItem` doesn't exist in the `Chat`.

  Status code: 404 Not Found.
  """
  UNKNOWN_REPLYING_CHAT_ITEM

  """
  List of `Attachment`s should contain at most 100 elements.

  Status code: 400 Bad Request.
  """
  WRONG_ATTACHMENTS_COUNT

  """
  List of replied `ChatItem`s should contain at most 100 elements.

  Status code: 400 Bad Request.
  """
  WRONG_REPLYING_CHAT_ITEMS_COUNT
}

"""Result of performing `Mutation.postChatMessage`."""
union PostChatMessageResult = ChatEventsVersioned | PostChatMessageError

"""Presence manually set by a `User` to himself."""
enum Presence {
  """
  `User` is currently present and expected to see notifications right
  away.

  This is the default `Presence` all `User`s have.
  """
  PRESENT

  """
  `User` is away and expected to see notifications as soon as he comes
  back.
  """
  AWAY
}

type Query {
  """
  Returns the current authenticated `MyUser`.

  ## Authentication

  Mandatory.
  """
  myUser: MyUser

  """
  Returns a `User` by its `id`.

  ## Authentication

  Optional.
  """
  user(
    """ID of the `User` to be returned."""
    id: UserId!
  ): User

  """
  Returns `User`s by their `ids`.

  ## Authentication

  Optional.
  """
  users(
    """IDs of the `User`s to be returned."""
    ids: [UserId!]!
  ): [User!]!

  """
  Searches `User`s by the given criteria.

  Exactly one of `num`/`login`/`direct_link`/`name` arguments must be
  specified (be non-`null`).

  Searching by `num`/`login`/`direct_link` is exact.

  Searching by `name` is fuzzy.

  ## Authentication

  Optional.

  ## Sorting

  Returned `User`s are sorted depending on the provided arguments:
  - If one of the `num`/`login`/`direct_link` arguments is specified, then
    an exact `User` is returned.
  - If the `name` argument is specified, then returned `User`s are sorted
    primarily by the [Levenshtein distance][0] of their `name`s, and
    secondary by their IDs (if the [Levenshtein distance][0] is the same),
    in descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `User` pointed by the cursor and the
  requested count of `User`s preceding and following it.

  If it's desired to receive the `User`, pointed by the cursor, without
  querying in both directions, one can specify `first` or `last` count as
  `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.

  [0]: https://en.wikipedia.org/wiki/Levenshtein_distance
  """
  searchUsers(
    """`UserNum` to search `User`s with."""
    num: UserNum

    """`UserLogin` to search `User`s with."""
    login: UserLogin

    """`ChatDirectLinkSlug` to search owner of."""
    directLink: ChatDirectLinkSlug

    """Part of `UserName` to fuzzy search `User` with."""
    name: UserName

    """
    Number of next `UsersEdge`s to return.

    Usable only with `name` argument.
    """
    first: Int

    """
    Cursor indicating the `UsersEdge` position to return next `UsersEdge`s after.

    Usable only with `name` argument.
    """
    after: UsersCursor

    """
    Number of prior `UsersEdge`s to return.

    Usable only with `name` argument.
    """
    last: Int

    """
    Cursor indicating the `UsersEdge` position to return prior `UsersEdge`s before.

    Usable only with `name` argument.
    """
    before: UsersCursor
  ): UsersConnection!

  """
  Returns `User`s blocked by the authenticated `MyUser` as
  `BlocklistRecord`s.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `User`s are sorted primarily by their blocking `DateTime`, and
  secondary by their IDs (if the blocking `DateTime` is the same), in
  descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `BlocklistRecord` pointed by the cursor
  and the requested count of `BlocklistRecord`s preceding and following
  it.

  If it's desired to receive the `BlocklistRecord`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  blocklist(
    """Number of next `BlocklistRecord`s to return."""
    first: Int

    """
    Cursor indicating the `BlocklistEdge` position to return next `BlocklistRecord`s after.
    """
    after: BlocklistCursor

    """Number of prior `BlocklistRecord`s to return."""
    last: Int

    """
    Cursor indicating the `BlocklistEdge` position to return prior `BlocklistRecord`s before.
    """
    before: BlocklistCursor
  ): BlocklistConnection!

  """
  Indicates whether the specified `UserLogin` is occupied by some `User`,
  or is free to be used.

  ## Authentication

  Mandatory.
  """
  checkUserLoginOccupied(
    """`UserLogin` to be checked."""
    login: UserLogin!
  ): Boolean!

  """
  Returns a `Chat` by its ID.

  The authenticated `MyUser` should be a member of the `Chat` in order to
  view it.

  ## Authentication

  Mandatory.
  """
  chat(
    """ID of the `Chat` to be returned."""
    id: ChatId!
  ): Chat

  """
  Returns a `ChatItem` by its ID.

  The authenticated `MyUser` should be a member of the `Chat` the provided
  `ChatItem` belongs to, in order to view it.

  ## Authentication

  Mandatory.
  """
  chatItem(
    """ID of the `ChatItem` to be returned."""
    id: ChatItemId!
  ): ChatItemsEdge

  """
  Returns favorite `Chat`s of the authenticated `MyUser` ordered by the
  custom order of `MyUser`'s favorites list (using `Chat.favoritePosition`
  field).

  Use `Mutation.favoriteChat` to update the position of a `Chat` in
  `MyUser`'s favorites list.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `Chat`s are sorted in the order specified by the authenticated
  `MyUser` in `Mutation.favoriteChat` descending (starting from the
  highest `ChatFavoritePosition` and finishing at the lowest).

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `Chat` pointed by the cursor and the
  requested count of `Chat`s preceding and following it.

  If it's desired to receive the `Chat`, pointed by the cursor, without
  querying in both directions, one can specify `first` or `last` count as
  `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  favoriteChats(
    """Number of next `Chat`s to return."""
    first: Int

    """
    Cursor indicating the `FavoriteChatsEdge` position to return next `Chat`s after.
    """
    after: FavoriteChatsCursor

    """Number of prior `Chat`s to return."""
    last: Int

    """
    Cursor indicating the `FavoriteChatsEdge` position to return prior `Chat`s before.
    """
    before: FavoriteChatsCursor
  ): FavoriteChatsConnection!

  """
  Returns non-hidden `Chat`s of the authenticated `MyUser` ordered
  descending by their last updating `DateTime`.

  Use the `noFavorite` argument to exclude favorited `Chat`s from the
  returned result.

  Use the `withOngoingCalls` argument to only include `Chat`s with ongoing
  `ChatCall`s into the returned result (`true`), or to exclude them
  (`false`).

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `Chat`s are sorted primarily by their last updating `DateTime`,
  and secondary by their IDs (if the last updating `DateTime` is the
  same), in descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `Chat` pointed by the cursor and the
  requested count of `Chat`s preceding and following it.

  If it's desired to receive the `Chat`, pointed by the cursor, without
  querying in both directions, one can specify `first` or `last` count as
  `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  recentChats(
    """Number of next `Chat`s to return."""
    first: Int

    """
    Cursor indicating the `RecentChatsEdge` position to return next `Chat`s after.
    """
    after: RecentChatsCursor

    """Number of prior `Chat`s to return."""
    last: Int

    """
    Cursor indicating the `RecentChatsEdge` position to return prior `Chat`s before.
    """
    before: RecentChatsCursor

    """Indicator whether favorite `Chat`s should be excluded from the result."""
    noFavorite: Boolean = false

    """
    Indicator whether only `Chat`s with ongoing calls should be included into
    the result (`true`), or whether they should be excluded from the result (`false`).
    `null` means omitting filtering by this criteria.
    """
    withOngoingCalls: Boolean = null
  ): RecentChatsConnection!

  """
  Returns a list of incoming `ChatCall`s of the authenticated `MyUser`.

  A `ChatCall` is considered incoming when:
  - it's not yet answered or declined (or the authenticated `MyUser` has
    been redialed after it was answered or declined);
  - its `Chat` is not muted by the authenticated `MyUser`;
  - its initiator is not the authenticated `MyUser`.

  This list contains `ChatCall`s which require an immediate action from
  the authenticated `MyUser` and doesn't represent any historical data.

  A new `ChatCall` appears in this list when someone other than the
  authenticated `MyUser` starts it in a `Chat`, and that `Chat` is not
  muted by the authenticated `MyUser`.

  A `ChatCall` is removed from this list when:
  - it has been finished;
  - `MyUser` executes `Mutation.joinChatCall` or
    `Mutation.declineChatCall` on it;
  - `MyUser` executes `Mutation.toggleChatMute` on its `Chat` (or
    `Mutation.toggleMyUserMute` on himself).

  Executing `Mutation.toggleMyUserMute` with `mute` argument (muting)
  makes this list always empty until the consecutive execution of
  `Mutation.toggleMyUserMute` without `mute` argument (unmuting) or
  reaching the mute's deadline.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `ChatCall`s are sorted primarily by their starting `DateTime`,
  and secondary by their IDs (if the starting `DateTime` is the same), in
  descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatCall` pointed by the cursor and the
  requested count of `ChatCall`s preceding and following it.

  If it's desired to receive the `ChatCall`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  incomingChatCalls(
    """Number of next incoming `ChatCall`s to return."""
    first: Int

    """
    Cursor indicating the `IncomingChatCallsEdge` position to return next incoming `ChatCall`s after.
    """
    after: IncomingChatCallsCursor

    """Number of prior incoming `ChatCall`s to return."""
    last: Int

    """
    Cursor indicating the `IncomingChatCallsEdge` position to return prior incoming `ChatCall`s before.
    """
    before: IncomingChatCallsCursor
  ): IncomingChatCallsConnection!

  """
  Returns a `ChatContact` by its ID.

  ## Authentication

  Mandatory.
  """
  chatContact(
    """ID of the `ChatContact` to be returned."""
    id: ChatContactId!
  ): ChatContact

  """
  Returns address book of the authenticated `MyUser` ordered
  alphabetically by `ChatContact.name`s.

  Use the `noFavorite` argument to exclude favorited `ChatContact`s from
  the returned result.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `ChatContact`s are sorted primarily and alphabetically by their
  `name`s, and secondary by their IDs (if the `name` is the same), in
  ascending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatContact` pointed by the cursor and
  the requested count of `ChatContact`s preceding and following it.

  If it's desired to receive the `ChatContact`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  chatContacts(
    """Number of next `ChatContact`s to return."""
    first: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return next `ChatContact`s after.
    """
    after: ChatContactsCursor

    """Number of prior `ChatContact`s to return."""
    last: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return prior `ChatContact`s before.
    """
    before: ChatContactsCursor

    """
    Indicator whether favorite `ChatContact`s should be excluded from the result.
    """
    noFavorite: Boolean = false
  ): ChatContactsConnection!

  """
  Searches `ChatContact`s by the given criteria.

  Exactly one of `name`/`email`/`phone` arguments must be specified (be
  non-`null`).

  Searching by `email`/`phone` is exact.

  Searching by `name` is fuzzy.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `ChatContact`s are sorted depending on the provided arguments:
  - If one of the `email`/`phone` arguments is specified, then returned
    `ChatContact`s are sorted by their `name`s (by IDs if the `name` is
    the same) in ascending order.
  - If the `name` argument is specified, then returned `ChatContact`s are
    sorted primarily by the [Levenshtein distance][0] of their `name`s,
    and secondary by their IDs (if the [Levenshtein distance][0] is the
    same), in descending order.

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatContact` pointed by the cursor and
  the requested count of `ChatContact`s preceding and following it.

  If it's desired to receive the `ChatContact`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.

  [0]: https://en.wikipedia.org/wiki/Levenshtein_distance
  """
  searchChatContacts(
    """Part of `UserName` to search `ChatContact`s with."""
    name: UserName

    """`UserEmail` to search `ChatContact`s with."""
    email: UserEmail

    """`UserPhone` to search `ChatContact`s with."""
    phone: UserPhone

    """Number of next `ChatContactsEdge`s to return."""
    first: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return next `ChatContactsEdge`s after.
    """
    after: ChatContactsCursor

    """Number of prior `ChatContactsEdge`s to return."""
    last: Int

    """
    Cursor indicating the `ChatContactsEdge` position to return prior `ChatContactsEdge`s before.
    """
    before: ChatContactsCursor
  ): ChatContactsConnection!

  """
  Returns favorited `ChatContact`s of the authenticated `MyUser` ordered
  by the custom order of `MyUser`'s favorites list (using
  `ChatContact.favoritePosition` field).

  Use `Mutation.favoriteChatContact` to update the position of a
  `ChatContact` in `MyUser`'s favorites list.

  ## Authentication

  Mandatory.

  ## Sorting

  Returned `ChatContact`s are sorted in the order specified by the
  authenticated `MyUser` in `Mutation.favoriteChatContact` descending
  (starting from the highest `ChatContactFavoritePosition` and finishing
  at the lowest).

  ## Pagination

  It's allowed to specify both `first` and `last` counts at the same time,
  provided that `after` and `before` cursors are equal. In such case the
  returned page will include the `ChatContact` pointed by the cursor and
  the requested count of `ChatContact`s preceding and following it.

  If it's desired to receive the `ChatContact`, pointed by the cursor,
  without querying in both directions, one can specify `first` or `last`
  count as `0`.

  If no arguments are provided, then `first` parameter will be considered
  as `50`.
  """
  favoriteChatContacts(
    """Number of next `ChatContact`s to return."""
    first: Int

    """
    Cursor indicating the `FavoriteChatContactsEdge` position to return next `ChatContact`s after.
    """
    after: FavoriteChatContactsCursor

    """Number of prior `ChatContact`s to return."""
    last: Int

    """
    Cursor indicating the `FavoriteChatContactsEdge` position to return prior `ChatContact`s before.
    """
    before: FavoriteChatContactsCursor
  ): FavoriteChatContactsConnection!

  """
  Returns list of `ChatContact`s of the authenticated `MyUser` the
  specified `User` is linked to (one of its `ChatContactRecord`s
  represents this `User`).

  ## Authentication

  Mandatory.

  ## Result

  Query returns `null` when:
  - No `User` exists with the specified `userId`.

  Query returns empty list when:
  - The specified `User` is not linked to any `ChatContact`s of the
    authenticated `MyUser`.
  """
  linkedChatContacts(
    """ID of the `User` returned `ChatContacts` should be linked to."""
    userId: UserId!
  ): [ChatContact!]

  """
  Returns the monolog `Chat` of the authenticated `MyUser`.

  If there is no `Chat`-monolog, the one could be created via
  `Mutation.createMonologChat`.

  ## Authentication

  Mandatory.

  ## Result

  Query returns `null` when no `Chat`-monolog exists for the authenticated
  `MyUser`.
  """
  monolog: Chat

  """
  Returns a dialog `Chat` between the specified `User` and the
  authenticated `MyUser`.

  If there is no such dialog `Chat`, the one could be created via
  `Mutation.createDialogChat`.

  ## Authentication

  Mandatory.

  ## Result

  Query returns `null` when:
  - No `User` exists with the specified `userId`.
  - No dialog `Chat` exists between the specified `User` and the
    authenticated `MyUser`.
  """
  dialog(
    """ID of the `User` to return a dialog `Chat` with."""
    userId: UserId!
  ): Chat

  """
  Counts a number of mutual `ChatContact`s between the specified `User`
  and the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Result

  Query returns `null` when:
  - No `User` exists with the specified `userId`.
  """
  mutualChatContactsCount(
    """ID of the `User` to return a number of mutual `ChatContact`s with."""
    userId: UserId!
  ): Int
}

"""Error of performing `Mutation.readChat`."""
type ReadChatError {
  """Code indicating why this error has happened."""
  code: ReadChatErrorCode!
}

"""Possible error codes of performing `Mutation.readChat`."""
enum ReadChatErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `ChatItem` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_ITEM
}

"""Result of performing `Mutation.readChat`."""
union ReadChatResult = ChatEventsVersioned | ReadChatError

"""
[Connection] with recent `Chat`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type RecentChatsConnection {
  """
  List of `Chat` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [RecentChatsEdge!]!

  """
  List of `Chat`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [Chat!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""Cursor of `recentChatsEvents` subscription."""
scalar RecentChatsCursor

"""
[Edge] with a recent `Chat`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type RecentChatsEdge {
  """
  `Chat` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: Chat!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: RecentChatsCursor!
}

"""
Initial top of `Query.recentChats` list emitted by
`Subscription.recentChatsTopEvents`.
"""
type RecentChatsTop {
  """
  List of top `Chat`s.

  ## Sorting

  Returned `Chat`s are sorted primarily by their last updating `DateTime`,
  and secondary by their IDs (if the last updating `DateTime` is the
  same), in descending order.
  """
  list: [Chat!]!
}

"""Events emitted by `Subscription.recentChatsTopEvents`."""
union RecentChatsTopEvents = SubscriptionInitialized | RecentChatsTop | EventRecentChatsTopChatUpdated | EventRecentChatsTopChatDeleted

"""Error of performing `Mutation.redialChatCallMember`."""
type RedialChatCallMemberError {
  """Code indicating why this error has happened."""
  code: RedialChatCallMemberErrorCode!
}

"""Possible error codes of performing `Mutation.redialChatCallMember`."""
enum RedialChatCallMemberErrorCode {
  """
  There is no ongoing `ChatCall` in this `Chat` at the moment.

  Status code: 404 Not Found.
  """
  NO_CALL

  """
  Authenticated `MyUser` doesn't participate in the ongoing `ChatCall`.

  Status code: 403 Forbidden.
  """
  NOT_CALL_MEMBER

  """
  Redialed `User` is not a member of this `Chat`.

  Status code: 403 Forbidden.
  """
  NOT_CHAT_MEMBER

  """
  `Chat` is not a group, so cannot redial its members.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.redialChatCallMember`."""
union RedialChatCallMemberResult = ChatCallEventsVersioned | RedialChatCallMemberError

"""
Type of a `RememberedSession`'s refresh token.

Its values are always considered to be non-empty and represent a
[valid Base64 string][1].

[1]: https://base64.guru/learn/base64-characters
"""
scalar RefreshToken

"""Possible error codes of performing `Mutation.registerFcmDevice`."""
enum RegisterFcmDeviceErrorCode {
  """
  Invalid `FcmRegistrationToken` provided.

  Status code: 400 Bad Request.
  """
  INVALID_REGISTRATION_TOKEN

  """
  Unknown `FcmRegistrationToken` provided.

  Status code: 404 Not Found.
  """
  UNKNOWN_REGISTRATION_TOKEN
}

"""
Remembered session of a `MyUser`, which allows to renew his `Session`s.
"""
type RememberedSession {
  """
  Unique `RefreshToken` of this `RememberedSession`.

  This one should be used for a `Session` renewal via
  `Mutation.renewSession` and is **NOT** usable as a
  [Bearer authentication token][1].

  [1]: https://tools.ietf.org/html/rfc6750#section-2.1
  """
  token: RefreshToken!

  """
  `DateTime` of this `RememberedSession` expiration.

  Once expired, it's not usable anymore and a new `RememberedSession`
  should be created via `Mutation.createSession`.

  Client applications are supposed to use this field for tracking
  `RememberedSession`'s expiration and sign out `MyUser`s properly.
  """
  expireAt: DateTime!

  """
  Version of this `RememberedSession`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: RememberedSessionVersion!
}

"""
Version of `RememberedSession`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar RememberedSessionVersion

"""Error of performing `Mutation.removeChatCallMember`."""
type RemoveChatCallMemberError {
  """Code indicating why this error has happened."""
  code: RemoveChatCallMemberErrorCode!
}

"""Possible error codes of performing `Mutation.removeChatCallMember`."""
enum RemoveChatCallMemberErrorCode {
  """
  `Chat` is not a group, so cannot remove members from its calls.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `User` with the provided ID is not a member of the group.

  Status code: 400 Bad Request.
  """
  NOT_MEMBER

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.removeChatCallMember`."""
union RemoveChatCallMemberResult = ChatEventsVersioned | RemoveChatCallMemberError

"""Error of performing `Mutation.removeChatMember`."""
type RemoveChatMemberError {
  """Code indicating why this error has happened."""
  code: RemoveChatMemberErrorCode!
}

"""Possible error codes of performing `Mutation.removeChatMember`."""
enum RemoveChatMemberErrorCode {
  """
  `Chat` is not a group, so cannot remove its members.

  Status code: 403 Forbidden.
  """
  NOT_GROUP

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.removeChatMember`."""
union RemoveChatMemberResult = ChatEventsVersioned | RemoveChatMemberError

"""Error of performing `Mutation.renameChat`."""
type RenameChatError {
  """Code indicating why this error has happened."""
  code: RenameChatErrorCode!
}

"""Possible error codes of performing `Mutation.renameChat`."""
enum RenameChatErrorCode {
  """
  `Chat` represents a dialog, so cannot be renamed.

  Status code: 403 Forbidden.
  """
  DIALOG

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.renameChat`."""
union RenameChatResult = ChatEventsVersioned | RenameChatError

"""Error of performing `Mutation.renewSession`."""
type RenewSessionError {
  """Code indicating why this error has happened."""
  code: RenewSessionErrorCode!
}

"""Possible error codes of performing `Mutation.renewSession`."""
enum RenewSessionErrorCode {
  """
  Provided `RefreshToken` is wrong.

  Status code: 403 Forbidden.
  """
  WRONG_REFRESH_TOKEN
}

"""Result of successful performing `Mutation.renewSession`."""
type RenewSessionOk {
  """
  Renewed `Session`.

  It will expire in 30 minutes after creation.
  """
  session: Session!

  """
  Renewed `RememberedSession`.

  Use it instead of previous one for the next `Mutation.renewSession`
  execution.

  The expiration `DateTime` of the renewed `RememberedSession` is not
  prolonged comparing to the previous one, and remains the same for the
  all `RememberedSession`s obtained via `Mutation.renewSession`.
  Use `Mutation.createSession` if you need to reset expiration `DateTime`
  of a `RememberedSession`.
  """
  remembered: RememberedSession!

  """`MyUser` that the `Session` was renewed for."""
  user: MyUser!
}

"""Result of performing `Mutation.renewSession`."""
union RenewSessionResult = RenewSessionOk | RenewSessionError

"""
Possible error codes of performing `Mutation.resendUserEmailConfirmation`.
"""
enum ResendUserEmailConfirmationErrorCode {
  """
  Exceeded limit of sending email address `ConfirmationCode`s. Try again in 1 hour.

  Status code: 403 Forbidden.
  """
  CODE_LIMIT_EXCEEDED

  """
  Authenticated `MyUser` has no unconfirmed email addresses.

  Status code: 404 Not Found.
  """
  NO_UNCONFIRMED
}

"""
Possible error codes of performing `Mutation.resendUserPhoneConfirmation`.
"""
enum ResendUserPhoneConfirmationErrorCode {
  """
  Exceeded limit of sending phone number `ConfirmationCode`s. Try again in 1 hour.

  Status code: 403 Forbidden.
  """
  CODE_LIMIT_EXCEEDED

  """
  Authenticated `MyUser` has no unconfirmed phone number.

  Status code: 404 Not Found.
  """
  NO_UNCONFIRMED
}

"""Error of performing `Mutation.resetUserPassword`."""
type ResetUserPasswordError {
  """Code indicating why this error has happened."""
  code: ResetUserPasswordErrorCode!
}

"""Possible error codes of performing `Mutation.resetUserPassword`."""
enum ResetUserPasswordErrorCode {
  """
  Provided `ConfirmationCode` is wrong or `MyUser` with the provided identifier doesn't exist.

  Status code: 403 Forbidden.
  """
  WRONG_CODE
}

"""Result of performing `Mutation.resetUserPassword`."""
union ResetUserPasswordResult = MyUserEventsVersioned | ResetUserPasswordError

"""Session of a `MyUser` being signed-in."""
type Session {
  """
  Unique authentication token of this `Session`.

  This one should be used as a [Bearer authentication token][1].

  [1]: https://tools.ietf.org/html/rfc6750#section-2.1
  """
  token: AccessToken!

  """
  `DateTime` of this `Session` expiration.

  Once expired, it's not usable anymore and a new `Session` should be
  created via `Mutation.createSession` or `Mutation.renewSession`.

  Client applications are supposed to use this field for tracking
  `Session`'s expiration and renewing it before an authentication error
  occur.
  """
  expireAt: DateTime!

  """
  Version of this `Session`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: SessionVersion!
}

"""
Version of `Session`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar SessionVersion

"""Error of performing `Mutation.startChatCall`."""
type StartChatCallError {
  """Code indicating why this error has happened."""
  code: StartChatCallErrorCode!
}

"""Possible error codes of performing `Mutation.startChatCall`."""
enum StartChatCallErrorCode {
  """
  Authenticated `MyUser` is blocked by the `User`, who responds to the `ChatCall`.

  This error can happen only if `Chat` represents a dialog (consists only of two `User`s).

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of a successful performing `Mutation.startChatCall`."""
type StartChatCallOk {
  """
  ID of the device the authenticated `MyUser` started the `ChatCall` from.

  Use this ID in `Subscription.chatCallEvents` and
  `Mutation.leaveChatCall` to distinguish between different devices of the
  authenticated `MyUser`.
  """
  deviceId: ChatCallDeviceId!

  """
  The only `ChatEvent`s which may be produced by performing
  `Mutation.startChatCall`:
  - `EventChatItemPosted` (if no `ChatCall` exists);
  - `EventChatCallStarted` (if no `ChatCall` exists);
  - `EventChatCallMemberJoined` (if `ChatCall` exists already).

  `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

"""Result of performing `Mutation.startChatCall`."""
union StartChatCallResult = StartChatCallOk | StartChatCallError

type Subscription {
  """
  Subscribes to `UserEvent`s of the specified `User`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`, or immediately completes (without emitting
  anything) if such `User` doesn't exist.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Result

  If `ver` argument is not specified (or is `null`) an initial state of
  the `User` will be emitted after `SubscriptionInitialized` and before
  any other `UserEvent`s (and won't be emitted ever again until this
  subscription completes). This allows to skip doing `Query.user` before
  establishing this subscription.

  If the specified `ver` is not fresh (was queried quite a time ago), it
  may become stale, so this subscription will return `STALE_VERSION` error
  on initialization. In such case:
  - either a fresh version should be obtained via `Query.user`;
  - or a re-subscription should be done without specifying a `ver`
    argument (so the fresh `ver` may be obtained in the emitted initial
    state of the `User`).

  ## Completion

  Finite.

  Completes without re-subscription necessity when:
  - The specified `User` is deleted (emits `EventUserDeleted` and
    completes).
  - The specified `User` doesn't exist (emits nothing, completes
    immediately after being established).

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).

  ## Idempotency

  This subscription could emit the same `EventUserDeleted` multiple times,
  so a client side is expected to handle it idempotently considering the
  `User.ver`.
  """
  userEvents(
    """ID of the `User` to subscribe onto."""
    id: UserId!

    """
    `User.ver` to start returning `UserEvent`s from.

    If omitted (or is `null`) then an initial state of the `User` will be
    emitted after `SubscriptionInitialized` and before any other `UserEvent`s.
    """
    ver: UserVersion
  ): UserEvents!

  """
  Subscribes to `MyUserEvent`s of the authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Result

  If `ver` argument is not specified (or is `null`) an initial state of
  the authenticated `MyUser` will be emitted after
  `SubscriptionInitialized` and before any other `MyUserEvent`s (and won't
  be emitted ever again until this subscription completes). This allows to
  skip calling `Query.myUser` before establishing this subscription.

  If the specified `ver` is not fresh (was queried quite a time ago), it
  may become stale, so this subscription will return `STALE_VERSION` error
  on initialization. In such case:
  - either a fresh version should be obtained via `Query.myUser`;
  - or a re-subscription should be done without specifying a `ver`
    argument (so the fresh `ver` may be obtained in the emitted initial
    state of the `MyUser`).

  ## Completion

  Finite.

  Completes without re-subscription necessity when:
  - The authenticated `MyUser` is deleted (emits `EventUserDeleted` and
    completes).

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).

  ## Idempotency

  This subscription could emit the same `EventUserDeleted` multiple times,
  so a client side is expected to handle it idempotently considering the
  `MyUser.ver`.
  """
  myUserEvents(
    """
    `MyUser.ver` to start returning `MyUserEvent`s from.

    If omitted (or is `null`) then an initial state of the `MyUser` will be
    emitted after `SubscriptionInitialized` and before any other `MyUserEvent`s.
    """
    ver: MyUserVersion
  ): MyUserEvents!

  """
  Keeps the authenticated `MyUser` online while subscribed.

  Keep this subscription up while the authenticated `MyUser` should be
  considered as online. Once this subscription begins `User.online` of
  `MyUser` becomes `UserOnline`, and once ends sets it to `UserOffline`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  keepOnline: SubscriptionInitialized!

  """
  Subscribes to updates of top `count` items of `Query.recentChats` list.

  Note, that `EventRecentChatsTopChatUpdated` informs about a `Chat`
  becoming the topmost in `Query.recentChats` list, but never about a
  `Chat` being updated itself.

  Note, that `EventRecentChatsTopChatDeleted` informs about a `Chat` being
  removed from top `count` items of `Query.recentChats` list, but never
  about a `Chat` being removed itself.

  Instead, use `Subscription.chatEvents` for being informed correctly
  about `Chat` changes.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized` followed by the initial state of the
  `RecentChatsTop` list (and they won't be emitted ever again until this
  subscription completes). Note, that emitting an empty list is possible
  valid.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  recentChatsTopEvents(
    """
    Count of top recent `Chat`s to receive updates for. Value must be in range from 1 to 100.

    Usually, you need just pass the count of `ChatConnection.nodes` returned by `Query.recentChats`.
    """
    count: Int!

    """
    Indicator whether updates regarding favorite `Chat`s should be excluded from the result.
    """
    noFavorite: Boolean = false

    """
    Indicator whether only updates regarding `Chat`s with ongoing calls should
    be included into the result (`true`), or whether they should be excluded
    from the result (`false`).
    `null` means omitting filtering by this criteria.
    """
    withOngoingCalls: Boolean = null
  ): RecentChatsTopEvents!

  """
  Subscribes to `FavoriteChatsEvent`s of all `Chat`s of the authenticated
  `MyUser`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Result

  If `ver` argument is not specified (or is `null`) an initial state of
  the `FavoriteChatsList` will be emitted after `SubscriptionInitialized`
  and before any other `FavoriteChatsEvent`s (and won't be emitted ever
  again until this subscription completes). This allows to skip doing
  `Query.favoriteChats` before establishing this subscription.

  If the specified `ver` is not fresh (was queried quite a time ago), it
  may become stale, so this subscription will return `STALE_VERSION` error
  on initialization. In such case:
  - either a fresh version should be obtained via `Query.favoriteChats`;
  - or a re-subscription should be done without specifying a `ver`
    argument (so the fresh `ver` may be obtained in the emitted initial
    state of the `FavoriteChatsList`).

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).

  ## Idempotency

  It's possible that in rare scenarios this subscription could emit an
  event which have already been applied to the state of some `Chat`, so a
  client side is expected to handle all the events idempotently
  considering the `Chat.ver`.
  """
  favoriteChatsEvents(
    """
    Version of a `FavoriteChatsList` to start returning `FavoriteChatsEvent`s from.

    Get it from `Query.favoriteChats.ver`.

    If omitted (or is `null`) then an initial state of the `FavoriteChatsList`
    will be emitted after `SubscriptionInitialized` and before any other
    `FavoriteChatsEvent`.
    """
    ver: FavoriteChatsListVersion
  ): FavoriteChatsEvents!

  """
  Subscribes to updates of top `count` items of `Query.incomingChatCalls`
  list.

  Note, that `EventIncomingChatCallsTopChatCallAdded` informs about a
  `ChatCall` becoming the topmost in `Query.incomingChatCalls` list, but
  never about a `ChatCall` being updated itself.

  Note, that `EventIncomingChatCallsTopChatCallRemoved` informs about a
  `ChatCall` being removed from top `count` items of
  `Query.incomingChatCalls` list, but never about a `ChatCall` being
  finished or removed itself.

  Instead, use `Subscription.chatCallEvents` for being informed correctly
  about `ChatCall` changes, and `Subscription.chatEvents` for being
  informed correctly about new `ChatCall`s happening in a `Chat`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized` followed by the initial state of the
  `IncomingChatCallsTop` list (and they won't be emitted ever again until
  this subscription completes). Note, that emitting an empty list is
  possible valid.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  incomingChatCallsTopEvents(
    """
    Count of top incoming `ChatCall`s to receive updates for. Value must be in range from 1 to 100.

    Usually, you need just pass the count of `IncomingChatCallConnection.nodes` returned by `Query.incomingChatCalls`.
    """
    count: Int!
  ): IncomingChatCallsTopEvents!

  """
  Subscribes to `ChatEvent`s of the specified `Chat`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`, or immediately completes (without emitting
  anything) if such `Chat` doesn't exist or `MyUser` doesn't participate
  in it.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Result

  If `ver` argument is not specified (or is `null`) an initial state of
  the `Chat` will be emitted after `SubscriptionInitialized` and before
  any other `ChatEvent`s (and won't be emitted ever again until this
  subscription completes). This allows to skip doing `Query.chat` (or
  `Query.recentChats`) before establishing this subscription.

  If the specified `ver` is not fresh (was queried quite a time ago), it
  may become stale, so this subscription will return `STALE_VERSION` error
  on initialization. In such case:
  - either a fresh version should be obtained via `Query.chat` (or
    `Query.recentChats`);
  - or a re-subscription should be done without specifying a `ver`
    argument (so the fresh `ver` may be obtained in the emitted initial
    state of the `Chat`).

  ## Completion

  Finite.

  Completes without re-subscription necessity when:
  - The `Chat` does not exist (emits nothing, completes immediately after
    being established).
  - The authenticated `MyUser` is not a member of the `Chat` at the moment
    of subscribing (emits nothing, completes immediately after being
    established).
  - The authenticated `MyUser` is no longer a member of the `Chat` (emits
    an `EventChatItemPosted` of a `ChatInfo` with
    `ChatInfoActionMemberRemoved` and completes).

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  chatEvents(
    """ID of the `Chat` to subscribe onto."""
    id: ChatId!

    """
    `Chat.ver` to start returning `ChatEvent`s from.

    If omitted (or is `null`) then an initial state of the `Chat` will be
    emitted after `SubscriptionInitialized` and before any other `ChatEvent`s.
    """
    ver: ChatVersion
  ): ChatEvents!

  """
  Subscribes to `ChatCallEvent`s of a `ChatCall`.

  This subscription is mandatory to be created after (and only after)
  executing `Mutation.startChatCall` or `Mutation.joinChatCall` as
  represents a heartbeat indication of the authenticated `MyUser`'s
  participation in a `ChatCall`. Stopping or breaking this subscription
  without leaving a `ChatCall` will end up by kicking the authenticated
  `MyUser` from the `ChatCall` by timeout (if not re-established earlier).

  Once this subscription kicks the authenticated `MyUser` from the
  `ChatCall` by timeout, it automatically lowers his hand raised by
  `Mutation.toggleChatCallHand`, if no other `MyUser`'s devices are
  participating in this `ChatCall` at the moment.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized` followed by the initial state of the
  `ChatCall` (and they won't be emitted ever again until this subscription
  completes), or immediately completes without emitting anything, if such
  `ChatCall` hasn't been found or the authenticated `MyUser` doesn't
  participate in it.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Completion

  Finite.

  Completes without re-subscription necessity when:
  - The `ChatCall` is finished (`EventChatCallFinished` is emitted).
  - The authenticated `MyUser` is no longer a member of the `ChatCall`
    (`EventChatCallMemberLeft` is emitted for the the authenticated
    `MyUser`).
  - The `ChatCall` is not found or the authenticated `MyUser` doesn't
    participate in it from the specified `MyUser`'s device (emits nothing,
    completes immediately after being established).

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  chatCallEvents(
    """ID of the ongoing `ChatCall` to subscribe onto."""
    id: ChatItemId!

    """
    ID of the `MyUser`'s device to subscribe to the ongoing `ChatCall` events from.

    Get it from `StartChatCallOk.deviceId` or `JoinChatCallOk.deviceId`.
    """
    deviceId: ChatCallDeviceId!
  ): ChatCallEvents!

  """
  Subscribes to `ChatContactEvent`s of all `ChatContact`s of the
  authenticated `MyUser`.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Result

  If `ver` argument is not specified (or is `null`) an initial state of
  the `ChatContact`s list will be emitted after `SubscriptionInitialized`
  and before any other `ChatContactEvent`s (and won't be emitted ever
  again until this subscription completes). This allows to skip doing
  `Query.chatContacts` (or `Query.favoriteChatContacts`) before
  establishing this subscription.

  If the specified `ver` is not fresh (was queried quite a time ago), it
  may become stale, so this subscription will return `STALE_VERSION` error
  on initialization. In such case:
  - either a fresh version should be obtained via `Query.chatContacts` (or
    `Query.favoriteChatContacts`);
  - or a re-subscription should be done without specifying a `ver`
    argument (so the fresh `ver` may be obtained in the emitted initial
    state of the `ChatContact`s list).

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).

  ## Idempotency

  It's possible that in rare scenarios this subscription could emit an
  event which have already been applied to the state of some
  `ChatContact`, so a client side is expected to handle all the events
  idempotently considering the `ChatContact.ver`.
  """
  chatContactsEvents(
    """
    Version of a `ChatContact`s list to start returning `ChatContactEvent`s from.

    Get it either from `Query.chatContacts.ver` or `Query.favoriteChatContacts.ver`.

    If omitted (or is `null`) then an initial state of the `ChatContact`s list
    will be emitted after `SubscriptionInitialized` and before any other
    `ChatContactEvent`s.
    """
    ver: ChatContactsListVersion
  ): ChatContactsEvents!

  """
  Notifies `ChatMember`s subscribed to `Subscription.chatTypings` about
  the authenticated `MyUser` being typing in the `Chat` at the moment.

  Keep this subscription up while the authenticated `MyUser` is typing.
  Once this subscription begins `Subscription.chatTypings` emits
  `EventChatTypingStarted`, and `EventChatTypingStopped` once it ends.

  Makes no sense for the `Chat`-monolog of the authenticated `MyUser`, so
  emits `MONOLOG` error on initialization in such case.

  ## Authentication

  Mandatory.

  ## Initialization

  Once this subscription is initialized completely, it immediately emits
  `SubscriptionInitialized`.

  If nothing has been emitted for a long period of time after establishing
  this subscription (while not being completed), it should be considered
  as an unexpected server error. This fact can be used on a client side to
  decide whether this subscription has been initialized successfully.

  ## Completion

  Infinite.

  Completes requiring a re-subscription when:
  - Authenticated `Session` expires (`SESSION_EXPIRED` error is emitted).
  - An error occurs on the server (error is emitted).
  - The server is shutting down or becoming unreachable (unexpectedly
    completes after initialization).
  """
  keepTyping(
    """ID of the `Chat` to type in."""
    chatId: ChatId!
  ): SubscriptionInitialized!
}

"""
Indicator notifying about a GraphQL subscription being successfully
initialized.
"""
type SubscriptionInitialized {
  """Always `true`."""
  ok: Boolean!
}

"""
[Base64URL]-encoded [ThumbHash].

[Base64URL]: https://base64.guru/standards/base64url
[ThumbHash]: https://evanw.github.io/thumbhash
"""
scalar ThumbHash

"""Error of performing `Mutation.toggleChatCallHand`."""
type ToggleChatCallHandError {
  """Code indicating why this error has happened."""
  code: ToggleChatCallHandErrorCode!
}

"""Possible error codes of performing `Mutation.toggleChatCallHand`."""
enum ToggleChatCallHandErrorCode {
  """
  There is no ongoing `ChatCall` in this `Chat` at the moment.

  Status code: 404 Not Found.
  """
  NO_CALL

  """
  Authenticated `MyUser` doesn't participate in the ongoing `ChatCall`.

  Status code: 403 Forbidden.
  """
  NOT_CALL_MEMBER

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.toggleChatCallHand`."""
union ToggleChatCallHandResult = ChatCallEventsVersioned | ToggleChatCallHandError

"""Error of performing `Mutation.toggleChatMute`."""
type ToggleChatMuteError {
  """Code indicating why this error has happened."""
  code: ToggleChatMuteErrorCode!
}

"""Possible error codes of performing `Mutation.toggleChatMute`."""
enum ToggleChatMuteErrorCode {
  """
  `Chat` represents a monolog, so cannot be (un)muted.

  Status code: 403 Forbidden.
  """
  MONOLOG

  """
  Mute duration cannot be shorter than one minute.

  Status code: 400 Bad Request.
  """
  TOO_SHORT

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.toggleChatMute`."""
union ToggleChatMuteResult = ChatEventsVersioned | ToggleChatMuteError

"""Error of performing `Mutation.toggleMyUserMute`."""
type ToggleMyUserMuteError {
  """Code indicating why this error has happened."""
  code: ToggleMyUserMuteErrorCode!
}

"""Possible error codes of performing `Mutation.toggleMyUserMute`."""
enum ToggleMyUserMuteErrorCode {
  """
  Mute duration cannot be shorter than one minute.

  Status code: 400 Bad Request.
  """
  TOO_SHORT
}

"""Result of performing `Mutation.toggleMyUserMute`."""
union ToggleMyUserMuteResult = MyUserEventsVersioned | ToggleMyUserMuteError

"""Error of performing `Mutation.transformDialogCallIntoGroupCall`."""
type TransformDialogCallIntoGroupCallError {
  """Code indicating why this error has happened."""
  code: TransformDialogCallIntoGroupCallErrorCode!
}

"""
Possible error codes of performing `Mutation.transformDialogCallIntoGroupCall`.
"""
enum TransformDialogCallIntoGroupCallErrorCode {
  """
  Authenticated `MyUser` is blocked by one of the specified members.

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  There is no ongoing `ChatCall` in this `Chat` at the moment.

  Status code: 404 Not Found.
  """
  NO_CALL

  """
  Specified `Chat` is not a dialog, so its call cannot be transformed into a group call.

  Status code: 403 Forbidden.
  """
  NOT_DIALOG

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER

  """
  `Chat` cannot be created with more than 100 initial members.

  Status code: 400 Bad Request.
  """
  WRONG_MEMBERS_COUNT
}

"""Result of performing `Mutation.transformDialogCallIntoGroupCall`."""
union TransformDialogCallIntoGroupCallResult = ChatEventsVersioned | TransformDialogCallIntoGroupCallError

"""Error of performing `Mutation.unblockUser`."""
type UnblockUserError {
  """Code indicating why this error has happened."""
  code: UnblockUserErrorCode!
}

"""Possible error codes of performing `Mutation.unblockUser`."""
enum UnblockUserErrorCode {
  """
  `User` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_USER
}

"""Result of performing `Mutation.unblockUser`."""
union UnblockUserResult = BlocklistEventsVersioned | UnblockUserError

"""Error of performing `Mutation.unfavoriteChatContact`."""
type UnfavoriteChatContactError {
  """Code indicating why this error has happened."""
  code: UnfavoriteChatContactErrorCode!
}

"""Possible error codes of performing `Mutation.unfavoriteChatContact`."""
enum UnfavoriteChatContactErrorCode {
  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT
}

"""Result of performing `Mutation.unfavoriteChatContact`."""
union UnfavoriteChatContactResult = ChatContactEventsVersioned | UnfavoriteChatContactError

"""Error of performing `Mutation.unfavoriteChat`."""
type UnfavoriteChatError {
  """Code indicating why this error has happened."""
  code: UnfavoriteChatErrorCode!
}

"""Possible error codes of performing `Mutation.unfavoriteChat`."""
enum UnfavoriteChatErrorCode {
  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT
}

"""Result of performing `Mutation.unfavoriteChat`."""
union UnfavoriteChatResult = ChatEventsVersioned | UnfavoriteChatError

"""Error of performing `Mutation.updateChatAvatar`."""
type UpdateChatAvatarError {
  """Code indicating why this error has happened."""
  code: UpdateChatAvatarErrorCode!
}

"""Possible error codes of performing `Mutation.updateChatAvatar`."""
enum UpdateChatAvatarErrorCode {
  """
  `Chat` represents a dialog, so cannot have avatars.

  Status code: 403 Forbidden.
  """
  DIALOG

  """
  Point coordinates of `crop` area are negative or bigger than original image dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_COORDINATES

  """
  Top left point coordinates of `crop` area must be smaller than bottom right
  ones and `crop` area dimensions must be greater than zero.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_POINTS

  """
  Uploaded image has too big dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_DIMENSIONS

  """
  Uploaded file is too big or zero in size.

  Status code: 400 Bad Request.
  """
  INVALID_SIZE

  """
  Uploaded file cannot be decoded as an image.

  Status code: 400 Bad Request.
  """
  MALFORMED

  """
  `Chat` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT

  """
  Uploaded file has unsupported MIME type.

  Status code: 400 Bad Request.
  """
  UNSUPPORTED_FORMAT
}

"""Result of performing `Mutation.updateChatAvatar`."""
union UpdateChatAvatarResult = ChatEventsVersioned | UpdateChatAvatarError

"""Error of performing `Mutation.updateChatContactName`."""
type UpdateChatContactNameError {
  """Code indicating why this error has happened."""
  code: UpdateChatContactNameErrorCode!
}

"""Possible error codes of performing `Mutation.updateChatContactName`."""
enum UpdateChatContactNameErrorCode {
  """
  `ChatContact` with the provided ID doesn't exist.

  Status code: 404 Not Found.
  """
  UNKNOWN_CHAT_CONTACT
}

"""Result of performing `Mutation.updateChatContactName`."""
union UpdateChatContactNameResult = ChatContactEventsVersioned | UpdateChatContactNameError

"""Error of performing `Mutation.updateUserAvatar`."""
type UpdateUserAvatarError {
  """Code indicating why this error has happened."""
  code: UpdateUserAvatarErrorCode!
}

"""Possible error codes of performing `Mutation.updateUserAvatar`."""
enum UpdateUserAvatarErrorCode {
  """
  Point coordinates of `crop` area are negative or bigger than original image dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_COORDINATES

  """
  Top left point coordinates of `crop` area must be smaller than bottom right
  ones and `crop` area dimensions must be greater than zero.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_POINTS

  """
  Uploaded image has too big dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_DIMENSIONS

  """
  Uploaded file is too big or zero in size.

  Status code: 400 Bad Request.
  """
  INVALID_SIZE

  """
  Uploaded file cannot be decoded as an image.

  Status code: 400 Bad Request.
  """
  MALFORMED

  """
  Uploaded file has unsupported MIME type.

  Status code: 400 Bad Request.
  """
  UNSUPPORTED_FORMAT
}

"""Result of performing `Mutation.updateUserAvatar`."""
union UpdateUserAvatarResult = MyUserEventsVersioned | UpdateUserAvatarError

"""Error of performing `Mutation.updateUserCallCover`."""
type UpdateUserCallCoverError {
  """Code indicating why this error has happened."""
  code: UpdateUserCallCoverErrorCode!
}

"""Possible error codes of performing `Mutation.updateUserCallCover`."""
enum UpdateUserCallCoverErrorCode {
  """
  Point coordinates of `crop` area are negative or bigger than original image dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_COORDINATES

  """
  Top left point coordinates of `crop` area must be smaller than bottom right
  ones and `crop` area dimensions must be greater than zero.

  Status code: 400 Bad Request.
  """
  INVALID_CROP_POINTS

  """
  Uploaded image has too big dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_DIMENSIONS

  """
  Uploaded file is too big or zero in size.

  Status code: 400 Bad Request.
  """
  INVALID_SIZE

  """
  Uploaded file cannot be decoded as an image.

  Status code: 400 Bad Request.
  """
  MALFORMED

  """
  Uploaded file has unsupported MIME type.

  Status code: 400 Bad Request.
  """
  UNSUPPORTED_FORMAT
}

"""Result of performing `Mutation.updateUserCallCover`."""
union UpdateUserCallCoverResult = MyUserEventsVersioned | UpdateUserCallCoverError

"""Error of performing `Mutation.updateUserLogin`."""
type UpdateUserLoginError {
  """Code indicating why this error has happened."""
  code: UpdateUserLoginErrorCode!
}

"""Possible error codes of performing `Mutation.updateUserLogin`."""
enum UpdateUserLoginErrorCode {
  """
  Provided login is occupied by another `User` already.

  Status code: 409 Conflict.
  """
  OCCUPIED
}

"""Result of performing `Mutation.updateUserLogin`."""
union UpdateUserLoginResult = MyUserEventsVersioned | UpdateUserLoginError

"""Error of performing `Mutation.updateUserPassword`."""
type UpdateUserPasswordError {
  """Code indicating why this error has happened."""
  code: UpdateUserPasswordErrorCode!
}

"""Possible error codes of performing `Mutation.updateUserPassword`."""
enum UpdateUserPasswordErrorCode {
  """
  Provided `old` password of `MyUser` is wrong.

  Status code: 403 Forbidden.
  """
  WRONG_OLD_PASSWORD
}

"""Result of performing `Mutation.updateUserPassword`."""
union UpdateUserPasswordResult = MyUserEventsVersioned | UpdateUserPasswordError

"""
Type of [GraphQL multipart request][1] upload.

It's intended to be used as a `null`able type (e.g., `Upload`) only in GraphQL
schema, and its values should always be `null`.

[1]: https://github.com/jaydenseric/graphql-multipart-request-spec
"""
scalar Upload

"""Error of performing `Mutation.uploadAttachment`."""
type UploadAttachmentError {
  """Code indicating why this error has happened."""
  code: UploadAttachmentErrorCode!
}

"""Possible error codes of performing `Mutation.uploadAttachment`."""
enum UploadAttachmentErrorCode {
  """
  Uploaded image has too big dimensions.

  Status code: 400 Bad Request.
  """
  INVALID_DIMENSIONS

  """
  Uploaded file is too big or zero in size.

  Status code: 400 Bad Request.
  """
  INVALID_SIZE

  """
  Uploaded image cannot be decoded as an image.

  Status code: 400 Bad Request.
  """
  MALFORMED

  """
  No filename found in a [Content-Disposition][1] header.

  [1]: https://mdn.io/Web/HTTP/Headers/Content-Disposition

  Status code: 400 Bad Request.
  """
  NO_FILENAME
}

"""Result of a successful performing `Mutation.uploadAttachment`."""
type UploadAttachmentOk {
  """Uploaded `Attachment`."""
  attachment: Attachment!
}

"""Result of performing `Mutation.uploadAttachment`."""
union UploadAttachmentResult = UploadAttachmentOk | UploadAttachmentError

"""Error of performing `Mutation.useChatDirectLink`."""
type UseChatDirectLinkError {
  """Code indicating why this error has happened."""
  code: UseChatDirectLinkErrorCode!
}

"""Possible error codes of performing `Mutation.useChatDirectLink`."""
enum UseChatDirectLinkErrorCode {
  """
  Authenticated `MyUser` is blocked by the responder.

  Status code: 403 Forbidden.
  """
  BLOCKED

  """
  `ChatDirectLink` with the provided slug doesn't exist or is not active anymore.

  Status code: 404 Not Found.
  """
  UNKNOWN_DIRECT_LINK
}

"""Result of a successful performing `Mutation.useChatDirectLink`."""
type UseChatDirectLinkOk {
  """Created or modified `Chat`."""
  chat: Chat!

  """
  The only `ChatEvent` which may be produced by performing
  `Mutation.useChatDirectLink`:
  - `EventChatItemPosted` (`ChatInfo` with either `ChatInfoActionCreated`
    or `ChatInfoActionMemberAdded`).

  `null` means no-op due to idempotency.
  """
  event: ChatEventsVersioned
}

"""Result of performing `Mutation.useChatDirectLink`."""
union UseChatDirectLinkResult = UseChatDirectLinkOk | UseChatDirectLinkError

"""User of a system impersonating a real person."""
type User {
  """
  Unique ID of this `User`.

  Once assigned it never changes.
  """
  id: UserId!

  """
  Unique number of this `User`.

  `num` is intended for an easier `User` identification by other `User`s.
  It's just like a telephone number in a real life.

  It may be reused by another `User` in future, once this `User` becomes
  unreachable (sign-in for this `User` is impossible).
  """
  num: UserNum!

  """
  Name of this `User`.

  `name` of a `User` is not unique and is intended for displaying an
  `User` in a well-readable form for an easier `User` identification by
  other `User`s.

  `User` is free to choose how exactly he should be displayed for other
  `User`s.
  """
  name: UserName

  """Arbitrary descriptive information about this `User`."""
  bio: UserBio

  """
  Avatar of this `User`.

  `avatar` is an image helping to identify a `User` visually.
  """
  avatar: UserAvatar

  """
  Call cover of this `User`.

  `callCover` is an image helping to identify a `User` visually in
  `ChatCall`s.
  """
  callCover: UserCallCover

  """
  Number of mutual `ChatContact`s between this `User` and the
  authenticated `MyUser`.

  Shortcut for `Query.mutualChatContactsCount` with `userId` of this
  `User`, so is not considered in the `User.ver` field.
  """
  mutualContactsCount: Int!

  """
  List of `ChatContact`s of the authenticated `MyUser` this `User` is
  linked to (one of its `ChatContactRecord`s represents this `User`).

  Shortcut for `Query.linkedChatContacts` with `userId` of this `User`, so
  is not considered in the `User.ver` field.
  """
  contacts: [ChatContact!]!

  """
  Online state of this `User`.

  Returns `null` if this `User` hid his `online` state.

  `User` is considered to be online, while he is subscribed to
  `Subscription.keepOnline`.
  """
  online: UserOnlineState

  """
  `Presence` of this `User`.

  Returns `null` if this `User` hid his `Presence`.
  """
  presence: Presence

  """Custom text status of this `User`."""
  status: UserTextStatus

  """Indicator whether this `User` is deleted."""
  isDeleted: Boolean!

  """
  Dialog `Chat` between this `User` and the authenticated `MyUser`.

  Shortcut for `Query.dialog` with `userId` of this `User`, so is not
  considered in the `User.ver` field.
  """
  dialog: Chat

  """
  Indicator whether this `User` is blocked by the authenticated `MyUser`.
  """
  isBlocked: IsBlocked!

  """
  Version of this `User`'s state.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: UserVersion!
}

"""Avatar of a `User`."""
type UserAvatar {
  """
  `CropArea` applied to the `original` `ImageFile` for creating this
  `UserAvatar`.
  """
  crop: CropArea

  """Original `ImageFile` representing this `UserAvatar`."""
  original: ImageFile!

  """
  Full-sized `ImageFile` representing this `UserAvatar`, keeping the
  `original` dimensions.
  """
  full: ImageFile!

  """
  `big` view `ImageFile` of this `UserAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to
  `250px`x`250px`.
  """
  big: ImageFile!

  """
  `medium` view `ImageFile` of this `UserAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to
  `100px`x`100px`.
  """
  medium: ImageFile!

  """
  `small` view `ImageFile` of this `UserAvatar`, square-cropped to its
  minimum dimension (either width or height), and scaled to `46px`x`46px`.
  """
  small: ImageFile!
}

"""
Type of a `User`'s bio.

Its values are always considered to be non-empty, and meet the following
requirements:
- be at least 1 and maximum 4096 characters long.
"""
scalar UserBio

"""Call cover of a `User`."""
type UserCallCover {
  """
  `CropArea` applied to the `original` `ImageFile` for creating this
  `UserCallCover`.
  """
  crop: CropArea

  """Original `ImageFile` representing this `UserCallCover`."""
  original: ImageFile!

  """
  Full-sized `ImageFile` representing this `UserCallCover`, keeping the
  `original` dimensions.
  """
  full: ImageFile!

  """
  `vertical` view `ImageFile` of this `UserCallCover`, rectangular-cropped
  to its minimum dimension (either width or height), and proportionally
  scaled to `675px`x`900px`.
  """
  vertical: ImageFile!

  """
  `square` view `ImageFile` of this `UserCallCover`, square-cropped to its
  minimum dimension (either width or height), and scaled to
  `300px`x`300px`.
  """
  square: ImageFile!
}

"""
Type of `User`'s email address.

Its values are always considered to represent a valid email address.
"""
scalar UserEmail

"""List of email addresses associated with a `MyUser`."""
type UserEmails {
  """
  List of already confirmed email addresses.

  Any `confirmed` email address can be used in combination with `password`
  to sign-in a `MyUser`.

  All `confirmed` email addresses can be used for a `password` recovery.
  """
  confirmed: [UserEmail!]!

  """
  Email address that still requires a confirmation.

  `unconfirmed` email address doesn't provide any functionality like
  `confirmed` ones do.

  `unconfirmed` email address can be moved to `confirmed` ones after
  completion of confirmation process via `Mutation.confirmUserEmail` only.
  """
  unconfirmed: UserEmail
}

"""Events happening with a `User`."""
interface UserEvent {
  """ID of the `User` this `UserEvent` is related to."""
  userId: UserId!
}

"""Events emitted by `Subscription.userEvents`."""
union UserEvents = SubscriptionInitialized | User | UserEventsVersioned | IsBlocked | BlocklistEventsVersioned

"""`UserEvent` along with the corresponding `UserVersion`."""
type UserEventsVersioned {
  """`UserEvent`s themselves."""
  events: [UserEvent!]!

  """
  Actual state of the `User` after the `UserEvent`s have been emitted (so
  the returned `User.ver` may differ from these
  `UserEventsVersioned.ver`).
  """
  user: User!

  """
  Version of the `User`'s state updated by these `UserEvent`s.

  It increases monotonically, so may be used (and is intended to) for
  tracking state's actuality.
  """
  ver: UserVersion!
}

"""Type of a `User`'s ID."""
scalar UserId

"""
Type of a `MyUser`'s login.

Its values are always considered to be non-empty and meet the following
requirements:
- have only lowercase latin letters (`a-z`), digits (`0-9`) or `_-`symbols;
- start and end with letter or digit;
- do not contain digits only;
- be at least 3 and maximum 20 characters long.
"""
scalar UserLogin

"""
Type of a `User`'s name.

Its values are always considered to be non-empty, and meet the following
requirements:
- not start and end with space-like characters;
- not contain line breaks;
- be at least 2 and maximum 100 characters long.
"""
scalar UserName

"""
Type of a `User`'s unique number.

Its values are always in range between `1_000_000_000_000_000` and
`9_999_999_999_999_999` inclusively.
"""
scalar UserNum

"""State of a `User` to be offline at the moment."""
type UserOffline {
  """
  `DateTime` when the `User` was seen online last time.

  `null` if the `User` was never seen online before.
  """
  lastSeenAt: DateTime
}

"""State of a `User` to be online at the moment."""
type UserOnline {
  """
  Indicates that the `User` is online at the moment.

  Always `true`.
  """
  online: Boolean!
}

"""Online state of a `User`."""
union UserOnlineState = UserOnline | UserOffline

"""
Type of a `MyUser`'s password.

Its values are always considered to be non-empty, and meet the following
requirements:
- not start and end with space-like characters;
- be at least 1 and maximum 250 characters long.
"""
scalar UserPassword

"""
Type of `User`'s phone number.

Its values are always considered to represent a valid phone number in
[E.164] standard international format (start with `+` sign, followed by
7-15 digits).

[E.164]: https://en.wikipedia.org/wiki/E.164
"""
scalar UserPhone

"""List of phone numbers associated with a `MyUser`."""
type UserPhones {
  """
  List of already confirmed phone numbers.

  Any `confirmed` phone number can be used in combination with `password`
  to sign-in a `MyUser`.

  All `confirmed` phone numbers can be used for a `password` recovery.
  """
  confirmed: [UserPhone!]!

  """
  Phone number that still requires a confirmation.

  `unconfirmed` phone number doesn't provide any functionality like
  `confirmed` ones do.

  `unconfirmed` phone number can be moved to `confirmed` ones after
  completion of confirmation process via `Mutation.confirmUserPhone` only.
  """
  unconfirmed: UserPhone
}

"""
[Connection] with `User`s.

[Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
"""
type UsersConnection {
  """
  List of `User` [Edges] in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [Edges]: https://tinyurl.com/gql-relay#sel-FAFFFBEAAAACBFpwI
  """
  edges: [UsersEdge!]!

  """
  List of `User`s in this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  """
  nodes: [User!]!

  """
  [PageInfo] of this [Connection].

  [Connection]: https://tinyurl.com/gql-relay#sec-Connection-Types
  [PageInfo]: https://tinyurl.com/gql-relay#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

"""Cursor of `User`s."""
scalar UsersCursor

"""
[Edge] with a `User`.

[Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
"""
type UsersEdge {
  """
  `User` [Node] at the end of this [Edge].

  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  [Node]: https://tinyurl.com/gql-relay#sec-Node
  """
  node: User!

  """
  [Cursor] of this [Edge].

  [Cursor]: https://tinyurl.com/gql-relay#sec-Cursor
  [Edge]: https://tinyurl.com/gql-relay#sec-Edge-Types
  """
  cursor: UsersCursor!
}

"""
Type of a `User`'s text status value.

Its values are always considered to be non-empty, and meet the following
requirements:
- be at least 1 and maximum 25 characters long.
"""
scalar UserTextStatus

"""
Version of `User`'s state.

It increases monotonically, so may be used (and is intended to) for tracking
state's actuality.
"""
scalar UserVersion

"""
Possible error codes of performing `Mutation.validateUserPasswordRecoveryCode`.
"""
enum ValidateUserPasswordRecoveryErrorCode {
  """
  Provided `ConfirmationCode` is wrong or `MyUser` with the provided identifier doesn't exist.

  Status code: 403 Forbidden.
  """
  WRONG_CODE
}

