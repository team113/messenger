// Copyright Â© 2022-2024 IT ENGINEERING MANAGEMENT INC,
//                       <https://github.com/team113>
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License v3.0 as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License v3.0 for
// more details.
//
// You should have received a copy of the GNU Affero General Public License v3.0
// along with this program. If not, see
// <https://www.gnu.org/licenses/agpl-3.0.html>.

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:get/get.dart';

import '/config.dart';
import '/domain/model/my_user.dart';
import '/domain/model/session.dart';
import '/domain/model/user.dart';
import '/domain/service/auth.dart';
import '/l10n/l10n.dart';
import '/provider/gql/exceptions.dart';
import '/ui/widget/text_field.dart';
import 'view.dart';

export 'view.dart';

/// Controller of a [DeleteSessionView].
class DeleteSessionController extends GetxController {
  DeleteSessionController(this._authService, {this.pop});

  /// [TextFieldState] of the [MyUser]'s password.
  late final TextFieldState password;

  /// Indicator whether the [password] should be obscured.
  final RxBool obscurePassword = RxBool(true);

  /// Callback, called when an [DeleteSessionView] this controller is bound to
  /// should be popped from the [Navigator].
  final void Function()? pop;

  /// [AuthService] used to delete a [Session].
  final AuthService _authService;

  @override
  void onInit() {
    password = TextFieldState(
      onChanged: (s) {
        password.error.value = null;

        if (s.text.isNotEmpty) {
          try {
            UserPassword(s.text);
          } on FormatException {
            s.error.value = 'err_password_incorrect'.l10n;
          }
        }
      },
      onSubmitted: (s) {
        s.unsubmit();
      },
    );

    super.onInit();
  }

  /// Deletes the provided [session].
  Future<void> deleteSession(Session session) async {
    if (password.error.value != null || password.status.value.isLoading) {
      return;
    }

    password.editable.value = false;
    password.status.value = RxStatus.loading();

    try {
      await _authService.deleteSession(
        id: session.id,
        password: UserPassword(password.text),
      );
      pop?.call();
    } on DeleteSessionException catch (e) {
      password.error.value = e.toMessage();
    } catch (e) {
      password.error.value = 'err_data_transfer'.l10n;
      rethrow;
    } finally {
      password.status.value = RxStatus.empty();
      password.editable.value = true;
    }
  }
}

/// Extension adding ability to get the device name part from a [UserAgent].
extension UserAgentExtension on UserAgent {
  /// Returns the device name part of this [UserAgent], if any, or otherwise
  /// returns the whole [UserAgent].
  String get deviceName {
    // If [UserAgent] starts with [Config.userAgentProduct], then it's probably
    // the one generated by us via [WebUtils.userAgent] method.
    if (val.startsWith(Config.userAgentProduct)) {
      final int i = val.indexOf('(');
      if (i != -1) {
        final String value = val.substring(i + 1, val.length - 1);

        final List<String> parts = value.split(';');
        if (value.contains('macOS') ||
            value.contains('Android') ||
            value.contains('iOS')) {
          if (parts.length > 1) {
            return parts[parts.length - 2].trim();
          }
        } else if (value.contains('Windows')) {
          if (parts.isNotEmpty) {
            return parts[0].split(' ').take(3).join(' ');
          }
        }
        // Linux.
        else if (parts.isNotEmpty) {
          return parts[0].split(' ').take(2).join(' ');
        }
      }
    }

    // Otherwise it may be a browser's `User-Agent` header.
    else {
      List<String> parts = val.split(' ');

      int? i;

      i = parts.indexWhere(
        (e) =>
            e.startsWith('Firefox') ||
            e.startsWith('Edg') ||
            e.startsWith('OPR') ||
            e.startsWith('Opera') ||
            e.startsWith('SamsungBrowser') ||
            e.startsWith('YaBrowser'),
      );

      if (i == -1) {
        i = parts.indexWhere((e) => e.startsWith('Chrome'));
      }

      if (i == -1) {
        i = parts.indexWhere((e) => e.startsWith('Safari'));
      }

      if (i != -1) {
        parts = parts[i].split('/');

        if (parts.length > 1) {
          String name = parts[0];
          String version = parts[1];

          name = name
              .replaceAll('OPR', 'Opera')
              .replaceAll('SamsungBrowser', 'Samsung Browser')
              .replaceAll('Edg', 'Microsoft Edge')
              .replaceAll('YaBrowser', 'Yandex Browser');

          version = version.split('.')[0];

          return '$name $version';
        }
      }
    }

    return val;
  }
}
